- `1.txt` : 額外路徑資訊

<p><img src="./image/05-09_01_p75.png"></p>

- (1)-(3) 方法不重要，因為伺服器會協助添加上去
- (4) req.getContextPath() ，背起來
- (5) 找到來源網頁用的
- (7) 抓取 1.txt 的絕對路徑，直至硬碟中真實路徑(IO 會使用)
  - 取出硬碟中的真實位置
  - 檔案不存還是可以跑
  - 用途: 檔案下載
- (8) 相當於 (4)+(5)+(6)
  - 動態取出動態的專案名稱，用於導回路徑 (p.240)
- (12) 跟 (13) 相同
- (15) 相當於 (1)+(2)+(3)+(4)+(5)+(6)
  - `串接英雄`
  - 使用性不高
  - StringBuffer 推薦使用

<p><img src="./image/05-09_02_p76.png"></p>

<p><img src="./image/05-09_03_p65.png"></p>

<p><img src="./image/05-09_04_p150.png"></p>

- 程式使用`獨立貓`測試，因為路徑最標準(規範)
- (19) 傳回檔案型態，對應 p18、89
  - 設定 contentType 用

<p><img src="./image/05-09_05_p78.png"></p>

- 使用 getContextPath() 可以轉換成動態路徑

<p><img src="./image/05-09_06_code.png"></p>

- P76: 專案路徑

<p><img src="./image/05-09_07_p242.png"></p>

- (16) `getRealPath()` 與方法 (7) 有絕對關聯，都會獲取真實路徑

  - 檔案位於本地機器內
  - 用途: 檔案上傳
  - 上傳方法
    1. 讓客戶自行新增上傳的資料夾 <sup>x</sup>
    2. 幫客戶創建資料夾在專案路徑底下，接著可用 `getServletContext().getRealPath('/images')` 抓取路徑 。
       抓取路徑: `C:\EA102_WebApp\apache-tomcat-9.0.35\webapps\IBM_9\`

- (17) 用的機會比較小

<p><img src="./image/05-09_08_p77.png"></p>

<p><img src="./image/05-09_09.png"></p>

- 自訂驗證

<p><img src="./image/05-09_10_p240.png"></p>

<p><img src="./image/05-09_11_p241.png"></p>

<p><img src="./image/05-09_12_p242.png"></p>

- `return;` 不可省略，`用於讓程式中斷於此`

<p><img src="./image/05-09_13_p242.png"></p>

<p><img src="./image/05-09_17.png"></p>

<p><img src="./image/05-09_18.png"></p>

<p><img src="./image/05-09_19_p90.png"></p>

<p><img src="./image/05-09_20_p18.png"></p>

<p><img src="./image/05-09_21_p89.png"></p>

- 使用機會不多，有可能以此機會被投入病毒

<p><img src="./image/05-09_23_code.png"></p>

- getDateHeader 不重要

<p><img src="./image/05-09_27_p79.png"></p>

<p><img src="./image/05-09_28_p17.png"></p>

<p><img src="./image/05-09_29_p18.png"></p>

<p><img src="./image/05-09_33_p19.png"></p>

# String 說明

<p><img src="./image/05-09_14.png"></p>

<p><img src="./image/05-09_15.png"></p>

<p><img src="./image/05-09_16.png"></p>

- getContentType 三種可能
  - get
    - null
  - post
    - 預設資料: application/x-www-form-urlencoded
    - 資料上傳: multipart/form-data

<p><img src="./image/05-09_30_p76.png"></p>

<p><img src="./image/05-09_31.png"></p>

<p><img src="./image/05-09_32_p182.png"></p>

<p><img src="./image/05-09_33_p19.png"></p>

<p><img src="./image/05-09_34_p183.png"></p>

<p><img src="./image/05-09_35_p118.png"></p>

<p><img src="./image/05-09_36_p65.png"></p>

<p><img src="./image/05-09_37_p80.png"></p>

- 限制癱瘓攻擊
  - 硬碟灌爆
  - 站線

<p><img src="./image/05-09_38_p82.png"></p>

<p><img src="./image/05-09_39_p297.png"></p>

# getContextPath() 練習

- 使用 getContextPath() 則目錄修改時也會同步更改，如果寫死則容易出錯

```java
//package servlet_examples;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class Hello extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {
     req.setCharacterEncoding("Big5");
    res.setContentType("text/html; charset=Big5");
    PrintWriter out = res.getWriter();

    String name = req.getParameter("name");
    out.println("<HTML>");
    out.println("<HEAD><TITLE>Hello, " + name + "</TITLE></HEAD>");
    out.println("<BODY>");
    out.println("Hello, 你好: " + name);

    out.println("<br><img src=\""+req.getContextPath()+"/images/tomcat.gif\">");
    out.println("<br><img src=\""+       "/IBM_9"      +"/images/tomcat.gif\">");
    out.println("<br><img src=\"          /IBM_9         /images/tomcat.gif\">");
    out.println("<br><img src=\"/IBM_9/images/tomcat.gif\">");
    out.println("<br><img src='/IBM_9/images/tomcat.gif'>");

    out.println("</BODY></HTML>");
  }

  public String getServletInfo() {
    return "A servlet that knows the name of the person to whom it's" +
           "saying hello";
  }
}
```

---

```cs
<html>
  <head>
    <title>Hello, peter1吳永志</title>
  </head>
  <body>
    Hello, 你好: peter1吳永志
    <br /><img src="/IBM_9/images/tomcat.gif" />
    <br /><img src="/IBM_9/images/tomcat.gif" />
    <br /><img src="          /IBM_9         /images/tomcat.gif" />
    <br /><img src="/IBM_9/images/tomcat.gif" />
    <br /><img src="/IBM_9/images/tomcat.gif" />
  </body>
</html>
```

# \*.txt (額外路徑資訊) 練習

- 步驟 1: 執行測試程式

```cs
檔案路徑: "/SL314/src/PathServlet.java"
```

```java
/*
    測試:   http://localhost:8081/SL314/PathServlet/1.txt?name1=peter1&name2=peter2
    應注意     (※1)注意當有用到【額外路徑資訊】時必須使用【前置路徑對應】的設定
    同時注意(※2)web.xml內的<url-pattern>是<url-pattern>/PathServlet/*</url-pattern>
*/

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class PathServlet extends HttpServlet {
  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {

      res.setContentType("text/plain; charset=Big5");
      PrintWriter out = res.getWriter();

      out.println("==================================context物件 - 路徑資訊及檔案服務==================================");

      out.println("req.getScheme()= "+req.getScheme());
      out.println("req.getServerName()= "+req.getServerName());
      out.println("req.getServerPort()= "+req.getServerPort());
      out.println("req.getContextPath()= "+req.getContextPath());
      out.println("req.getServletPath()= "+req.getServletPath());
      out.println("req.getPathInfo()= "+req.getPathInfo() );
      out.println("req.getPathTranslated()= "+req.getPathTranslated());
      out.println("req.getQueryString()= "+req.getQueryString());

      out.println();
      out.println("req.getRequestURI()= "+req.getRequestURI());
      out.println("【相當於req.getContextPath() + req.getServletPath() + req.getPathInfo()】");

      out.println();
      out.println("req.getMethod()= "+req.getMethod());
      out.println("req.getProtocol()= "+req.getProtocol());

      out.println();
      out.println("req.getHeader(\"Content-Type\")= "+req.getHeader("Content-Type"));
      out.println("req.getContentType()= "+req.getContentType());
      out.println("req.getContentLength()= "+req.getContentLength());

      out.println();
      out.println("req.getRequestURL()= "+req.getRequestURL());
      out.println("【StringBuffer】");
      out.println();

      out.println("==================================context物件 - 路徑資訊及檔案服務==================================");

      out.println("※ getServletContext().getRealPath(\"/xxx.gif\")= "+getServletContext().getRealPath("/xxx.gif"));

      out.println();
      out.println("※ ServletContext context = getServletContext();");
      // 若無此類型副檔名，則顯示為 null
      ServletContext context = getServletContext();
      out.println("context.getMimeType(\"/xxx.gif\")= "+context.getMimeType("/xxx.gif"));
      out.println("context.getMimeType(\"/xxx.jpg\")= "+context.getMimeType("/xxx.jpg"));
      out.println("context.getMimeType(\"/xxx.pdf\")= "+context.getMimeType("/xxx.pdf"));
      out.println("context.getMimeType(\"/xxx.doc\")= "+context.getMimeType("/xxx.doc"));
      out.println("context.getMimeType(\"/xxx.mp3\")= "+context.getMimeType("/xxx.mp3"));
      out.println("context.getMimeType(\"/xxx.avi\")= "+context.getMimeType("/xxx.avi"));
      out.println("========================================================");

    }
    public void doPost(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {
      doGet(req,res);
    }
}
```

- 步驟 2: 修改路徑

```cs
"http://localhost:8081/SL314/PathServlet/1111111111111111111111111111111111111111111111111111111111111111111111111.txt"
```

- 步驟 3: 顯示結果

```cs
==================================context物件 - 路徑資訊及檔案服務==================================
req.getScheme()= http
req.getServerName()= localhost
req.getServerPort()= 8081
req.getContextPath()= /SL314
req.getServletPath()= /PathServlet
req.getPathInfo()= /1111111111111111111111111111111111111111111111111111111111111111111111111.txt
req.getPathTranslated()= C:\EA102_WebApp\eclipse_WTP_workspace1\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\SL314\1111111111111111111111111111111111111111111111111111111111111111111111111.txt
req.getQueryString()= null

req.getRequestURI()= /SL314/PathServlet/1111111111111111111111111111111111111111111111111111111111111111111111111.txt
【相當於req.getContextPath() + req.getServletPath() + req.getPathInfo()】

req.getMethod()= GET
req.getProtocol()= HTTP/1.1

req.getHeader("Content-Type")= null
req.getContentType()= null
req.getContentLength()= -1

req.getRequestURL()= http://localhost:8081/SL314/PathServlet/1111111111111111111111111111111111111111111111111111111111111111111111111.txt
【StringBuffer】

==================================context物件 - 路徑資訊及檔案服務==================================
※ getServletContext().getRealPath("/xxx.gif")= C:\EA102_WebApp\eclipse_WTP_workspace1\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\SL314\xxx.gif

※ ServletContext context = getServletContext();
context.getMimeType("/xxx.gif")= image/gif
context.getMimeType("/xxx.jpg")= image/jpeg
context.getMimeType("/xxx.pdf")= application/pdf
context.getMimeType("/xxx.doc")= application/msword
context.getMimeType("/xxx.mp3")= audio/mpeg
context.getMimeType("/xxx.avi")= video/x-msvideo
========================================================
```

- 步驟 4: PathServlet.java 放入路徑

```cs
檔案路徑: "C:\EA102_WebApp\apache-tomcat-9.0.35\webapps\IBM_9\WEB-INF\classes"
```

- 步驟 5: 修改 web.xml，添加 PathServlet 設置

```cs
檔案路徑: "C:\EA102_WebApp\apache-tomcat-9.0.35\webapps\IBM_9\WEB-INF\web.xml"
```

```xml
<!--注意當有用到【額外路徑資訊】時必須使用【前置路徑對應】的設定  -->
<!-- 明確/前置/名稱對應 -->
<servlet>
  <servlet-name>PathServlet</servlet-name>
  <servlet-class>PathServlet</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>PathServlet</servlet-name>
  <url-pattern>/PathServlet/*</url-pattern>
</servlet-mapping>
```

- 表示路徑後方輸入任何什麼字，使用 getPathInfo 都可抓取

```cs
==================================context物件 - 路徑資訊及檔案服務==================================
req.getScheme()= http
req.getServerName()= localhost
req.getServerPort()= 8081
req.getContextPath()= /IBM_9
req.getServletPath()= /PathServlet
req.getPathInfo()= /1111111111111111111111111111111111111111111111111111111111111111111111111.txt
req.getPathTranslated()= C:\EA102_WebApp\apache-tomcat-9.0.35\webapps\IBM_9\1111111111111111111111111111111111111111111111111111111111111111111111111.txt
req.getQueryString()= null

req.getRequestURI()= /IBM_9/PathServlet/1111111111111111111111111111111111111111111111111111111111111111111111111.txt
【相當於req.getContextPath() + req.getServletPath() + req.getPathInfo()】

req.getMethod()= GET
req.getProtocol()= HTTP/1.1

req.getHeader("Content-Type")= null
req.getContentType()= null
req.getContentLength()= -1

req.getRequestURL()= http://localhost:8081/IBM_9/PathServlet/1111111111111111111111111111111111111111111111111111111111111111111111111.txt
【StringBuffer】

==================================context物件 - 路徑資訊及檔案服務==================================
※ getServletContext().getRealPath("/xxx.gif")= C:\EA102_WebApp\apache-tomcat-9.0.35\webapps\IBM_9\xxx.gif

※ ServletContext context = getServletContext();
context.getMimeType("/xxx.gif")= image/gif
context.getMimeType("/xxx.jpg")= image/jpeg
context.getMimeType("/xxx.pdf")= application/pdf
context.getMimeType("/xxx.doc")= application/msword
context.getMimeType("/xxx.mp3")= audio/mpeg
context.getMimeType("/xxx.avi")= video/x-msvideo
========================================================
```

# ViewFile 練習

```cs
圖片檔案不存在時，google瀏覽器不會提醒 File not found(IE會)
但一般搜尋時檔案一定在，所以不處理
```

- 執行程式

```cs
範例程式: "/SL314/src/servlet_examples/ViewFile.java"
測試用檔案路徑: "/SL314/WebContent/images"
```

```java
/*
   測試:   http://localhost:8081/SL314/ViewFile/images/tomcat.gif
   應注意   (※1)注意當有用到【額外路徑資訊】時必須使用【前置路徑對應】的設定
   同時注意(※2)web.xml內的<url-pattern>是<url-pattern>/ViewFile/*</url-pattern>
*/

package servlet_examples;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ViewFile extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {

    // Use a ServletOutputStream because we may pass binary information
    ServletOutputStream out = res.getOutputStream();

    // Get the file to view
    String file = req.getPathTranslated();
    System.out.println("file="+file);

    // No file, nothing to view
    if (file == null) {
      out.println("No file to view");
      return;
    }

    // Get and set the type of the file
    String contentType = getServletContext().getMimeType(file);
    res.setContentType(contentType);
    System.out.println("contentType="+contentType);

    // Return the file
    FileInputStream in = null;
    try {
      in = new FileInputStream(file);
      byte[] buf = new byte[in.available()]; // buffer
      in.read(buf);
      out.write(buf);
    } catch (FileNotFoundException e) {
      out.println("File not found");
    } catch (IOException e) {
      out.println("Problem sending file: " + e.getMessage());
    } finally {
      if (in != null)
        in.close();
    }
  }
}
```

- 測試檔案

```cs
1. "localhost:8081/SL314/ViewFile/images/tomcat.gif"
```

```cs
file=C:\EA102_WebApp\eclipse_WTP_workspace1\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\SL314\images\tomcat.gif
contentType=image/gif
```

---

```cs
2. "localhost:8081/SL314/ViewFile/images/1.txt"
```

```cs
file=C:\EA102_WebApp\eclipse_WTP_workspace1\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\SL314\images\1.txt
contentType=text/plain
```

---

```cs
3. "localhost:8081/SL314/ViewFile/images/1.pdf"
```

```cs
file=C:\EA102_WebApp\eclipse_WTP_workspace1\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\SL314\images\1.pdf
contentType=application/pdf
```

# 下載檔案

- 下載檔案 (則一)
  - `res.setContentType("application/octet-stream");`
  - `res.setContentType("application/force-download");`
- 設定 header
  - `res.setHeader("content-Disposition", "attachment; filename=\"" + (new File(file)).getName() + "\" ");`
  - 須完整填寫 `attachment; filename`

<p><img src="./image/05-09_22.png"></p>

- `attachment; filename` 只有 chrome 不用打，所以還是要填寫

```java
/*
   測試:   http://localhost:8081/SL314/ViewFile/images/tomcat.gif
   應注意   (※1)注意當有用到【額外路徑資訊】時必須使用【前置路徑對應】的設定
   同時注意(※2)web.xml內的<url-pattern>是<url-pattern>/ViewFile/*</url-pattern>
*/

package servlet_examples;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ViewFile extends HttpServlet {

  public void doGet(HttpServletRequest req, HttpServletResponse res)
                               throws ServletException, IOException {

    // Use a ServletOutputStream because we may pass binary information
    ServletOutputStream out = res.getOutputStream();

    // Get the file to view
    String file = req.getPathTranslated();
    System.out.println("file="+file);

    // No file, nothing to view
    if (file == null) {
      out.println("No file to view");
      return;
    }

    // Get and set the type of the file
    String contentType = getServletContext().getMimeType(file);
    res.setContentType("application/force-download"); // 下載檔案設定
    res.setHeader("content-Disposition", "attachment; filename=\"" + (new File(file)).getName() + "\" ");
    System.out.println("contentType="+contentType);

    // Return the file
    FileInputStream in = null;
    try {
      in = new FileInputStream(file);
      byte[] buf = new byte[in.available()]; // buffer
      in.read(buf);
      out.write(buf);
    } catch (FileNotFoundException e) {
      out.println("File not found");
    } catch (IOException e) {
      out.println("Problem sending file: " + e.getMessage());
    } finally {
      if (in != null)
        in.close();
    }
  }
}
```

- 可動態下載檔案，並依照原始檔名保存

# 長度計算總結

- 字串幾個字 length()
  陣列長度 length
  file 類別 length()
  Collection 長度 size()
  map 長度 size()
  inputString 長度 available()

# 檔案路徑對比

- 在 eclipse 上傳檔案，會在 tomcat 產生相應檔案，之後 eclipse serve 才會添加檔案

<p><img src="./image/05-09_24_code.png"></p>

- 手動在 eclipse 路徑中刪除檔案，則無法讓檔案同步產生了，也無法讀取文件
- 也不要在 tomcat 上手動刪除檔案
- 操作只在 eclipse 中操作

<p><img src="./image/05-09_25_code.png"></p>

<p><img src="./image/05-09_26_code.png"></p>

---

參考鏈接:

- [String,StringBuffer 与 StringBuilder 的区别??](https://blog.csdn.net/rmn190/article/details/1492013)
- [Apache httpd VirtualHost](http://pclevin.blogspot.com/2016/03/apache-httpd-virtualhost.html)
