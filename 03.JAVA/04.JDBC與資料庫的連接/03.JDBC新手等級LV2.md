<h1 id="top">目錄</h1>

<ul>
<li><a href='#s1'>1. BatchUpdate 批次更新</a></li>
<li><a href='#s2'>2. BatchUpdate 範例</a></li>
<li><a href='#s3'>3. 自增主鍵值 getGeneratedKeys 綁定說明</a></li>
<li><a href='#s4'>4. 自增主鍵值 getGeneratedKeys 綁定範例</a></li>
<li><a href='#s5'>5. SQL 序列號生成時可以有文字</a></li>
<li><a href='#s6'>6. BLOB / CLOB 說明</a></li>
<li><a href='#s7'>7. BLOB / CLOB 範例</a></li>
<li><a href='#s8'>8. 交易 Transaction 說明</a></li>
<li><a href='#s9'>9. 資料 rollback 方法</a></li>
<li><a href='#s10'>10. 設置 sqvePoint 並部分 rollback</a></li></ul><hr>

# <a id='s1' class='md-title' href='#top'>1. BatchUpdate 批次更新</a>

- `批次更新(Batch Update)`適用於對資料庫進行`大量更新`的行為,將要執行的 SQL 指令一次收集完畢後再送出,效能會比一次一次送出 SQL 指令要來得更好

- 透過 `addBatch()` 方法收集 SQL 指令後,將結合成一句 SQL 指令,再利用 `executeBatch()` 方法送出,其中執行 SQL 產生的例外為 BatchUpdateException

- 只適用於更新(如`新增`、`修改`或`刪除`),對於查詢功能無法支援

# <a id='s2' class='md-title' href='#top'>2. BatchUpdate 範例</a>

- 連線只要一 Connection 就會將未 commit 的動作自動 commit ， 即資料不自動 commit 的設定只在 close 前有效果，close 後還是會還原所有設定

```cs
範例連結: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestBatchUpdate_Statement.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class TestBatchUpdate_Statement {
  // MySQL URL需加上後面參數
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    Statement stat = null;
    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      stat = con.createStatement();
      stat.addBatch("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(7015, 'DAVID', 'MANAGER', TO_DATE('2016-01-01','YYYY-MM-DD'), 2500, 0.0, 40)");
      stat.addBatch("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(7016, 'KEVIN', 'CLERK', TO_DATE('2016-02-02','YYYY-MM-DD'), 800, 0.0, 20)");
      stat.addBatch("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(7017, 'VINCENT', 'SALESMAN', TO_DATE('2016-03-03','YYYY-MM-DD'), 600, 1000.0, 30)");
      stat.addBatch("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(7018, 'RON', 'ANALYST', TO_DATE('2016-04-04','YYYY-MM-DD'), 3500, 0.0, 10)");

      stat.executeBatch();

    } catch (ClassNotFoundException ce) {
      ce.printStackTrace();
    } catch (SQLException se) {
      se.printStackTrace();
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (stat != null) {
        try {
          stat.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestBatchUpdate_PreparedStatement.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestBatchUpdate_PreparedStatement {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(?, ?, ?, ?, ?, ?, ?)";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      // 預先準備SQL
      pstmt = con.prepareStatement(SQL);
      pstmt.setInt(1, 7015);
      pstmt.setString(2, "DAVID");
      pstmt.setString(3, "MANAGER");
      pstmt.setDate(4, java.sql.Date.valueOf("2016-01-01"));
      pstmt.setDouble(5, 2500);
      pstmt.setDouble(6, 0.0);
      pstmt.setInt(7, 40);
      pstmt.addBatch(); // 添加入批次

      pstmt.setInt(1, 7016);
      pstmt.setString(2, "KEVIN");
      pstmt.setString(3, "CLERK");
      pstmt.setDate(4, java.sql.Date.valueOf("2016-02-02"));
      pstmt.setDouble(5, 800);
      pstmt.setDouble(6, 0.0);
      pstmt.setInt(7, 20);
      pstmt.addBatch();

      pstmt.executeBatch();

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {

      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# <a id='s3' class='md-title' href='#top'>3. 自增主鍵值 getGeneratedKeys 綁定說明</a>

- JDBC 3.0 規範裡,當新增資料時,允許`資料庫自動產生的主鍵值`(`即 oracle 中的 sequence 序列`)綁定到 Statement 或 PreparedStatement 中

- 使用方式 (Statement):

  - int executeUpdate(String sql, int autoGeneratedKeys)
  - int executeUpdate(String sql, int[] columnIndexes)
  - int executeUpdate(String sql, String[] colunmNames)

- 使用方式 (PreparedStatement):

  - PreparedStatement preparedStatement(String sql, int autoGeneratedKeys)
  - PreparedStatement preparedStatement (String sql, int[] columnIndexes)
  - PreparedStatement preparedStatement (String sql, String[] colunmNames)

- 以 Statement 的 ResultSet `getGeneratedKeys()` 方法可取出綁定的資料庫自增主鍵值

# <a id='s4' class='md-title' href='#top'>4. 自增主鍵值 getGeneratedKeys 綁定範例</a>

- PK 對應 executeUpdate 的資料包，用於 getGeneratedKeys 綁定

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestGeneratedKeys_Statement.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

public class TestGeneratedKeys_Statement {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "INSERT INTO EMPLOYEE2(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(EMP2_SEQ.NEXTVAL, 'DAVID', 'MANAGER', TO_DATE('2016-01-01','YYYY-MM-DD'), 2500, 0.0, 40)";

  public static void main(String[] args) {
    Connection con = null;
    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      String[] cols = { "EMPNO" }; // 或是 int[] cols = {1};
      Statement stmt = con.createStatement();
      stmt.executeUpdate(SQL, cols);

      ResultSet rs = stmt.getGeneratedKeys();
      ResultSetMetaData rsmd = rs.getMetaData();
      int columnCount = rsmd.getColumnCount();
      if (rs.next()) {
        do {
          for (int i = 1; i <= columnCount; i++) {
            String key = rs.getString(i);
            System.out.println("自增主鍵值 = " + key +"(剛新增成功的員工編號)");
          }
        } while (rs.next());
      } else {
        System.out.println("NO KEYS WERE GENERATED.");
      }

      rs.close();
      stmt.close();

      Statement stmt2 = con.createStatement();
      ResultSet rs2 = stmt2.executeQuery("SELECT * FROM EMPLOYEE2");
      while (rs2.next()) {
        System.out.println("EMPNO = " + rs2.getInt(1));
        System.out.println("ENAME = " + rs2.getString(2));
        System.out.println("=================");
      }

      rs2.close();
      stmt2.close();


    } catch (ClassNotFoundException ce) {
      System.err.println(ce.getMessage());
    } catch (SQLException se) {
      System.err.println(se.getMessage());
    } finally {
      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.err.println(se.getMessage());
        }
      }
    }
  }
}
```

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestGeneratedKeys_PreparedStatement.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

public class TestGeneratedKeys_PreparedStatement {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "INSERT INTO EMPLOYEE2(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(EMP2_SEQ.NEXTVAL, ?, ?, ?, ?, ?, ?)";

  public static void main(String[] args) {
    Connection con = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      String[] cols = { "EMPNO" }; // 或 int cols[] = {1};

      PreparedStatement pstmt = con.prepareStatement(SQL, cols);
      pstmt.setString(1, "DAVID");
      pstmt.setString(2, "MANAGER");
      pstmt.setDate(3, java.sql.Date.valueOf("2016-01-01"));
      pstmt.setInt(4, 2500);
      pstmt.setDouble(5, 0.0);
      pstmt.setInt(6, 40);

      pstmt.executeUpdate();

      ResultSet rs = pstmt.getGeneratedKeys();
      ResultSetMetaData rsmd = rs.getMetaData();
      int columnCount = rsmd.getColumnCount();
      if (rs.next()) {
        do {
          for (int i = 1; i <= columnCount; i++) {
            String key = rs.getString(i);
            System.out.println("自增主鍵值 = " + key +"(剛新增成功的員工編號)");
          }
        } while (rs.next());
      } else {
        System.out.println("NO KEYS WERE GENERATED.");
      }

      rs.close();

      pstmt = con.prepareStatement("SELECT * FROM EMPLOYEE2");
      ResultSet rs2 = pstmt.executeQuery();
      while (rs2.next()) {
        System.out.println("EMPNO = " + rs2.getInt(1));
        System.out.println("ENAME = " + rs2.getString(2));
        System.out.println("=================");
      }

      rs2.close();
      pstmt.close();


    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {
      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# <a id='s5' class='md-title' href='#top'>5. SQL 序列號生成時可以有文字</a>

```sql
-- 刪除表與規則
DROP TABLE EMPLOYEE3;
DROP SEQUENCE EMP3_SEQ;

-- 創建表
CREATE TABLE EMPLOYEE3 (
 EMPNO               VARCHAR2(10),
 ENAME               VARCHAR2(10),
 JOB                 VARCHAR2(9),
 HIREDATE            DATE,
 SAL                 NUMBER(7,2),
 COMM                NUMBER(7,2),
 DEPTNO              NUMBER(2) NOT NULL,
 CONSTRAINT EMP3_EMPNO_PK PRIMARY KEY (EMPNO));

-- 建立序號規則
CREATE SEQUENCE EMP3_SEQ
INCREMENT BY 1
START WITH 1
NOMAXVALUE
NOCYCLE
NOCACHE;

-- 填充值
---- || 意思是 append 串接(文字串接)
---- lpad(序列號規則, 填充數(5), 填充值('0'))在序列號左方自動用0補滿5個位數
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'KING','PRESIDENT',TO_DATE('1981-11-17','YYYY-MM-DD'),5000.5,0.0,10);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'BLAKE','MANAGER',TO_DATE('1981-05-01','YYYY-MM-DD'),2850,0.0,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'CLARK','MANAGER',TO_DATE('1981-01-09','YYYY-MM-DD'),2450,0.0,10);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'JONES','MANAGER',TO_DATE('1981-04-02','YYYY-MM-DD'),2975,0.0,20);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'MARTIN','SALESMAN',TO_DATE('1981-09-28','YYYY-MM-DD'),1250,1400,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'ALLEN','SALESMAN',TO_DATE('1981-02-2','YYYY-MM-DD'),1600,300,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'TURNER','SALESMAN',TO_DATE('1981-09-28','YYYY-MM-DD'),1500,0,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'JAMES','CLERK',TO_DATE('1981-12-03','YYYY-MM-DD'),950,0.0,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'WARD','SALESMAN',TO_DATE('1981-02-22','YYYY-MM-DD'),1250,500,30);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'FORD','ANALYST',TO_DATE('1981-12-03','YYYY-MM-DD'),3000,0.0,20);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'SMITH','CLERK',TO_DATE('1980-12-17','YYYY-MM-DD'),800,0.0,20);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'SCOTT','ANALYST',TO_DATE('1981-12-09','YYYY-MM-DD'),3000,0.0,20);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'ADAMS','CLERK',TO_DATE('1983-01-12','YYYY-MM-DD'),1100,0.0,20);
INSERT INTO EMPLOYEE3 VALUES ('EMP' || lpad(EMP3_SEQ.NEXTVAL, 5, '0'),'MILLER','CLERK',TO_DATE('1982-01-23','YYYY-MM-DD'),1300,0.0,10);
```

# <a id='s6' class='md-title' href='#top'>6. BLOB / CLOB 說明</a>

- 若想`將檔案`(如`圖片`、`影音`資料等)`寫入資料庫`,可以在建立表格時,指定欄位資料型態為 BLOB 或 CLOB

- BLOB 全名為 Binary Large Object,`可儲存大量`的 Byte `資料`,JDBC 裡提供了 java.sql.Blob 類別,使用 setBlob()與 getBlob(),或是可以將 BLOB 欄位對應 byte[ ] ,再使用 getBytes()與 setBytes 進行操作

- CLOB 全名為 Character Large Object,可儲存大量的文字資料,JDBC 裡提供了 java.sql.Clob 類別,搭配 getCharacterStream()取得 Reader 資料或是 getAsciiStream()取得 InputStream 資料

- 註: `setBlob()`, `setClob()` 是 `JDBC 4.0` 對 BLOB 與 CLOB 的支援改進的新增方法

# <a id='s7' class='md-title' href='#top'>7. BLOB / CLOB 範例</a>

- 保存圖片

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestWriteBlob.java"
```

```java
package idv.david.advanced;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestWriteBlob {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "INSERT INTO CLUB(ID, NAME, PIC)" + "VALUES(?, ?, ?)";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      pstmt = con.prepareStatement(SQL);

      // 1. setBlob (不建議)
      pstmt.setInt(1, 1);
      pstmt.setString(2, "拜仁慕尼黑");
      Blob blob = con.createBlob(); // 一個空的容器 用來裝著拿到的圖片位元資料
      byte[] pic2 = getPictureByteArray("items/FC_Bayern.png");
      // 這邊1指的是位置(索引值)，從這個Blob容器的第一個位置開始存放位元資料
      // 步驟2能直接將此兩步驟整合
      blob.setBytes(1, pic2);
      pstmt.setBlob(3, blob);
      pstmt.executeUpdate();

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 2. setBytes (建議)
      pstmt.setInt(1, 2);
      pstmt.setString(2, "巴塞隆納");
      byte[] pic = getPictureByteArray("items/FC_Barcelona.png");
      pstmt.setBytes(3, pic);
      pstmt.executeUpdate();

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 3. setBinaryStream
      pstmt.setInt(1, 3);
      pstmt.setString(2, "皇家馬德里");
      InputStream is = getPictureStream("items/FC_Real_Madrid.png");
      // 放入資料流與長度
      pstmt.setBinaryStream(3, is, is.available());
      pstmt.executeUpdate();

      // 4. setBinaryStream
      pstmt.setInt(1, 4);
      pstmt.setString(2, "皇家馬德里2");
      InputStream is2 = getPictureStream("items/FC_Real_Madrid.png");
      // 可直接放入資料流
      pstmt.setBinaryStream(3, is2);
      pstmt.executeUpdate();

      System.out.println("新增成功");

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } catch (IOException ie) {
      System.out.println(ie);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }

  // 使用InputStream資料流方式
  public static InputStream getPictureStream(String path) throws IOException {
    File file = new File(path);
    FileInputStream fis = new FileInputStream(file);
    return fis;
  }

  // 使用byte[]方式
  public static byte[] getPictureByteArray(String path) throws IOException {
    File file = new File(path);
    FileInputStream fis = new FileInputStream(file);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    byte[] buffer = new byte[8192]; // 自訂緩衝
    int i;
    while ((i = fis.read(buffer)) != -1) {
      baos.write(buffer, 0, i);
    }
    baos.close();
    fis.close();

    return baos.toByteArray();
  }
}
```

- 讀出資料庫內圖片

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestReadBlob.java"
```

```java
package idv.david.advanced;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestReadBlob {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "SELECT PIC FROM CLUB WHERE ID = ?";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      pstmt = con.prepareStatement(SQL);

      // 1. getBlob
      pstmt.setInt(1, 1);
      ResultSet rs1 = pstmt.executeQuery();
      rs1.next(); // 游標起始位置是0，所以得用next()到下一步
      Blob blob = rs1.getBlob(1);
      readPicture(blob);

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 2. getBytes
      pstmt.setInt(1, 2);
      ResultSet rs2 = pstmt.executeQuery();
      rs2.next();
      byte[] pic = rs2.getBytes(1);
      readPicture(pic);

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 3. setBinaryStream
      pstmt.setInt(1, 3);
      ResultSet rs3 = pstmt.executeQuery();
      rs3.next();
      InputStream is = rs3.getBinaryStream(1);
      readPicture(is);

      System.out.println("查詢成功");

      rs1.close();
      rs2.close();
      rs3.close();

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } catch (IOException ie) {
      System.out.println(ie);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }

  // Handle with blob data
  public static void readPicture(Blob blob) throws IOException, SQLException {
    InputStream is = blob.getBinaryStream();
    FileOutputStream fos = new FileOutputStream("Output/1.png");
    int i;
    while ((i = is.read()) != -1) {
      fos.write(i);
    }
    fos.flush();
    fos.close();
  }

  // Handle with byte array data
  public static void readPicture(byte[] bytes) throws IOException {
    FileOutputStream fos = new FileOutputStream("Output/2.png");
    fos.write(bytes);
    fos.flush();
    fos.close();
  }

  // Handle with stream data
  public static void readPicture(InputStream is) throws IOException {
    FileOutputStream fos = new FileOutputStream("Output/3.png");
    int i;
    while ((i = is.read()) != -1) {
      fos.write(i);
    }
    fos.flush();
    fos.close();
  }
}
```

- 文字檔案寫入資料庫

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestWriteClob.java"
```

```java
package idv.david.advanced;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestWriteClob {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "UPDATE CLUB SET INTRO = ? WHERE ID = ?";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      pstmt = con.prepareStatement(SQL);

      // 1. setClob
      Clob clob = con.createClob();
      String str = getLongString("items/BM.txt");
      clob.setString(1, str); // position
      pstmt.setClob(1, clob);
      pstmt.setInt(2, 1);
      pstmt.executeUpdate();

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 2. setCharacterStream
      Reader reader = getLongStringStream("items/Bar.txt");
      pstmt.setCharacterStream(1, reader);
      pstmt.setInt(2, 2);
      pstmt.executeUpdate();

      // setAsciiStream使用方式同setCharacterStream
      // 差別就在於Unicode的支援
      // 若是文字為Unicode請使用setCharacterStream

      System.out.println("新增成功");

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } catch (IOException ie) {
      System.out.println(ie);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }

  // 使用String
  public static String getLongString(String path) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(path));
    StringBuilder sb = new StringBuilder(); // StringBuffer is thread-safe!
    String str;
    while ((str = br.readLine()) != null) {
      sb.append(str);
      sb.append("\n");
    }
    br.close();

    return sb.toString();
  }

  // 使用資料流
  public static Reader getLongStringStream(String path) throws IOException {
    return new FileReader(path);
  }
}
```

- 從資料庫讀出文檔

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/TestReadClob.java"
```

```java
package idv.david.advanced;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestReadClob {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "SELECT INTRO FROM CLUB WHERE ID = ?";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      pstmt = con.prepareStatement(SQL);

      // 1. getClob
      pstmt.setInt(1, 1);
      ResultSet rs1 = pstmt.executeQuery();
      rs1.next();
      Clob clob = rs1.getClob(1);
      System.out.println(readString(clob));

      // 清空裡面參數，重覆使用已取得的PreparedStatement物件
      pstmt.clearParameters();

      // 2. getCharacterStream
      pstmt.setInt(1, 2);
      ResultSet rs2 = pstmt.executeQuery();
      rs2.next();
      Reader reader = rs2.getCharacterStream(1);
      System.out.println(readString(reader));

      rs1.close();
      rs2.close();

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } catch (IOException ie) {
      System.out.println(ie);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }

  public static String readString(Clob clob) throws IOException, SQLException {
    StringBuilder sb = new StringBuilder();
    // 可改變的字串，省資源，就不需要消耗記憶體，直接使用 BufferedReader 即不同步
    BufferedReader br = new BufferedReader(clob.getCharacterStream());
    String str;
    while ((str = br.readLine()) != null) {
      sb.append(str);
      sb.append("\n");
    }
    br.close();

    return sb.toString();
  }

  public static String readString(Reader reader) throws IOException {
    StringBuilder sb = new StringBuilder();
    BufferedReader br = new BufferedReader(reader);
    String str;
    while ((str = br.readLine()) != null) {
      sb.append(str);
      sb.append("\n");
    }
    br.close();

    return sb.toString();
  }
}
```

# <a id='s8' class='md-title' href='#top'>8. 交易 Transaction 說明</a>

- 交易的四個基本要求是`原子性`(**A**tomicity)、`一致性`(**C**onsistency)、`隔離行為`(**I**solation behavior)與`持續性`(**D**urability),也常簡稱為 `ACID` <sup><bikao>★</bikao></sup>

- 一個交易即為一個單元工作(Unit of work),裡面所有包含的步驟需全部執行成功,若有一個步驟失敗,則視為此交易失敗,需撤消先前所有執行成功的動作,回到初始狀態

  - `原子性`: 都要成功才成功

- 交易作用的資料集合在交易前後必須一致,若交易成功,則整個資料集合都必須是交易後狀態,若交易失敗,整個資料集合都必須為開始交易前的狀態

  - `一致性`: 交易失敗的情況應該跟之前帳戶資料相同

- 多人使用環境下,每個使用者都能進行自己的交易,交易與交易之間彼此不相關,互不干擾

  - `隔離行為`: 多人操作互不影響

- 交易一旦成功,所有變更都必須保存下來,即使系統出了問題,交易結果仍不會遺失或改變

  - `持續性`: 交易成功永久保存

- 為維護資料庫的整合性,將一組 SQL 指令組成一個交易,若所有敘述運作正常,則提交(commit)資料庫一次處理,若其中有錯誤發生,則回復(rollback)交易前的狀態

- `一個 Connection 物件預設是自動提交(auto-commit)模式`(`SQLDeveloper預設為手動提交`),即以個別的交易為單位自動 commit 資料庫,完成資料庫更新

- Connection 介面`有關交易的三大方法`:

  - <sup><bikao>★</bikao></sup> `setAutoCommit(boolean autoCommit)` : 設定`自動提交模式`(`手動提交`設定成 `false`)
  - <sup><bikao>★</bikao></sup> `commit()`:結束目前的交易並將所有暫存的資料`永久變更`至資料庫中
  - <sup><bikao>★</bikao></sup> `rollback()`:`結束目前的交易`並將所有暫存的資料遺棄

    - 一般會在交易被中斷時呼叫,`即發生 SQLException 時呼叫` (`在 catch 區塊裡面呼叫`)

- BatchUpdate 若是不必每一筆 SQL 指令都要確認的話,也可以搭配交易管理進行操作,使用方式同上頁說明

- 如果在交易管理時,`僅想要撒回某個SQL執行點`,可以利用`設定儲存點(Save Point)`的方式進行設計

- 上述交易相關功能,資料庫表格必須有支援交易為前提才能使用。例如在 MySQL 裡建立為 InnoDB 類型的表格

- <sup><bikao>★</bikao></sup><sup> <bikao>★</bikao></sup> <sup><bikao>★</bikao></sup> `進行交易時,連線物件不可共用!`<sup><bikao>★</bikao></sup><sup> <bikao>★</bikao></sup> <sup><bikao>★</bikao></sup> (遵守`隔離`行為，防止錯亂發生)
  參考訂單與訂單明細實作範例: TestTranscationWithOrder.java

- Connection 物件可使用下列方法進行隔離行為等級的取得或設定:

  - int getTransactionIsolation()

    - 取得目前的 transaction-isolation-level 值
    - Connection 介面定義了 5 個常數

      int TRANSACTION_NONE
      int TRANSACTION_READ_COMMITTED
      int TRANSACTION_READ_UNCOMMITTED
      int TRANSCATION_REPEATABLE_READ
      int TRANSCATION_SERIALIZABLE

  - void setTransactionIsolation(int level)
    - 此方法不得於執行交易區間內呼叫

- TRANSACTION_NONE 僅適用沒有交易功能或唯讀功能的資料庫表格;
  若是表格是有支援交易功能,則會無視此設定

  註: 若是想查詢資料庫是否支援某隔離行為可利用 DatabaseMetaData 的 boolean supportsTransactionIsolationLevel(int level)方法

- 交易問題與可預防隔離行為關係

| 隔離行為         | Lost Update<br>(更新遺失) | Dirty Read<br>(髒讀) | Unrepeatable read<br>(無法重覆讀取) | Phantom read<br>(幻讀) |
| ---------------- | :-----------------------: | :------------------: | :---------------------------------: | :--------------------: |
| READ_UNCOMMITTED |             ✔             |
| READ_COMMITTED   |             ✔             |          ✔           |
| REPRETABLE_READ  |             ✔             |          ✔           |                  ✔                  |
| SERIALIZABLE     |             ✔             |          ✔           |                  ✔                  |           ✔            |

- 一層一層鎖起下，效率會越來越糟
- `Oracle` 使用 `READ_COMMITTED` 作為它的`隔離等級`
- `REPRETABLE_READ` 拿資料一般不會有修改行為，所以通常不會鎖起
- `SERIALIZABLE` 是`鎖整個表`，嚴重，不能亂用
- JAVA 白皮書(16-39 有開始說明此部分)

# <a id='s9' class='md-title' href='#top'>9. 資料 rollback 方法</a>

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/transaction/TestTransaction.java"
```

```java
package idv.david.transaction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class TestTransaction {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    Statement stmt = null;
    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      /***** 交易區間開始 *****/
      con.setAutoCommit(false); // 設定取消自動 commit，否則無法在錯誤時rollback

      stmt = con.createStatement();
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7015, 'DAVID', 'MANAGER', TO_DATE('2016-01-01','YYYY-MM-DD'), 2500, 0.0, 40)");
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7016, 'JAMES', 'CLERK', TO_DATE('2016-02-02','YYYY-MM-DD'), 800, 0.0, 20)");
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7017, 'VINCENT', 'SALESMAN', TO_DATE('2016-03-03','YYYY-MM-DD'), 600, 1000.0, 30)");
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7018, 'RON', 'ANALYST', TO_DATE('2016-04-04','YYYY-MM-DD'), 3500, 0.0, 10)");

      System.out.println("Operation success!");
      con.commit(); // 手動 commit
      /***** 交易區間結束 *****/
    } catch (ClassNotFoundException ce) {
      ce.printStackTrace();
    } catch (SQLException se) {
      try {
        // 發生例外即進行rollback動作
        con.rollback();
      } catch (SQLException e) {
        e.printStackTrace();
      }
      se.printStackTrace();
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (stmt != null) {
        try {
          stmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
      if (con != null) {
        try {
          // 保證在該程式執行完畢前，將資料庫的交易狀態取消，恢復為一般模式(避免死結問題!!)
          con.setAutoCommit(true);
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# <a id='s10' class='md-title' href='#top'>10. 設置 sqvePoint 並部分 rollback</a>

- MySQL 需用 con.releaseSavepoint(savePoint) 釋放資源
- Oracle 不能加 con.releaseSavepoint(savePoint) 會出錯
- 表格需有`交易功能`， MySQL 可以設置這種設定

```java
package idv.david.transaction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;

public class TestSavePoint {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    Statement stmt = null;
    Savepoint savePoint = null;
    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      // 大量或複雜的交易才會需要設置savePoint與rollback
      con.setAutoCommit(false);

      stmt = con.createStatement();
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7015, 'DAVID', 'MANAGER', TO_DATE('2016-01-01','YYYY-MM-DD'), 2500, 0.0, 40)");
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7016, 'JAMES', 'CLERK', TO_DATE('2016-02-02','YYYY-MM-DD'), 800, 0.0, 20)");

      // Oracle不支援, MySQL可以使用(區別在 con.releaseSavepoint(savePoint) )
      // 每個儲存點紀錄的不一樣，要設置新的需要重新撰寫
      savePoint = con.setSavepoint();

      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7017, 'VINCENT', 'SALESMAN', TO_DATE('2016-03-03','YYYY-MM-DD'), 600, 1000.0, 30)");
      stmt.executeUpdate("INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
          + "VALUES(7018, 'RON', 'ANALYST', TO_DATE('2016-04-04','YYYY-MM-DD'), 3500, 0.0, 50)");

      con.commit();

    } catch (ClassNotFoundException ce) {
      ce.printStackTrace();
    } catch (SQLException se) {
      try {
        con.rollback(savePoint); // 沒設置 savePoint 就是 rollback 全部
      } catch (SQLException e) {
        e.printStackTrace();
      }
      se.printStackTrace();
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (stmt != null) {
        try {
          stmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
      if (con != null) {
        try {
          con.setAutoCommit(true);
          // 記得釋放儲存點 (MySQL 才要釋放)
          // con.releaseSavepoint(savePoint);
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

---

參考鏈接:

- [Connection 对象简介 方法解读 JDBC 简介（四）](https://www.cnblogs.com/noteless/p/10302526.html)

- [Spring 利用 JDBCTemplate 实现批量插入和返回 id](https://blog.51cto.com/ciyorecord/2095774)
