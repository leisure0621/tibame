# try – catch – finally

- java7 後可以不需要 close 資源

```cs
範例程式: "/JavaEx_Part2/src/ch01/TestTryWithResources.java"
```

```java
package ch01;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class TestTryWithResources {

  public static void main(String[] args) {
    File file = new File("files/books.csv");
    BufferedReader br = null;

    // before, finally內自行處理資源的關閉
    // 但目前還是會需要自行處理，因為企業的版本疊代緩慢，故還是會用到舊的方法去寫
    try {
      br = new BufferedReader(new FileReader(file));
      String bookInfo = "";
      while ((bookInfo = br.readLine()) != null) {
        System.out.println(bookInfo);
      }
    } catch (IOException ex) {
      ex.printStackTrace();
    } finally {
      try {
        br.close();
      } catch (IOException ex) {
        ex.printStackTrace();
      }
    }

    // Java 7, try-with-resources可確保物件（資源）在最後都會被關閉
    try (BufferedReader in = new BufferedReader(new FileReader(file));) {
      String bookInfo = "";
      while ((bookInfo = in.readLine()) != null) {
        System.out.println(bookInfo);
      }
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
}
```

- JDK 7(JDBC 4.1)以後可操作的作法

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/TestConnection2.java"
```

```java
package idv.david.basic;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class TestConnection2 {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
    } catch (ClassNotFoundException ce) {
      ce.printStackTrace();
    }

    // JDK 7(JDBC 4.1) 以後
    try(Connection con = DriverManager.getConnection(URL, USER, PASSWORD)) {
      System.out.println("Connecting to database successfully! (連線成功！)");
    } catch (SQLException se) {
      System.out.println(se.getMessage());
    }
  }
}
```

# SQL Injection(SQL 注入攻擊)

- 駭客們的`填空遊戲`
- `(NAME = '1' OR '1'='1') and (PASSWORD = '1' OR '1'='1');`

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/TestSQLInjection.java"
```

```java
package idv.david.basic;

// userName = 1' OR '1'='1
// userPassword = 1' OR '1'='1;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;

public class TestSQLInjection {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    Statement stat = null;
    ResultSet rs = null;

    String userName = "", userPassword = "";

    Scanner sc = new Scanner(System.in);
    System.out.println("請輸入名稱: ");
    userName = sc.nextLine();
    System.out.println("請輸入密碼: ");
    userPassword = sc.nextLine();

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      stat = con.createStatement();
      rs = stat.executeQuery(
          "SELECT * FROM MEMBER WHERE (NAME = '" + userName + "') AND (PASSWORD = '" + userPassword + "')");

      // 駭客們所稱呼的"填空遊戲"
      // 將鍵盤輸入資料當做變數所組合成的SQL句子：
      // SELECT * FROM MEMBER WHERE (NAME = '1' OR '1'='1') and (PASSWORD = '1' OR '1'='1');

      while (rs.next()) {
        System.out.println("User ID: " + rs.getInt("ID"));
        System.out.println("User name: " + rs.getString("NAME"));
        System.out.println("User password: " + rs.getString("PASSWORD"));
        System.out.println();
      }

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (stat != null) {
        try {
          stat.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
      sc.close();
    }
  }
}
```

# PreparedStatement 對象 (最常用需記住)

- 資料庫會將 SQL 指令預先編譯,可避免資料庫重覆解析同一個 SQL 指令,`執行效能較好`,`因為可以動態處理 SQL 指令,可避免 SQL Injection 攻擊`

- 提供參數在每次執行時置入不同的值,透過 `setType(int idx, Type value)` 提供參數值

  - `int idx`，第幾個問號(由 1 開始)
  - `Type value`，問號的值

- 執行 PreparedStatement 兩個方法

  - 執行時不需要再提供指令(在創建 PreparedStatement 時指令已經先交給資料庫了)

  - `ResultSet executeQuery()`
  - `int executeUpdate()`
  - `boolean excute()`: 執行"未知"的 SQL 指令(如預存程序)
    - 回傳 true 表示剛剛執行的動作是查詢，false 表示更新

- 問號是針對`資料`，`不針對欄位與表格`(要做的話還是要用字串串接)

# PreparedStatement 對象範例

- 簡易改寫，可以用這種方式動態新增資料

```cs
範例程式: "/JavaTest/src/jdbctest/HelloJDBC.java"
```

```java
package jdbctest;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;

public class HelloJDBC {
  private static final String DRIVER = "oracle.jdbc.driver.OracleDriver";
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "DAVID";
  private static final String PASSWORD = "123456";
  // JDBC 可以用 ? 表示動態改寫的資料
  private static final String INSERT_STMT = "INSERT INTO DEPARTMENT (DEPTNO, DNAME, LOC) VALUES (?, ?, ?)";

  public static void main(String[] args) {
    // 為了搭配資源關閉，故需自行設定 try-catch
    Connection con = null;
    Statement stmt = null;
    ResultSet rs = null;
    PreparedStatement pstmt = null;

    Scanner sc = new Scanner(System.in);
    System.out.println("請輸入部門編號");
    int deptno = sc.nextInt();
    System.out.println("請輸入部門名稱");
    String dname = sc.next();
    System.out.println("請輸入所在地");
    String loc = sc.next();

    sc.close();

    try {
      // step 1: 載入驅動
      Class.forName(DRIVER);
      System.out.println("載入成功");

      // step 2: 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("連線成功");

      // step 3: 執行SQL指令(搭配PreparedStatement)
      // 已先將部分SQL指令提交給資料庫，等待後續須查詢的資料注入
      pstmt = con.prepareStatement(INSERT_STMT);

      // 執行前要將指令中各個問號對應的值設定好
      pstmt.setInt(1, deptno);
      pstmt.setString(2, dname);
      pstmt.setString(3, loc);

      pstmt.executeUpdate();

    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      // 越晚建立的越早關閉
      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (stmt != null) {
        try {
          stmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      // 連線不為空 關閉連線
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }
  }
}
```

- 也可注入多個值

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/Test_INSERT_PreparedStatement.java"
```

```java
package idv.david.basic;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class Test_INSERT_PreparedStatement {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "INSERT INTO EMPLOYEE(EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)"
      + "VALUES(?, ?, ?, ?, ?, ?, ?)";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      pstmt = con.prepareStatement(SQL);
      pstmt.setInt(1, 7015);
      pstmt.setString(2, "DAVID");
      pstmt.setString(3, "MANAGER");
      pstmt.setDate(4, java.sql.Date.valueOf("2016-01-01"));
      pstmt.setDouble(5, 2500);
      pstmt.setDouble(6, 0.0);
      pstmt.setInt(7, 40);

      int rowCount = pstmt.executeUpdate();
      System.out.println("新增 " + rowCount + " 筆資料");

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {

      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# 結合 PreparedStatement 避免 SQL Injection 注入攻擊

- 仍可成功連線，但資料不會曝光。且效能更佳

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/TestSQLInjectionPrevent.java"
```

```java
package idv.david.basic;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

public class TestSQLInjectionPrevent {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "SELECT * FROM MEMBER WHERE NAME = ? AND PASSWORD = ?";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;

    String userName = "", userPassword = "";

    Scanner sc = new Scanner(System.in);
    System.out.println("請輸入名稱: ");
    userName = sc.nextLine();
    System.out.println("請輸入密碼: ");
    userPassword = sc.nextLine();

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      // SQL指令預先處理
      pstmt = con.prepareStatement(SQL);
      // 對問號進行操作
      pstmt.setString(1, userName);
      pstmt.setString(2, userPassword);

      rs = pstmt.executeQuery();

      while (rs.next()) {
        System.out.println("User ID: " + rs.getInt("ID"));
        System.out.println("User name: " + rs.getString("NAME"));
        System.out.println("User password: " + rs.getString("PASSWORD"));
        System.out.println();
      }

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
      sc.close();
    }
  }
}
```

# 資料庫成本

- 成本原因
  - 資料庫版本
  - 資料庫功能
  - 資料庫一次連線數量
- 注意
  - 所以必須要使用`try{}catch{}`關閉使用`資源`

# CallableStatement 對象

- 繼承 PreparedStatement 介面,用來呼叫`資料庫預存程序`

- 預存程序(stored procedure)在應用程式執行前,已事先編譯好在資料庫裡,因此預存程序的效能一般比預先編譯的敘述快

- 程式設計師只需知道預存程序的名稱與輸入輸出的參數,無需暸解 SQL
  指令

- 不同的資料庫有不同的預存程序語法;對三階開發人員(前端、後端、資料端)來說,意義不大

# CallableStatement 範例

- 寫入資料: `插入資料`

```cs
範例程式: "/JavaEx_JDBC_Oracle/items/procedure.txt"
```

```sql
CREATE OR REPLACE PROCEDURE INSERT_EMP
(
  EMPNO in INTEGER,
  ENAME in VARCHAR2,
  JOB in VARCHAR2,
  HIREDATE in DATE,
  SAL in FLOAT,
  COMM in FLOAT,
  DEPTNO in INTEGER
)
IS
BEGIN
INSERT INTO EMPLOYEE (EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO)
VALUES (EMPNO, ENAME, JOB, HIREDATE, SAL, COMM, DEPTNO);
END;
```

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/Test_StoredProcedureIN.java"
```

```java
package idv.david.basic;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.GregorianCalendar;

public class Test_StoredProcedureIN {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    CallableStatement cstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      cstmt = con.prepareCall("{call INSERT_EMP(?, ?, ?, ?, ?, ?, ?)}");
      cstmt.setInt(1, 7015);
      cstmt.setString(2, "DAVID");
      cstmt.setString(3, "MANAGER");

      // 利用GregorianCalendar指定日期再轉換成java.sql.Date資料
      GregorianCalendar cal = new GregorianCalendar(2016, Calendar.JANUARY, 1);
      Date date = new Date(cal.getTimeInMillis());
      cstmt.setDate(4, date);

      cstmt.setFloat(5, 2500);
      cstmt.setFloat(6, 0.0f);
      cstmt.setInt(7, 40);

      cstmt.execute();

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {
      if (cstmt != null) {
        try {
          cstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

- 讀取資料: `讀取平均值`

```cs
範例程式: "/JavaEx_JDBC_Oracle/items/procedure.txt"
```

```sql
CREATE OR REPLACE PROCEDURE GET_SAL_AVG(val IN FLOAT, average OUT FLOAT)
IS
temp_avg FLOAT;
BEGIN
SELECT avg(SAL) INTO temp_avg FROM EMPLOYEE WHERE SAL <= val;
-- := 表示 temp_avg 指定給 average，即 Java 的 =
average := temp_avg;
RETURN;
END;
```

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/basic/Test_StoredProcedureOUT.java"
```

```java
package idv.david.basic;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Types;

public class Test_StoredProcedureOUT {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    CallableStatement cstmt = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      // ? 預設會被當作輸入(IN)的參數
      cstmt = con.prepareCall("{call get_sal_avg(?,?)}");
      cstmt.setFloat(1, 1000);
      // registerOutParameter 設定為輸出(OUT)參數
      // Types.FLOAT 設定資料類型
      cstmt.registerOutParameter(2, Types.FLOAT);
      cstmt.execute();

      // 取得第二個問號的資料
      float avg = cstmt.getFloat(2);
      System.out.println("Average is " + avg);

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {

      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (cstmt != null) {
        try {
          cstmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# ResultSet Advanced(加強)

- `JDBC 2.0` 對 ResultSet 做了許多加強,允許更彈性的移動游標與資料更新等進階操作

- 建立 Statement 物件時進行設定:

  - Statement createStatement(int resultSetType, int resultSetConcurrency)
  - PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)

- 驅動程式必須能夠支援,否則會產生 Runtime Exception

- `不是所有驅動程式都支援`

- 相關參數 (都是在 ResultSet 介面已定義好的 static final 的整數常數):

  - ResultSetType

    - TYPE_FORWARD_ONLY (只能前進)
    - TYPE_SCROLL_INSENSITIVE (`可前後移動`,`不反應資料修改`)
    - TYPE_SCROLL_SENSITIVE (`可前後移動`,`反應資料修改`)

  - ResultSetConcurrency

    - CONCUR_READ_ONLY (`資料` `為唯讀`)
    - CONCUR_UPDATABLE (`資料` `可異動`,如新增、修改與刪除)

- 註: 若沒設定,預設為 TYPE_FORWARD_ONLY & CONCUR_READ_ONLY

  1. `游標只能一直往前(向下)移動無法返回`
  2. `只能唯讀，無法透過 ResultSet 做資料更新的操作`

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Test_ResultSet_Cursor {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "SELECT * FROM EMPLOYEE";

  public static void main(String[] args) {
    Connection con = null;
    Statement stmt = null;
    ResultSet rs = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);

      stmt = con.createStatement(); // SQLException: Oracle - 無效的僅轉送結果集作業: beforeFirst
                      // SQLException: Microsoft SQL Server 2008 - 不支援在順向結果集上執行要求的作業。

      // 對游標的設定
//      stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
//      stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); // Microsoft SQL Server 2008 不支援此種組合
      stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
//      stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);

      rs = stmt.executeQuery(SQL);

      System.out.println("起始位置=" + rs.getRow());
      rs.next(); // 不可遺漏 rs.next();
      System.out.print(rs.getRow() + " ");
      System.out.print(" EMPNO = " + rs.getInt(1));
      System.out.print(" ENAME = " + rs.getString(2) + "\n");
      rs.beforeFirst();

      System.out.println("----------------1----------------");

      while (rs.next()) {
        System.out.print(rs.getRow() + " ");
        System.out.print(" EMPNO = " + rs.getInt(1));
        System.out.print(" ENAME = " + rs.getString(2) + "\n");
      }

      System.out.println("----------------2----------------");

      while (rs.previous()) {
        System.out.print(rs.getRow() + " ");
        System.out.print(" EMPNO = " + rs.getInt(1));
        System.out.print(" ENAME = " + rs.getString(2) + "\n");
      }

      System.out.println("----------------3----------------");

      // 絕對位置
      rs.absolute(10);

      // 相對位置
      rs.relative(-3);

      rs.first();

      System.out.print(rs.getRow() + " ");
      System.out.print(" EMPNO = " + rs.getInt(1));
      System.out.print(" ENAME = " + rs.getString(2) + "\n");

      System.out.println("----------------4----------------");

      // 移動游標(last) + 列編號 (getRow)
      rs.last();
      int len = rs.getRow();
      System.out.println("資料共" + len + "筆" + " [使用ResultSet游標移動的方式]");
      rs.beforeFirst();

      System.out.println("----------------5----------------");

      ResultSet rs2 = stmt.executeQuery("SELECT count(*) AS count FROM EMPLOYEE");
      rs2.next();
      int len2 = rs2.getInt("count");
      System.out.println("資料共" + len2 + "筆" + " [直接下SQL指令的方式]");
      rs2.close();

    } catch (ClassNotFoundException ce) {
      System.out.println(ce);
    } catch (SQLException se) {
      System.out.println(se);
    } finally {
      // 依建立順序關閉資源 (越晚建立越早關閉)
      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (stmt != null) {
        try {
          stmt.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          System.out.println(se);
        }
      }
    }
  }
}
```

# MetaData (資料的資料)

- `JDBC 提供查詢結果與資料庫兩種 MetaData`,DatabaseMetaData `取得`資料庫相關`資訊`,為研發人員用來寫獨立於資料庫的驅動程式和開發工具

- 透過`ResultSet 的 getMetaData 方法`即可取得 ResultSetMetaData <sup><bikao>★</bikao></sup> 物件,而透過`Connection 的 getMetaData 方法`取得 DatabaseMetaData 物件

- ResultSetMetaData 常用方法:
  - int getColumnCount():取得欄位數
  - String getColumnName(int col):取得欄位名
  - String getColumnTypeName(int col):取得欄位在 DBMS 所使用的 SQL type 的名稱
  - String getTableName(int col):取得欄位所屬的表格名稱
  - boolean isNullable(int col):欄位能否為 null

# MetaData 範例

- RSMetaData: 讀取當下你自己表格的表格名稱的話，Oracle 方法會回傳空值

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/Test_SELECT_RSMetaData.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

public class Test_SELECT_RSMetaData {
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";
  private static final String SQL = "SELECT * FROM EMPLOYEE";

  public static void main(String[] args) {
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    ResultSetMetaData rsmd = null;

    try {
      Class.forName("oracle.jdbc.driver.OracleDriver");
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      System.out.println("Connecting to database successfully! (連線成功！)");

      pstmt = con.prepareStatement(SQL);
      rs = pstmt.executeQuery();
      rsmd = rs.getMetaData();

      int numberOfColumns = rsmd.getColumnCount();
      for (int i = 1; i <= numberOfColumns; i++) {
        String colName = rsmd.getColumnName(i);
        String tableName = rsmd.getTableName(i);
        String name = rsmd.getColumnTypeName(i);
        boolean caseSen = rsmd.isCaseSensitive(i);
        boolean writable = rsmd.isWritable(i);
        System.out.println("Information for column " + colName);
        System.out.println("    Column is in table " + tableName);
        System.out.println("    DBMS name for type is " + name);
        System.out.println("    Is case sensitive:  " + caseSen);
        System.out.println("    Is possibly writable:  " + writable);
        System.out.println();
      }

      while (rs.next()) {
        for (int i = 1; i <= numberOfColumns; i++) {
          String s = rs.getString(i);
          System.out.print(s + "  ");
        }
        System.out.println();
      }

      rs.close();
      pstmt.close();
      con.close();

    } catch(ClassNotFoundException ce) {
      ce.printStackTrace();
    } catch(SQLException se) {
      se.printStackTrace();
    }

  }
}
```

- DBMetaData: 讀資料庫的 MetaData

```cs
範例程式: "/JavaEx_JDBC_Oracle/src/idv/david/advanced/Test_SELECT_DBMetaData.java"
```

```java
package idv.david.advanced;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Test_SELECT_DBMetaData {
  private static final String DRIVER = "oracle.jdbc.driver.OracleDriver";
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "david";
  private static final String PASSWORD = "123456";

  public static void main(String[] args) {
    Connection con = null;
    ResultSet rs = null, rs2 = null;
    try {
      Class.forName(DRIVER);
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      DatabaseMetaData dbmd = con.getMetaData();
      String dbmsName = dbmd.getDatabaseProductName();
      rs = dbmd.getTableTypes();
      System.out.print("The following types of tables are ");
      System.out.println("available in " + dbmsName + ":  ");

      while (rs.next()) {
        String tableType = rs.getString("TABLE_TYPE");
        System.out.println("    " + tableType);
      }

      System.out.println("=======================");

      rs2 = dbmd.getTypeInfo();
      while (rs2.next()) {
        // 從API文件查詢DATA_TYPE...等資訊，就能取得相應資料
        int codeNumber = rs2.getInt("DATA_TYPE");
        String typeName = rs2.getString("TYPE_NAME");
        String createParams = rs2.getString("CREATE_PARAMS");

        System.out.println("DATA_TYPE = " + codeNumber);
        System.out.println("TYPE_NAME = " + typeName);
        System.out.println("CREATE_PARAMS = " + createParams);
        System.out.println("==================");
      }

    } catch (ClassNotFoundException ce) {
      ce.printStackTrace();
    } catch (SQLException se) {
      se.printStackTrace();
    } finally {
      if (rs2 != null) {
        try {
          rs2.close();
        } catch (SQLException se) {
          se.printStackTrace();
        }
      }

      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException se) {
          se.printStackTrace();
        }
      }

      if (con != null) {
        try {
          con.close();
        } catch (SQLException se) {
          se.printStackTrace();
        }
      }
    }
  }
}
```

# Object - Relational Mapping

- 物件 – 關聯式資料庫對映(Object-Relational Mapping)

  - 簡稱 ORM 或是 O/R Mapping
  - 是一種常見的軟體設計模式(design pattern)

- `一個資料庫表格對應一個 Java 類別` (類別先產生，才有物件)

  - `每個欄位對應到該類別的屬性(實體變數)`
  - 此 Java 類別稱為 `Value Object(VO)` 或 `Data Transfer Object(DTO)`,用來在 client 端與 server 端之間傳遞資料
  - 亦即應用程式的 Domain Object 對應到資料庫的 business entity
  - 本講義以 `Java Bean` 來實作 business entity

    - Java Bean 意思

      - `包裝資料、重複使用`

    - Java Bean 的三個要求 <sup><bikao>★</bikao></sup>
      - `對每一個 private 欄位分別設計一組 getter/setter`
      - `此類別實作 Serializable 介面`
      - `此類別擁有一個不帶參數的建構子`

- 針對資料庫表格存取`會設計一個 Data Access Object(DAO)類別來對應`

  - 此 DAO 類別封裝 JDBC 的資料庫存取程式碼的實作,應用程式若需要存取資料庫時,一律透過此 DAO 來處理

    - 通常不同廠商提供的資料庫,除了標準的 SQL 指令外,有些存取會依資料庫的不同而有所不同

  - 設計目的是若更換資料庫時,只需更換 DAO 即可,而應用程式無需變更

- `針對每一個 DAO 類別設計一個 DAO 介面來對應`

  - 此 DAO 介面負責定義方法(`定義該表格的各種存取方法`)(`降低相依性`)

# JAVA 型態與 SQL 型態

| Java 型態            | SQL 型態                              |
| -------------------- | ------------------------------------- |
| boolean              | BIT                                   |
| byte                 | TINYINT                               |
| short                | SMALLINT                              |
| int                  | INTEGER                               |
| long                 | BIGINT                                |
| float                | FLOAT                                 |
| double               | DOUBLE                                |
| byte[]               | BINARY, VARBINARY, LONGBINARY, `BLOB` |
| java.lang.String     | CHAR, VARCHAR, LONGVARCHAR, `CLOB`    |
| java.math.BigDecimal | DECIMAL, NUMERIC                      |
| java.sql.Date        | DATE                                  |
| java.sql.Time        | TIME                                  |
| java.sql.Timestamp   | TIMESTAMP                             |

- BLOB 與程式端 byte[] 對應
- CLOB 與程式端 String 對應

# Object - Relational Mapping(ORM) 實作

- 範例 1: 使用員工表格說明`增刪改查`

```cs
範例程式: "idv.david.dao"
```

- 範例 2: ArrayList 取得 txt 的資料

```cs
範例程式: "idv.david.additional.iocollection"
```

- 上課實作: 以下程式`沒有對刪除/取得資料為空`等等的狀態做處理

```cs
範例程式: "/JavaTest/src/orm/Dept.java"
```

```java
package orm;

import java.io.Serializable;

@SuppressWarnings("serial")
public class Dept implements Serializable {
  private int deptno;
  private String dname;
  private String loc;
  private String query;

  public Dept() {
    super();
  }

  public Dept(int deptno, String dname, String loc, String query) {
    super();
    this.deptno = deptno;
    this.dname = dname;
    this.loc = loc;
    this.query = query;
  }

  public String getQuery() {
    return query;
  }

  public void setQuery(String query) {
    this.query = query;
  }

  public int getDeptno() {
    return deptno;
  }

  public void setDeptno(int deptno) {
    this.deptno = deptno;
  }

  public String getDname() {
    return dname;
  }

  public void setDname(String dname) {
    this.dname = dname;
  }

  public String getLoc() {
    return loc;
  }

  public void setLoc(String loc) {
    this.loc = loc;
  }
}
```

```cs
範例程式: "/JavaTest/src/orm/DeptDAO.java"
```

```java
package orm;

import java.util.List;

public interface DeptDAO {
  void add(Dept dept);

  void update(Dept dept);

  void delete(int deptno);

  Dept findByPK(int deptno);

  List<Dept> getAll();
}
```

```cs
範例程式: "/JavaTest/src/orm/DeptDAOImpl.java"
```

```java
package orm;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class DeptDAOImpl implements DeptDAO {
  private static final String DRIVER = "oracle.jdbc.driver.OracleDriver";
  private static final String URL = "jdbc:oracle:thin:@localhost:1521:xe";
  private static final String USER = "DAVID";
  private static final String PASSWORD = "123456";

  private static final String INSERT_STMT = "INSERT INTO DEPARTMENT (DEPTNO, DNAME, LOC) VALUES (?, ?, ?)";
  private static final String UPDATE_STMT = "UPDATE DEPARTMENT SET DNAME = ?, LOC = ? WHERE DEPTNO = ? ";
  private static final String FIND_BY_PK = "SELECT * FROM DEPARTMENT WHERE DEPTNO = ?";
  private static final String FIND_ALL = "SELECT * FROM DEPARTMENT";
  private static final String DELETE_STMT = "DELETE FROM DEPARTMENT WHERE DEPTNO = ?";

  static {
    try {
      Class.forName(DRIVER);
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    }
  }

  @Override
  public void add(Dept dept) {
    Connection con = null;
    PreparedStatement pstmt = null;
    try {

      // 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      // SQL語法
      pstmt = con.prepareStatement(INSERT_STMT);

      // 設定將送入的資料
      pstmt.setInt(1, dept.getDeptno());
      pstmt.setString(2, dept.getDname());
      pstmt.setString(3, dept.getLoc());

      // 將資料送入資料庫
      pstmt.executeUpdate();

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }
  }

  @Override
  public void update(Dept dept) {
    Connection con = null;
    PreparedStatement pstmt = null;
    try {

      // 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      // SQL語法
      pstmt = con.prepareStatement(UPDATE_STMT);

      // 設定將送入的資料
      pstmt.setString(1, dept.getDname());
      pstmt.setString(2, dept.getLoc());
      pstmt.setInt(3, dept.getDeptno());

      // 將資料送入資料庫
      pstmt.executeUpdate();

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }
  }

  @Override
  public void delete(int deptno) {
    Connection con = null;
    PreparedStatement pstmt = null;
    try {

      // 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      // SQL語法
      pstmt = con.prepareStatement(DELETE_STMT);

      // 設定將送入的資料
      pstmt.setInt(1, deptno);

      // 將資料送入資料庫
      pstmt.executeUpdate();

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }
  }

  @Override
  public Dept findByPK(int deptno) {
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Dept dept = null;

    try {

      // 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      // SQL語法
      pstmt = con.prepareStatement(FIND_BY_PK);

      pstmt.setInt(1, deptno);
      rs = pstmt.executeQuery();

      // 取資料一定要next()
      while (rs.next()) {
        // 用Dept包裝著查詢出來的資料
        dept = new Dept();
        dept.setDeptno(rs.getInt("DEPTNO"));
        dept.setDname(rs.getString("DNAME"));
        dept.setLoc(rs.getString("LOC"));
      }
      // 將資料送入資料庫
      pstmt.executeUpdate();

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }

    return dept;
  }

  @Override
  public List<Dept> getAll() {
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    List<Dept> deptList = new ArrayList<>();

    try {

      // 建立連線
      con = DriverManager.getConnection(URL, USER, PASSWORD);
      // SQL語法
      pstmt = con.prepareStatement(FIND_ALL);

      rs = pstmt.executeQuery();

      while (rs.next()) {
        // 每一次執行就用新的Dept物件包裝著查詢出來的資料
        Dept dept = new Dept();
        dept.setDeptno(rs.getInt("DEPTNO"));
        dept.setDname(rs.getString("DNAME"));
        dept.setLoc(rs.getString("LOC"));
        // 用集合收集包裝好的部門物件，最後一次回傳
        deptList.add(dept);
      }
      // 將資料送入資料庫
      pstmt.executeUpdate();

    } catch (SQLException e) {
      e.printStackTrace();
    } finally {
      if (rs != null) {
        try {
          rs.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (pstmt != null) {
        try {
          pstmt.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
      if (con != null) {
        try {
          con.close();
        } catch (SQLException e) {
          e.printStackTrace();
        }
      }
    }

    return deptList;
  }
}
```

```cs
範例程式: "/JavaTest/src/orm/DeptTest.java"
```

```java
package orm;

import java.util.List;
import java.util.Scanner;

public class DeptTest {
  @SuppressWarnings("resource")
  public static void main(String[] args) {

    int deptno;
    String dname, loc;
    while (true) {
      // 輸入值
      Scanner sc = new Scanner(System.in);
      System.out.println("======= 目錄 =======");
      System.out.println("【新增資料】請輸入 1 ");
      System.out.println("【修改資料】請輸入 2 ");
      System.out.println("【刪除資料】請輸入 3 ");
      System.out.println("【查詢單筆資料】請輸入 4 ");
      System.out.println("【查詢所有資料】請輸入 5 ");
      System.out.println("輸入 1~5 外的數字結束此次查詢 ");
      System.out.println("==================");
      System.out.print("輸入: ");
      int action = sc.nextInt();

      if (action == 1) {
        System.out.println("請輸入部門編號");
        deptno = sc.nextInt();
        System.out.println("請輸入部門名稱");
        dname = sc.next();
        System.out.println("請輸入所在地");
        loc = sc.next();

        // 新增
        addData(deptno, dname, loc);
        continue;
      } else if (action == 2) {
        System.out.println("請輸入部門編號");
        deptno = sc.nextInt();
        System.out.println("請輸入【新的】部門名稱");
        dname = sc.next();
        System.out.println("請輸入【新的】所在地");
        loc = sc.next();

        // 修改
        updateData(deptno, dname, loc);
      } else if (action == 3) {
        System.out.println("請輸入【要刪除的】部門編號");
        deptno = sc.nextInt();

        // 刪除
        deleteData(deptno);
      } else if (action == 4) {
        System.out.println("請輸入【要查詢的】部門編號");
        deptno = sc.nextInt();

        // 查詢
        findByPKData(deptno);
      } else if (action == 5) {
        System.out.println("顯示所有資料:");

        // 所有
        findAllData();
      } else {
        System.out.println("結束查詢");
        sc.close();
        break;
      }
    }
  }

  static void addData(int deptno, String... arr) {
    // 包裝著要新增的部門資料
    Dept dept = new Dept(deptno, arr[0], arr[1]);
    // 創建dao物件，準備部門表格做新增資料的操作
    DeptDAO dao = new DeptDAOImpl();
    dao.add(dept);
    System.out.println("更新成功");
  }

  static void updateData(int deptno, String... arr) {
    Dept dept = new Dept(deptno, arr[0], arr[1]);
    DeptDAO dao = new DeptDAOImpl();
    dao.update(dept);
    System.out.println("修改成功");
  }

  static void deleteData(int deptno) {
    DeptDAO dao = new DeptDAOImpl();
    dao.delete(deptno);
    System.out.println("刪除成功");
  }

  static void findByPKData(int query) {
    DeptDAO dao = new DeptDAOImpl();
    Dept dept = dao.findByPK(query);

    System.out.println("DEPTNO = " + dept.getDeptno());
    System.out.println("DNAME = " + dept.getDname());
    System.out.println("LOC = " + dept.getLoc());

  }

  static void findAllData() {
    DeptDAO dao = new DeptDAOImpl();
    List<Dept> deptList = dao.getAll();

    for (Dept dept : deptList) {
      System.out.println("DEPTNO = " + dept.getDeptno());
      System.out.println("DNAME = " + dept.getDname());
      System.out.println("LOC = " + dept.getLoc());
      System.out.println();
    }
  }
}
```
