<h1 id="top">目錄</h1>

- [1. 泛型(Generic Type)](#s1)
- [2. 泛型生活化解釋](#s2)
- [3. 泛型(Generic Type)舉例](#s3)
- [4. 泛型的延伸，自訂泛型](#s4)
- [5. 泛型的進階設定](#s5)
- [6. 基本泛型總結](#s6)
- [7. Iterable 介面](#s7)
- [8. 增強型 for 迴圈 (for – each)](#s8)
- [9. Iterable 與 for - each 範例](#s9)
- [10. 傳統 for 與 for-each](#s10)
- [11. Collection 進一步探討(重點)](#s11)
- [12. Collection 延伸範例](#s12)
- [13. ArrayList 與 LinkedList 差異](#s13)
- [14. 自訂比較器的三種方法](#s14)
- [15. 堆疊](#s15)

---

# <a id='s1' class='md-title' href='#top'>1. 泛型(Generic Type)</a>

- JDK1.5 的泛型設計有以下優點

  - `可預先指定 Collection 中所含的物件類別`

    - 泛型的使用 `<>`，ex.`<Integer>`

    - 用來限制集合的使用，限定輸入陣列型別

  - 因此只要不小心加入其它類別的物件,在`編譯階段就會出現錯誤`,使得原本放在執行階段才會檢查出來的問題,提昇到了編譯時期

  - 避免 runtime 時期的 java.lang.ClassCastException 的錯誤,也因為類別已知,取出資料時`可省略型別轉換`(Cast)的麻煩`(也省去了instanceof檢查的麻煩)`

  - 另 Java 使用動態連結技術,並且有共同的 Object 祖先做為最根本的多型

- 在 JDK1.4 之前,實作 Collection 介面時,我們能夠處理 Object 物件,如 add(Object o)或 remove(Object o)方法

  - 如此雖可讓 Collection 介面變得`一般化`,但是因為在大部份的實際狀況下,我們放在 Collection 中的物件通常都屬同一個類別,取出時型別為 Object 還得作型別轉換(Cast),較為麻煩也容易出錯

# <a id='s2' class='md-title' href='#top'>2. 泛型生活化解釋</a>

- 沒泛型

  - 準備超大行李箱，在搬家時隨便放進去。但要開始整理，一個個拿出來時需要拿出來，是衣服就在走到衣櫃放，是什麼就要來回的走一個個放到對應的地方(前期開心後期麻煩)

- 泛型

  - 準備好多行李箱，日用品放一起、衣服放一起...，雖然一開始整理會麻煩，但之後整理時會方便很多(前期麻煩後期開心)

# <a id='s3' class='md-title' href='#top'>3. 泛型(Generic Type)舉例</a>

```java
範例程式: "/JavaEx_Part2/src/ch03/BeforeGenericList.java"

package ch03;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class BeforeGenericList {

  public static void main(String[] args) {
    // 使用ArrayList方法取得的資料都是Object
    List data = new ArrayList();
    data.add("Hello");
    data.add("World");
    data.add(10);

    Iterator it = data.iterator();
    while (it.hasNext()) {
      /*
      * 以下做法會失敗，因為Object中沒有isEmpty()的方法，所以要將資料轉型
      * 不轉資料就不會有相應物件的特性，也會轉型失敗
      * Object str1 = it.next();
      * str1.isEmpty();
      */
      String str2 = (String) it.next(); // 強制轉型
      System.out.println(str2);

      // 舊寫法: 資料相應轉型
      Object obj = it.next();
      if (obj instanceof String) {
        String s = (String) obj;
        System.out.println(s.isEmpty());
      } else if (obj instanceof Integer) {
        Integer i1 = (Integer) obj;
        System.out.println(i1.intValue());
      }
    }
  }
}
```

```java
範例程式: "/JavaEx_Part2/src/ch03/GenericList.java"

package ch03;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class GenericList {

  public static void main(String[] args) {
    // 泛型是String
    List<String> data = new ArrayList<String>();
    data.add("Hello");
    data.add("World");

    // 迭代器也要同泛型，String
    Iterator<String> it = data.iterator();
    while (it.hasNext()) {
      // next回傳的也是String
      // 強制轉型,不再需要使用instanceof判斷後再依序強制轉型
      String str = it.next();
      System.out.println(str);
    }
  }
}
```

```java
範例程式: "/JavaEx_Part2/src/ch03/GenericMap.java"

package ch03;

import java.util.HashMap;
import java.util.Map;

public class GenericMap {

  public static void main(String[] args) {
    Map<Integer, String> map = new HashMap<Integer, String>();
    for (int i = 0; i < 3; i++) {
      map.put(new Integer(i), "number" + i);
    }
    System.out.println(map.get(new Integer(0)));
    System.out.println(map.get(new Integer(1)));
    System.out.println(map.get(new Integer(2)));
  }
}
```

# <a id='s4' class='md-title' href='#top'>4. 泛型的延伸，自訂泛型</a>

```java
package ch03;

import java.util.*;

// 自訂泛型
class MyGenericType<Type> {

  private List<Type> list;

  public MyGenericType() {
    list = new Vector<Type>();
  }

  public void add(Type t) {
    list.add(t);
  }

  public Type get(int i) {
    return list.get(i);
  }
}

public class MyGeneric {
  public static void main(String[] args) {
    // 真正決定泛型
    MyGenericType<String> myGeneric = new MyGenericType<String>();
    for (int i = 0; i < 3; i++) {
      myGeneric.add("number" + i);
      System.out.println(myGeneric.get(i));
    }
  }
}
```

# <a id='s5' class='md-title' href='#top'>5. 泛型的進階設定</a>

- 泛型的設定可使用「`?`」搭配「`extends`」或「`super`」來增加泛型的彈性(`泛型上下邊界設定`)

  - `?`: `Any Type`

- 如:

  - `<? extends Number>`: 代表可以是 Number 或 Number 的子類別

  - `<? super Number>`: 代表可以是 Number 的父類別

```cs
範例程式: "/JavaEx_Part2/src/ch03/GenericAdv.java"
```

```java
package ch03;

class Book<T>{
  T price;
  // 限制自訂泛型的範圍，需在數字有關的類型
  public static void show(Book<? extends Number> b){
    System.out.println("書籍定價為：" + b.price);
  }
}


public class GenericAdv {
  public static void main(String[] args){
    Book<Integer> book = new Book<Integer>();
    book.price = 580;
    Book.show(book);
  }
}
```

# <a id='s6' class='md-title' href='#top'>6. 基本泛型總結</a>

- 請養成在使用 ArrayList 等集合時，都要加上`泛型`的好習慣

- List/Set 只能放單一物件，所以不能放兩種資料型態

```java
// 正確
List<String> data = new ArrayList<String>
// 錯誤
List<String, Integer> data = new ArrayList<String, Integer>
```

- Map 可以放兩種型態，因為裏頭包含 key、val

```java
// 正確
Map<Integer, String> map = new HashMap<Integer, String>();
```

- `<T,K,E,V>`<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>
  - T type
  - K key
  - E element
  - V value

# <a id='s7' class='md-title' href='#top'>7. Iterable 介面</a>

- 從 JDK1-5 開始,Collection 介面增加了新的泛型(Generic Type)功能
  設計,並繼承 JDK1-5 的新介面 Iterable

- 介面 Iterable(JDK1-5):

  - 此介面只有一個 iterator()方法,回傳 iterable 介面
  - `Iterable<T> iterator()`

- 實作 Iterable 介面,其目的是為了允許物件可以使用 JDK1-5 的「增強
  型 for 迴圈(for-each)」語法

- Implementing this interface allows an object to be the target of the
  "foreach" statement

- 當使用 JDK1-5 的 for-each 來走訪集合的元素內容時,一切將顯得格外輕鬆!

# <a id='s8' class='md-title' href='#top'>8. 增強型 for 迴圈 (for – each)</a>

- 增強型的 for 迴圈 (Enhanced for Loop) – for each:

  - 在 JDK1-5 中,針對 for 迴圈作了一些加強,讓我們無需知道陣列
    (array) 或集合(collection)的長度,甚至也不用迭代器(iterator),便
    可以將其中的元素一一取出

  - `使用 for – each 來走訪集合的元素會格外輕鬆`

- 語法:

  - `for (<資料型態> <變數宣告> : <陣列或集合>)`

  - `for (Type varName : listName)`

    - 即可將 listName 裡的元素依順序,由型別為 Type 的變數 varName 存取

    - 陣列或集合中元素的型別必須是可以轉型為 Type 的型別

# <a id='s9' class='md-title' href='#top'>9. Iterable 與 for - each 範例</a>

```cs
範例程式: "/JavaEx_Part2/src/ch03/EnhanceForCollection.java"
```

```java
package ch03;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class EnhanceForCollection {

  public static void main(String[] args) {
    List<String> data = new ArrayList<String>();
    // Set<String> data = new HashSet<String>();
    data.add("Hello");
    data.add("World");

    System.out.println("傳統的for 迴圈");
    for (int i = 0; i < data.size(); i++)
      System.out.println(data.get(i)); // (注意:Set不能用傳統的for迴圈)
    System.out.println();

    System.out.println("使用iterator迴圈");
    for (Iterator it = data.iterator(); it.hasNext();)
      System.out.println(it.next() + " ");
    System.out.println();

    System.out.println("增強功能的 for 迴圈(Using Enhanced foreach)");
    for (String str : data)
      System.out.println(str);
    System.out.println();

  }
}
```

---

```cs
範例程式: "/JavaEx_Part2/src/ch03/EnhanceForMap.java"
```

```java

package ch03;

import java.util.HashMap;
import java.util.Map;

public class EnhanceForMap {

  public static void main(String[] args) {
    Map<Integer, String> map = new HashMap<Integer, String>();

    for (int i = 0; i < 6; i++) {
      map.put(i, "David" + i);
    }
    for (String val : map.values()) {
      System.out.println(val);
    }
    for (Integer val : map.keySet()) {
      System.out.println(val);
    }
  }
}
```

# <a id='s10' class='md-title' href='#top'>10. 傳統 for 與 for-each</a>

- 傳統 for 迴圈效率比 for-each 快，所以 for-each 也是個 suger 用法

# <a id='s11' class='md-title' href='#top'>11. Collection 進一步探討(重點)</a>

- `HashSet`:

  - 自訂物件要實現不重複，需要主動去 override Object 類別的兩個方法 `equals()` 與 `hashCode()`

    - hashCode 可以當作物件編號，但會因為不同的屬性而不相同

- `TreeSet`:

  - 自訂物件要實現不重複，需要在實作 `compareTo()` 方法裡加上`回傳 0`(zero) 的設計，也就是一樣大的意思

- 以上兩點須記下，並背起來。不然實際操作中容易出錯且找不到問題發生的原因

- `ArrayList`、`HashSet`、`HashMap` 為此章節重點

- Collection 在官方被稱作是 Framework。Framewor，也稱作框架，也可當作工具

# <a id='s12' class='md-title' href='#top'>12. Collection 延伸範例</a>

- 基礎的依大小排序,見範例:

```cs
範例程式: "/JavaEx_Part2/src/ch03/TestCollectionsForList.java"
```

```java
package ch03;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class TestCollectionsForList {

  public static void main(String args[]) {
    List list = new ArrayList();
    list.add("5");
    list.add("2");
    list.add("3");
    list.add("4");
    list.add("1");

    // 排序後放入
    Collections.sort(list);// 排序
    Collections.reverse(list); // 倒序

    Object obj;
    for (int i = 0; i < list.size(); i++) {
      obj = list.get(i);
      System.out.println(obj);
    }
  }
}
```

---

```cs
範例程式: "TestArraysForArray.java"
```

```java
package ch03;

import java.util.*;

public class TestArraysForArray {

  public static void main(String args[]) {

    String strArray[] = { "5", "2", "3", "4", "1" };

    Arrays.sort(strArray);

    for (int i = 0; i < strArray.length; i++) {
      System.out.println(strArray[i]);
    }
  }
}
```

---

- Map 以 key 的資料進行大小排序，所以 key 的資料得是相同型別的資料

```cs
範例程式: "/JavaEx_Part2/src/ch03/TestTreeSet.java"
```

```java
package ch03;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class TestTreeSet {
  public static void main(String args[]) {
    Set set = new TreeSet();
    set.add(new Integer(56));
    set.add(new Integer(34));
    set.add(new Integer(12));
    set.add("Hello");

    // TreeSet 只能將相同類型的資料來比較
    Iterator objs = set.iterator();
    while (objs.hasNext())
      System.out.println(objs.next());
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/ch03/TestTreeMap.java"
```

```java
package ch03;

import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class TestTreeMap {
  public static void main(String[] args) {

    // HashMap 不保證key的順序性，有排序只是剛好，沒排序只是正常
    Map<Integer, String> map1 = new HashMap<Integer, String>();
    // TreeMap 會保證key的順序性
    Map<Integer, String> map2 = new TreeMap<Integer, String>(); // TreeMap的Key值要同一種資料型別

    for (int i = 0; i < 10; i++) {
      map1.put(i, "David" + i);
    }
    for (String val : map1.values()) {
      System.out.println(val);
    }

    for (int i = 0; i < 10; i++) {
      map2.put(i, "David" + i);
    }
    for (String val : map2.values()) {
      System.out.println(val);
    }
  }
}
```

---

- 物件大小排序(`實作 Comparable 介面`)見範例:

```cs
範例程式: "Employee.java"
```

```java
package ch03;

// Comparable<T>要比較的物件類型
public class Employee implements Comparable<Employee> {
  private int empno;
  private String ename;

  public void setEmpno(int empno) {
    this.empno = empno;
  }

  public int getEmpno() {
    return empno;
  }

  public void setEname(String ename) {
    this.ename = ename;
  }

  public String getEname() {
    return ename;
  }

  public Employee(int empno, String ename) {
    this.empno = empno;
    this.ename = ename;
  }

  public Employee(int empno) {
    this(empno, "-");
  }

  public Employee(String ename) {
    this(0, ename);
  }

  public Employee() {
    this(0, "-"); // 或 empno = 0; ename = "-"
  }

  public void display() {
    System.out.println("empno=" + empno);
    System.out.println("ename=" + ename);
  }

  public int compareTo(Employee aEmployee) {
    // 用這樣可能有溢位問題，所以不建議使用
    return this.empno - aEmployee.empno;
    // 建議作法，此做法也安全、謹慎
    if (this.empno > aEmployee.empno) {
      return 1;
    } else {
      return -1;
    }
  }
}
```

```cs
範例程式: "TestCollectionsForListEmp.java"
```

```java
package ch03;

import java.util.*;

public class TestCollectionsForListEmp {

  public static void main(String args[]) {
    List<Employee> list = new ArrayList<Employee>();
    Employee e1 = new Employee(7001, "king1");
    Employee e2 = new Employee(7002, "king2");
    Employee e3 = new Employee(7003, "king3");
    Employee e4 = new Employee(7004, "king4");
    Employee e5 = new Employee(7005, "king5");

    list.add(e5);
    list.add(e2);
    list.add(e3);
    list.add(e4);
    list.add(e1);

    Collections.sort(list);
    // Collections.reverse(list);

    for (Employee aEmp : list) {
      System.out.println(aEmp.getEmpno() + "-" + aEmp.getEname());
    }
  }
}
```

---

```cs
範例程式: "Employee.java"
```

```java
package ch03;

// Comparable<T>要比較的物件類型
public class Employee implements Comparable<Employee> {
  private int empno;
  private String ename;

  public void setEmpno(int empno) {
    this.empno = empno;
  }

  public int getEmpno() {
    return empno;
  }

  public void setEname(String ename) {
    this.ename = ename;
  }

  public String getEname() {
    return ename;
  }

  public Employee(int empno, String ename) {
    this.empno = empno;
    this.ename = ename;
  }

  public Employee(int empno) {
    this(empno, "-");
  }

  public Employee(String ename) {
    this(0, ename);
  }

  public Employee() {
    this(0, "-"); // 或 empno = 0; ename = "-"
  }

  public void display() {
    System.out.println("empno=" + empno);
    System.out.println("ename=" + ename);
  }

  public int compareTo(Employee aEmployee) {
    // 實作員工怎麼比大小
    // 物件本身與 aEmployee 相比較，如果 retrun 正值，就表示比 aEmployee 大
    // 正負值代表的是"左右"的意思
    // 很多時候在取資料庫資料時已排序(Order by)完畢，所以目前作法是做更複雜的自訂排序
    if (this.empno > aEmployee.empno) {
      return 1;
    } else {
      return -1;
    }
  }

}
```

```cs
範例程式: "TestArraysForArrayEmp.java"
```

```java
package ch03;

import java.util.Arrays;

public class TestArraysForArrayEmp {

  public static void main(String args[]) {

    Employee e[] = new Employee[5];
    Employee e1 = new Employee(7001, "king1");
    Employee e2 = new Employee(7002, "king2");
    Employee e3 = new Employee(7003, "king3");
    Employee e4 = new Employee(7004, "king4");
    Employee e5 = new Employee(7005, "king5");

    e[0] = e5;
    e[1] = e2;
    e[2] = e3;
    e[3] = e4;
    e[4] = e1;

    // sort方法會自己去呼叫Employee的compareTo方法，取得排序結果
    Arrays.sort(e);

    for (int i = 0; i < e.length; i++) {
      Employee aEmp = e[i];
      System.out.println(aEmp.getEmpno() + "-" + aEmp.getEname());
    }
  }
}
```

- `Employee.java` + `TestTreeSetEmp.java`, `TestTreeMapEmp.java`

```java
package ch03;

// Comparable<T>要比較的物件類型
public class Employee implements Comparable<Employee> {
  private int empno;
  private String ename;

  public void setEmpno(int empno) {
    this.empno = empno;
  }

  public int getEmpno() {
    return empno;
  }

  public void setEname(String ename) {
    this.ename = ename;
  }

  public String getEname() {
    return ename;
  }

  public Employee(int empno, String ename) {
    this.empno = empno;
    this.ename = ename;
  }

  public Employee(int empno) {
    this(empno, "-");
  }

  public Employee(String ename) {
    this(0, ename);
  }

  public Employee() {
    this(0, "-"); // 或 empno = 0; ename = "-"
  }

  public void display() {
    System.out.println("empno=" + empno);
    System.out.println("ename=" + ename);
  }

  public int compareTo(Employee aEmployee) {
    // 實作員工怎麼比大小
    // 物件本身與 aEmployee 相比較，如果 retrun 正值，就表示比 aEmployee 大
    // 正負值代表的是"左右"的意思
    // 很多時候在取資料庫資料時已排序(Order by)完畢，所以目前作法是做更複雜的自訂排序
    if (this.empno > aEmployee.empno) {
      return 1;
    } else {
      return -1;
    }
  }

  public boolean equals(Object obj) {
    if (this == obj)
      return true;

    if (obj != null && getClass() == obj.getClass()) {
      Employee e = (Employee) obj;
      if (this.empno == e.empno && this.ename.equals(e.ename)) {
        return true;
      }
    }

    return false;
  }

  public int hashCode() {
    // 依照屬性作比對
    final int prime = 31;
    int sum = 1;
    sum = prime * empno;
    sum = prime * ename.hashCode();
    return sum;
  }

}
```

```java
/*
 TreeMap的Key值要同一種資料型別
 */

package ch03;

import java.util.*;

public class TestTreeMapEmp {

  public static void main(String[] args) {

    // Map<Employee , String> map = new HashMap<Employee , String>();
    Map<Employee, String> map = new TreeMap<Employee, String>(); // TreeMap的Key值要同一種資料型別

    Employee e1 = new Employee(7001, "king1");
    Employee e2 = new Employee(7002, "king2");
    Employee e3 = new Employee(7003, "king3");
    Employee e4 = new Employee(7004, "king4");
    Employee e5 = new Employee(7005, "king5");

    map.put(e5, e5.getEname());
    map.put(e2, e2.getEname());
    map.put(e3, e3.getEname());
    map.put(e4, e4.getEname());
    map.put(e1, e1.getEname());

    for (String ename : map.values()) {
      System.out.println(ename);
    }

    System.out.println();

    for (Employee aEmployee : map.keySet()) {
      System.out.println(aEmployee.getEmpno());
    }
  }
}
```

# <a id='s13' class='md-title' href='#top'>13. ArrayList 與 LinkedList 差異</a>

- ArrayList: 連續線性方式存放元素
  - 搭配索引值存取元素，效率好。
  - 常對元素插入移除的操作效率差

```
① ② ③ ④ ⑤ ⑥
```

- LinkedList: 優缺點跟 ArrayList 相反

```
   ②      ④
  /   \   /
①     ③
```

- 更進階的排序,如 FIFO,LIFO...等,請參考範例補充分享

  - 依加入順序: `TestLinkedList.java`, `TestLinkedHashSet.java,` `TestLinkedHashMap.java`

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedList.java"
```

```java
/* *
*  LinkedList 也是一可置入"任意物件"的"動態陣列"(可隨內含物多寡增減其長度)
*  如果你需要經常將元素插入和刪除的話 , 那麼 LinkedList 可以有更佳的效率
*  LinkedList 多了
*     void addFirst(Object o);
*     void addLast(Object o);
*     Object getFirst();
*     Object getLast();
*   等方法
*/

package idv.david.additional.sort;

import java.util.*;

public class TestLinkedList {
  public static void main(String args[]) {

    LinkedList list = new LinkedList();
    list.add(new Integer(12));
    list.add(new Long(34L));
    list.add(new Double(5.6));
    list.add("Hello");
    list.add("Hello"); // duplicate, is added

    System.out.println("toString()=" + list);
    System.out.println("元素個數=" + list.size());

    Iterator objs = list.iterator();
    while (objs.hasNext())
      System.out.println(objs.next());

    // List家族可以用Iterator或for迴圈取值
    System.out.println();
    for (int i = 0; i < list.size(); i++) {
      Object obj = list.get(i);
      System.out.println(obj);
    }

    // 其它方法取值1 -> toArray()
    System.out.println();
    Object a[] = list.toArray();
    for (int i = 0; i < a.length; i++)
      System.out.println(a[i]);

    // 只有 LinkedList 才有此addFirst()...等method, 故呼叫此等method時不能用多型的寫法
    System.out.println();
    list.addFirst("first");
    list.addLast("last");
    for (int i = 0; i < list.size(); i++)
      System.out.println(list.get(i));

  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedHashSet.java"
```

```java
package idv.david.additional.sort;

import java.util.*;

public class TestLinkedHashSet {
  public static void main(String args[]) {
    // LinkedHashSet 依照加入順序為順序
    // HashSet 無續且不重覆
    // TreeSet 可自訂排序
    Set set = new LinkedHashSet();
    set.add(new Integer(56));
    set.add(new Integer(34));
    set.add(new Integer(12));

    Iterator objs = set.iterator();
    while (objs.hasNext())
      System.out.println(objs.next());

    System.out.println("===========");

    Set set2 = new HashSet();
    set2.add(new Integer(56));
    set2.add(new Integer(34));
    set2.add(new Integer(12));

    Iterator objs2 = set2.iterator();
    while(objs2.hasNext())
        System.out.println(objs2.next());
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedHashMap.java"
```

```java
package idv.david.additional.sort;

import java.util.*;

public class TestLinkedHashMap {
  public static void main(String[] args) {

//     Map<Integer , String> map = new HashMap<Integer , String>();
//     Map<Integer, String> map = new TreeMap<Integer, String>(); // TreeMap的Key值要同一種資料型別
    Map<Integer , String> map = new LinkedHashMap<Integer , String>();

    for (int i = 6 ; i > 0 ; i--) {
      map.put(i, "David" + i);
    }
    for (String val : map.values()) {
      System.out.println(val);
    }
  }
}
```

---

- 依大小順序: `TestQueue.java`, `TestPriorityQueue1.java`, `TestPriorityQueue2.java`

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestQueue.java"
```

```java
package idv.david.additional.sort;

import java.util.*;

public class TestQueue {
  public static void main(String[] args) {
    // 駐列:
    // 行事曆代辦事項的概念，做完了就不用在裡面存在
    // 餐廳的排隊系統，使用駐列的排隊方式(頭尾處理)
    Queue q = new LinkedList();
    q.offer("First");
    q.offer("Second");
    q.offer("Third");
    Object o;
    System.out.println(q.toString());
    while ((o = q.poll()) != null) {
      String s = (String) o;
      System.out.println(s);
    }
    System.out.println(q.toString());
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestPriorityQueue1.java"
```

```java
package idv.david.additional.sort;

import java.util.PriorityQueue;

public class TestPriorityQueue1 {
  public static void main(String[] args) {
    // 保證資料是用大小順序取出，取完後資料也會為空
    PriorityQueue<String> pq = new PriorityQueue<String>();
    pq.offer("c");
    pq.offer("a");
    pq.offer("b");
    String s;
    while ((s = pq.poll()) != null) {
      System.out.print(s + ", ");
    }
    System.out.print(pq); // a, b, c, []
  }
}
```

# <a id='s14' class='md-title' href='#top'>14. 自訂比較器的三種方法</a>

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/TestPriorityQueue2.java"
```

- 方法 1

```java
package idv.david.additional.sort;

import java.util.Comparator;
import java.util.PriorityQueue;

class MyComparator implements Comparator<String> {
  @Override
  public int compare(String s1, String s2) {
    // 使用java本身提供的字串順序比較，用乘(-1)的方式將資料排序規則倒過來(反轉)
    return s1.compareTo(s2) * -1;
  }

}

public class TestPriorityQueue2 {
  public static void main(String[] args) {

    MyComparator c = new MyComparator();
    // 3 集合初始大小，如果超過後續會動態擴增
    // c 使用自訂的排序規則
    PriorityQueue<String> pq = new PriorityQueue<String>(3, c);
    pq.offer("c");
    pq.offer("a");
    pq.offer("b");
    String s;
    while ((s = pq.poll()) != null) {
      System.out.print(s + ", ");
    }
  }
}
```

- 方法 2

```java
package idv.david.additional.sort;

import java.util.Comparator;
import java.util.PriorityQueue;

public class TestPriorityQueue2 {
  public static void main(String[] args) {
    // 比較器(匿名類別語法)
    Comparator<String> c = new Comparator<String>() {
      public int compare(String a, String b) {
        return a.compareTo(b) * -1;
      }
    };

    MyComparator c = new MyComparator();

    // 3 集合初始大小，如果超過後續會動態擴增
    // c 使用自訂的排序規則
    PriorityQueue<String> pq = new PriorityQueue<String>(3, c);
    pq.offer("c");
    pq.offer("a");
    pq.offer("b");
    String s;
    while ((s = pq.poll()) != null) {
      System.out.print(s + ", ");
    }
  }
}
```

- 方法 3: Java8 簡化

```java
package idv.david.additional.sort;

import java.util.Comparator;
import java.util.PriorityQueue;

public class TestPriorityQueue2 {
  public static void main(String[] args) {
    PriorityQueue<String> pq = new PriorityQueue<String>(3, (a, b) -> a.compareTo(b) * -1);
    pq.offer("c");
    pq.offer("a");
    pq.offer("b");
    String s;
    while ((s = pq.poll()) != null) {
      System.out.print(s + ", ");
    }
  }
}
```

# <a id='s15' class='md-title' href='#top'>15. 堆疊</a>

- 依加入順序(`FIFO`, `LIFO`): `Test_FIFO_List.java`, `Test_LIFO_Stack.java`
  - `FIFO` 先進先出
  - `LIFO` 後進先出(`堆疊`)，`出`表示移除
    - 電梯: 先進去的被擠在裏頭，最後進來的先出門
    - 自助餐: 上面的盤子最後放上，但拿盤子時也是由上面先拿走
    - 衣服穿多層: 越晚穿的越早脫
    - FilSterm: 最後接的水管最早 close()

```cs
範例程式: "/JavaEx_Part2/src/idv/david/additional/sort/Test_LIFO_Stack.java"
```

```java
package idv.david.additional.sort;

import java.util.Stack;

public class Test_LIFO_Stack {
  public static void main(String[] args) {
    Stack list = new Stack();
    list.add("c");
    list.add("a");
    list.add("b");
    list.add("a");
    System.out.println(list.toString());

    // stack 是使用後進先出的方式拿，那就不應該依照index(索引值)方式取值
    // for (int i = 0; i < list.size(); i++)
    // System.out.println(list.get(i));

    System.out.println();

    // stack取值方式應該使用這個
    // 判斷list不為空才pop資料出來
    while (!list.empty())
      System.out.println(list.pop());

  }
}
```

---

參考鏈接:

- [HashSet,TreeSet 和 LinkedHashSet 的区别](https://blog.csdn.net/yy6060/article/details/6589626?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)
- [hashset 和 Linkedset 的区别与联系](https://blog.csdn.net/zhuhai__yizhi/article/details/49494499)

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/mrzhangzifu/article/details/76285702">Java 泛型通配符 T E K V 的区别，以及 class 与 class 的区别</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
