- 語音電話: 使用 UDP 傳輸可將語音都傳過去，但不會斷訊
  - UDP: x...xx.xxxx
  - TCP: x..............
- UDP 也可用在車載影片

- socket 連線測試

```cs
cd C:\EA102_Workspace
java socket.TCPClient 10.120.25.150 8888
```

# socket 範例

- 範例

```cs
範例程式: "/JavaEx_Additional/src/socket/TCPClient.java"
```

- 內容

```java
package socket;
/*
    編譯: javac TcpClient.java
    執行: java TcpClient serverIP serverPort
    例如: java TcpClient 10.120.102.33 8888

    說明: 可以連線任何server
          輸入quit離開
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class TCPClient {
  public static void main(String args[]) {
    String data;
    Socket socket;
    int port;
    InetAddress addr = null;
    BufferedReader key_in = new BufferedReader(new InputStreamReader(System.in));
    BufferedReader s_in;
    PrintWriter s_out;
    if (args.length != 2) {
      System.out.println("java TcpClient serverIP serverPort");
      System.exit(0);
    }

    try {
      addr = InetAddress.getByName(args[0]);
    } catch (UnknownHostException uhe) {
      System.out.println("Server位址錯誤或未知...");
    }
    try {
      port = Integer.parseInt(args[1]);
      socket = new Socket(addr, port); // 此建構子執行的同時就會去連結ServerSocket了
      // in 、 out 應有結束，但因為在main中執行，所以不close也可以
      s_in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      s_out = new PrintWriter(socket.getOutputStream());
      while (true) {
        System.out.println("Client>");
        data = key_in.readLine(); // 讀取輸入的整串文字
        s_out.println(data); // PrintWriter 輸出
        s_out.flush(); // 沖出字串流
        if (data.equals("quit"))
          break;
        System.out.println(s_in.readLine());
      }
      socket.close();
    } catch (IOException ioe) {
      System.out.println("無法連接主機...");
    }
  }
}
```

- server 設置

```cs
範例: "/JavaEx_Additional/src/socket/TCPServer.java"
```

```java
package socket;
/*
    編譯: javac TcpServer.java
    執行: java  TcpServer
    說明: 聆聽  8888 port
          多重client的server
*/

import java.io.IOException;
import java.net.ServerSocket;

public class TCPServer {
  public static void main(String args[]) throws IOException {
    ServerSocket sc = null;
    int count = 0;

    System.out.println("TcpServerM listening port 8888.......");
    try {
      sc = new ServerSocket(8888); // 在8888埠建立ServerSocket, 並等待客戶端的連結
    } catch (IOException ioe) {
      System.err.println("Could not listen on port: 1024.");
      return;
    }

    try {
      while (true) {
        new ConnThread(sc.accept(), ++count).start(); // 連線 (accept方法呼叫時會發生wait(阻斷)，直到有client連過來才會繼續往下執行)
      }
    } catch (IOException ioe) {
      System.err.println("Exception" + ioe);
    }
    sc.close();
  }
}
```

- 撰寫 while 避免因為 run 結束而結束

```cs
"/JavaEx_Additional/src/socket/ConnThread.java"
```

```java
package socket;
import java.io.*;
import java.net.*;

class ConnThread extends Thread {
  private Socket socket = null;
  int threadID;

  public ConnThread(Socket socket, int count) { // 建構子socket為客戶端
    this.socket = socket;
    threadID = count;
  }

  public void run() {
    System.out.println("第" + threadID + "位使用者連線");
    try {
      BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
      PrintWriter out = new PrintWriter(socket.getOutputStream());

      while (true) {
        String msg = in.readLine(); // 由socket讀入的字串msg
        if (msg.equals("quit"))
          break;
        System.out.println("第" + threadID + "位使用者訊息:" + msg);
        String remsg = new String("\t" + "Server接收到訊息:" + msg);
        out.println(remsg);
        out.flush();
      }
      out.close();
      in.close();
      socket.close();
      System.out.println("第" + threadID + "位使用者離線");
    } catch (IOException e) {
      System.out.println(e);
    }
  }
}
```

# 範例分享

- https://drive.google.com/drive/folders/1BsM__n-vynAvYftXgesFpqLZKKPk8xbn

# 範例二說明

```cs
"/WebSocketChatWeb/src/idv/david/websocketchat/controller/TogetherWS.java"
```

```java
package idv.david.websocketchat.controller;

import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import javax.websocket.CloseReason;
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;

// class 名稱自訂
// {userName}路徑參數設計
@ServerEndpoint("/TogetherWS/{userName}")
public class TogetherWS {
  // Session : websocket 的 Session
  private static final Set<Session> connectedSessions = Collections.synchronizedSet(new HashSet<>());

  /*
  * 如果想取得HttpSession與ServletContext必須實作
  * ServerEndpointConfig.Configurator.modifyHandshake()，
  * 參考https://stackoverflow.com/questions/21888425/accessing-servletcontext-and-httpsession-in-onmessage-of-a-jsr-356-serverendpoint
  */
  @OnOpen
  public void onOpen(@PathParam("userName") String userName, Session userSession) throws IOException {
    connectedSessions.add(userSession);
    String text = String.format("Session ID = %s, connected; userName = %s", userSession.getId(), userName);
    System.out.println(text);
  }

  @OnMessage
  public void onMessage(Session userSession, String message) {
    for (Session session : connectedSessions) {
      if (session.isOpen())
        session.getAsyncRemote().sendText(message);
    }
    System.out.println("Message received: " + message);
  }

  @OnClose
  public void onClose(Session userSession, CloseReason reason) {
    connectedSessions.remove(userSession);
    String text = String.format("session ID = %s, disconnected; close code = %d; reason phrase = %s",
        userSession.getId(), reason.getCloseCode().getCode(), reason.getReasonPhrase());
    System.out.println(text);
  }

  @OnError
  public void onError(Session userSession, Throwable e) {
    System.out.println("Error: " + e.toString());
  }

}
```
