<h1 id="top">目錄</h1>

- [1. 物件參考(reference)變數](#s1)
- [2. 記憶體中儲存物件參考變數](#s2)
- [3. 記憶體空間區別](#s3)
- [4. 查看記憶體位置](#s4)
- [5. 垃圾物件的產生與清理](#s5)
- [6. method 與 void](#s6)
- [7. 更完整的解釋](#s7)

---

# <a id="s1" class="md-title" href="#top">1. 物件參考(reference)變數</a>

- 宣告

  - `類別名稱 變數名稱` 即 `Pen myPen`

- 實體化物件

  - 欲產生該物件真正的記憶體空間，必須以 new 關鍵字建立
  - `new Pen()`

- 初始化物件

  - 用 `=` (指定運算子)指派該物件至物件參考變數

    - `myPen = new Pen()`
    - 注意物件參考變數(Object Reference Variables)是個儲存物件在記憶體中位置的變數

- 操作資料

  - 最普遍的方法是利用 `.` 運算子來操作物件的值
  - `myPen.brand = "SKB"`
  - `yourPen.price = 12000.0`

# <a id="s2" class="md-title" href="#top">2. 記憶體中儲存物件參考變數</a>

- [類別型別](#)(物件參考變數)

  - 儲存[記憶體位置(memory address)](#)
  - 即是存在 heap Memery

- [基本資料型別](#)(基本資料型別變數)

  - `byte` > `short` > `int` > `long` >　`float` > `double` > `boolean` > `char`
  - 儲存值(value)
  - 存在 stack Memery

- java 語言裡，資料型別分成兩種

  - 基本資料型別 (stack Memery)
  - 類別資料型別 (heap Memery)
  - stack Memery 儲存門牌[(reference，記憶體位置)](#)，heap Memery 依照門牌找到資料，java 將 heep 的操作全交由 jvm 處理，工程師只能操作 stack

# <a id="s3" class="md-title" href="#top">3. 記憶體空間區別</a>

- 將 myPen1 = myPen2 時，也會變成相同的記憶體空間

<table>
<thead>
<tr>
<th style="text-align:left">不同的記憶體空間</th>
<th style="text-align:left">相同的記憶體空間</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Pen myPen1 = new Pen();</td>
<td style="text-align:left">Pen myPen1 = new Pen();</td>
</tr>
<tr>
<td style="text-align:left">Pen myPen2 = new Pen();</td>
<td style="text-align:left">Pen myPen2 = myPen1;</td>
</tr>
</tbody>
</table>

# <a id="s4" class="md-title" href="#top">4. 查看記憶體位置</a>

- 直接 print 類別物件可以查看系統給予的記憶體位置

```java
package xxx;

public class Student {
  public static void main(String[] args) {
    Student ene = new Student();
    System.out.println(ene);
  }
}
```

---

```cs
xxx.Student@15db9742
```

# <a id="s5" class="md-title" href="#top">5. 垃圾物件的產生與清理</a>

- 垃圾的產生

  - 此物件已不被任何物件參考到，便稱之為**垃圾**
  - 將物件參考變數指定給另一個物件 (指定的是記憶體位置)

```java
public class Student {
  public static void main(String[] args) {
    Student ene = new Student();
    Student eve = new Student();

    // 將物件參考變數指定給另一個物件
    // 因為ene的位置跟eve相等了，所以會產生"垃圾"資料
    ene = eve;
    System.out.println(ene);
    System.out.println(eve);
  }
}
```

---

```cs
xxx.Student@15db9742
xxx.Student@15db9742
```

- 垃圾的清理

  - java 有自動回收機制，由 jvm 管理並回收

- 因為 java 是強行別語言，所以在練習時也能增強程式上的概念

# <a id="s6" class="md-title" href="#top">6. method 與 void</a>

- 方法上如果使用的是 value，則不須另寫回傳值
- 物件導向的特性可以說是以類別為基礎(class-based)的程式設計

# <a id="s7" class="md-title" href="#top">7. 更完整的解釋</a>

```java
package ch07;

/*
* 此範例為傳值傳址測試
*/
public class PassArgTest {

  static void passValue(double value) {
    value = 20.0;
  }

  static void passReference(Pen reference) {
    reference.price = 20.0;
  }

  public static void main(String[] args) {
    // 基本資料型別變數: 儲存值(value)
    double price = 10.0;
    passValue(price); // 這種寫法對price完全不會有任何更動
    System.out.println(price); // 10

    // 物參考變數: 儲存記憶體位置(memory address)
    Pen myPen = new Pen();
    myPen.price = 10.0;
    passReference(myPen);// 但用此方法將物件傳過去，代表物件可以在方法中被使用、修改。

    // JAVA官方定義中，JAVA的運行是PASS BY VALUE。
    // reference(參考) 在JAVA中指的是物件實體的記憶體位置，而這個位置對JAVA來說也是代表一個值，所以所有傳遞都是值
  }
}
```

```java
package ch07;

/*
* 設計一個筆的類別，搭配PenTest.java一起參考使用
* 此為物件導向設計之基礎
*/
public class Pen {
  // 實體變數(屬性變數，成員變數)，需透過物件參考變數進行操作
  String brand;
  double price;

  // 方法成員，需透過物件參考變數進行呼叫
  public void showInfo() {
    System.out.println("牌子為：" + brand);
    System.out.println("價格為：" + price);
  }
}
```

---

參考鏈接

- [Java 面試考題](https://hackmd.io/@a110605/rkNKolQVz?type=view)
