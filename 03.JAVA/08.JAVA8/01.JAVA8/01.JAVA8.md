<h1 id="top">目錄</h1>

- [1. gson](#s1)
- [2. Java 8 New Features](#s2)
- [3. Why Lambda](#s3)
- [4. 為什麼要設計成內部類別?](#s4)
- [5. 匿名類別](#s5)
- [6. 匿名類別的簡化](#s6)
- [7. 怎麼辦到的!?](#s7)
- [8. 為何一定要加入 Lambda 呢?](#s8)
- [9. Lambda Expression](#s9)
- [10. 結論](#s10)

---

# <a id='s1' class='md-title' href='#top'>1. gson</a>

- google 有提供 gson，此功能 override JASONArray 與 JASONObject
- gson 的 key 需與實體變數的名稱相同

# <a id='s2' class='md-title' href='#top'>2. Java 8 New Features</a>

1. Lambda Expression
2. Filtering Collection with Lambda
3. Lambda Build-in Types
4. Operating Collections with Lambda (Stream API)
5. java.time (API)

# <a id='s3' class='md-title' href='#top'>3. Why Lambda</a>

- 讓我們先從內部類別開始說起
  - 類別當中可以再放置類別

```cs
範例檔案: "/JavaEx_Part2/src/ch05/OuterDemo1.java"
```

```java
package ch05;

class OuterDemo1_Test {
  private int outerNumber = 0;

  public void printOuterNumber() {
    System.out.println("3-再由OuterClass自行列印出外層類別的數值");
    System.out.println("outerNumber=" + outerNumber);
  }

  public class InnerClass {
    public void changeOuterNumber() {
      System.out.println("2-由InnerClass驅動變更外層OuterClass的數值");
      outerNumber++;
    }
  }

  public void event() {
    System.out.println("1-OuterClass發生事件");
    InnerClass ic = new InnerClass();
    ic.changeOuterNumber();
  }
}
public class OuterDemo1 {
  public static void main(String[] args) {
    OuterDemo1_Test oc = new OuterDemo1_Test();
    oc.event();
    oc.printOuterNumber();
  }
}
```

# <a id='s4' class='md-title' href='#top'>4. 為什麼要設計成內部類別?</a>

- (1) 讓彼此有邏輯關聯性的類別們能在同一個地方使用

  - 設計為內部類別即可`直接使用外部類別的 private 成員`，無須再
    透過參數傳遞方式，增加了使用上的便利性

- (2) 增加封裝設計的安全性

  - 因為`內部類部可以宣告為 private`，這樣外界就不會知道內部類
    別的存在，達到隱藏細節的設計

- (3) 增加程式閱讀性與維護性

  - 因為程式碼都在同一隻 Java 類別裡，所以在調整與閱讀理解上
    方便

# <a id='s5' class='md-title' href='#top'>5. 匿名類別</a>

- 出現在 android(視窗程式設計)
- 優點
  - 語法簡化
- 缺點
  - 垂直問題
  - 不好處理的語法
  - 無法重複使用 ( <u>因為是匿名類別，一次性使用所以無法複用</u> )
  - 會產生額外的 .class 檔 ( <u>{ClassName}\${1...n}</u>，即會產生類似 AndAnonymous\$1.class 的檔案 )

```java
package ch05;

interface Book {
  void show();
}

class BeforeAnonymous implements Book {

  @Override
  public void show() {
    System.out.println("我是一本書！");
  }

}

class Anonymous {
  public static void main(String[] args) {
    // 以往需再新增類別去實做介面，然後再產生物件去呼叫Override的方法內容
    Book ba = new BeforeAnonymous();
    ba.show();

    // 匿名類別直接實作介面，通常這樣寫法是自己使用，並不是要設計給其他人使用
    // 而且使用到的次數非常少，使用匿名類別即可達到簡便目的
    Book ba2 = new Book() {
      @Override
      public void show() {
        System.out.println("我是一本書！");
      }
    };
  }
}
```

# <a id='s6' class='md-title' href='#top'>6. 匿名類別的簡化</a>

- 作用
  - 垂直問題解決 (一行完成)
  - 乾淨的語法
  - 可重複使用
  - 不再產生額外的 .class 檔

```cs
"/Java8_NewFeatureEx/src/idv/david/lambda/TestLambdaAndAnonymous.java"
```

```java
package idv.david.lambda;

public class TestLambdaAndAnonymous {

  public static void main(String[] args) {
    new TestLambdaAndAnonymous().go();
  }

  private void go() {
    // 依然是Test物件實體
    Runnable r1 = () -> {
      System.out.println("r1: " + this.getClass());
    };

    // 匿名類別會再額外產生一個物件實體
    Runnable r2 = new Runnable() {
      public void run() {
        System.out.println("r2: " + this.getClass());
      }
    };

    new Thread(r1).start();
    new Thread(r2).start();
  }

}
```

# <a id='s7' class='md-title' href='#top'>7. 怎麼辦到的!?</a>

```java
package javafx.event;
interface EventHandler<T> {
  public void handle (T event);
}
```

- 因為該介面`只擁有一個抽象方法` (Single Abstract Method)
  - 因為只有一個抽象方法，就能搭配 lambda 做簡化
- 所以它就被稱為 SAM (Java 8 裡又稱為 Functional Interface)
- 例如 Runnable, GUI Listeners, Comparator 都是

# <a id='s8' class='md-title' href='#top'>8. 為何一定要加入 Lambda 呢?</a>

- (1) 時代在改變

  - 1995 年那時,主要的程式語言都沒有支援 closures(閉包)
  - 例如 Fortran, C, Pascal

- (2) Java 是最後一道防線

  - C++也加進去啦
  - C#在 3 - 0 時也加進去啦啦
  - 現今新起的語言通通都加啦啦啦

- (3) JSR 335 講好要加入 Lambda 了

# <a id='s9' class='md-title' href='#top'>9. Lambda Expression</a>

- 基本的 Lambda 表示式

  - (int x, int y) -> x + y
  - (int x, int y) -> { System.out.println(x + y); }
  - (x, y) -> x + y
    - 參數型別可省略括號!多個參數的話小括號一定要有

- 註: <u>區塊(Block)裡是可以多行敘述的 (但 lambda 風格不建議這麼做)</u>

- 參考範例套件: idv.david.lambda

- 情境:

  - 一個文具管理系統,有筆的相關屬性,如品牌、價格、顏色等
  - 用一個集合裝著各種不同的筆
  - 對系統的操作如下:
    (1) 查詢單價偏高的筆
    (2) 查詢處於安全庫存量的筆
    (3) 查詢可以擦拭的筆

- 重點:
  - 觀察那些查詢相關的方法

# <a id='s10' class='md-title' href='#top'>10. 結論</a>

- 推薦放置位置，servlet 只做接收與分發請求，所以應該放在 service (業務邏輯層)
- 用程式的寫法 join 表，可以`降低 sql 的相依性`。(每個資料庫的 join 寫法有些許不同，如果都用 sql 寫，則切換資料庫時反而會更困難，要改的地方更多)

---

參考鏈接:

- [Java8 Streams filter 使用](https://www.jianshu.com/p/6019e3c6c0a8)
