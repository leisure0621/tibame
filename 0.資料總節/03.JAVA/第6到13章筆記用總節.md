<h1>目錄</h1>

[toc]

---

# 1. JAVA 口角(!)

1. JAVA 是簡單的
2. 所見即物件 ( `Everything is a Object`)

# 2. 物件 類別(!)

- 物件

  1.  attribute(屬性) 或稱為 Characteristics(特徵)

  2.  behavior(行為) 或稱為 Operation(操作)

- 類別

  1. Data Member(資料成員): Virable(變數)

  2. Method Member(方法成員): Method(方法)

- Class(類別) 是 Object(物件) 的 type(資料型態)，Object(物件)是 Class(類別) 產生的 instance(資料實體)

```java
// 類別
public class Pen{
  int price;
  public static void main(String[] args){
    Pen p = new Pen(); // p 即是 Object Reference Virables (物件參考變數)
  }
}
```

- 宣告

  - `Pen p`

- 物件實體化

  - 產生物件真正的記憶體空間: `new Pen();`

- 物件初始化

  - `p = new Pen();`

- `Object Reference Variables`(物件參考變數) 儲存 `memory address`(記憶體位址) 的變數
- `基本資料型別變數` 儲存 `value`(值)

  - 相同的記憶體空間 = 改 A 就改 B，資料在一個記憶體空間所以會互相影響

```java
Pen p1 = new Pen();
Pen p2 = p1;
```

```java
public static void main (String[] args) {
  int amount;
  amount = 10;
  Pen myPen = new Pen();
  Pen yourPen = new Pen();
}
```

| Stack Memory |               |
| ------------ | ------------- |
| amount       | Pass by value |
| myPen        | Pass by value |
| yourPen      | Pass by value |

| Class | Heap Memory | 用法        |                   |
| ----- | ----------- | ----------- | ----------------- |
| myPen | brand       | myPen.brand | Pass by reference |
| myPen | price       | myPen.price | Pass by reference |

| Class   | Heap Memory | 用法          |                   |
| ------- | ----------- | ------------- | ----------------- |
| yourPen | brand       | yourPen.brand | Pass by reference |
| yourPen | price       | yourPen.price | Pass by reference |

- myPen.brand 的做法又稱作物件參考變數

# 3. Stack Heap global Memory

- [Stack](https://antrash.pixnet.net/blog/post/70456505)

  - 生命週期`可預測`，即可交由系統管理(系統會自動產生與回收)

- Heap

  - 生命週期`不可預測`，動態產生的資料(使用者需自己回收)
  - Heap 中的資料如果沒有正常的回收，將會逐步成長到將記憶體消耗殆盡(但 java 有 Garbage Collection 機制所以不須特別處理)

- global

  - 存 static 變數與全域變數

# 4. 物件導向的三大特性(!)

- **封裝** (Encapsulation)

  - `private`、`default`、`protected`、`public`

  - 提升資料存取安全性

- **繼承** (Inheritance)

  - 子類別`繼承父類別成員`，並`可修改`或`新增`自有成員

  - 繼承的同時可擴充所需，表現自身特質

  - `提高程式的重複使用`

- **多型** (Polymorphism)

  - 用同樣方式引用不同類別物件

```java
public class Test {
  void say() {
    System.out.println("Hello");
  }

  public static void main(String[] args) {
    Object[] obj = new Object[2];
    // 利用多型的特性使程式碼簡單易用
    for (int i = 0; i < obj.length; i++) {
      obj[i] = new Test();
      ((Test) obj[i]).say();
    }
  }
}
```

# 5. 陣列(!)

- 陣列是由`一群相同資料型態的變數所組成`的一種資料結構
- 需用 new 分配空間 `int x = new int[3]`，`new 時需指定長度且不可更改`
- 是種 Reference 資料型態，指定運算是傳遞`記憶體位置`
- 元素`有初始值`

#### 5-1. 一維陣列 二維陣列

- 一維 `元素`數
  - 可以的做法
    - int[] xx = new int[4];
- 二維 `列(row)`數
  - 可以的做法
    - int[][] xx = new int[4][];
      xx[0] = new int [3];

```java
// 一維陣列
Pen p[] = new Pen[3];
p[0] = new Pen();
p[1] = new Pen();
p[2] = new Pen();
// 一維陣列
int[] xx = new int[4];
// 二維陣列
int[][] xx = new int[4][];
xx[0] = new int [3];
```

#### 5-2. 複製陣列(!)

- 陣列複製方法 `Arrays.copyOf`(`陣列A`, `陣列A.length`)

```java
int[] 陣列B = Arrays.copyOf(陣列A, 陣列A.length);
```

- 一維陣列才能用
- 複製後的陣列互不影響
- JDK 6 後出現

#### 5-3. 陣列排序(!)

- 陣列排序方法

```java
Arrays.sort(欲排序的陣列名稱)
```

```java
int[] intArray3 = {100, 200, 300, 50};
Arrays.sort(intArray3);
for (int item : intArray3) {
  System.out.print(item + "\t"); // 50 100 200 300
}
```

#### 5-4. 陣列搜尋(!)

- 陣列搜尋前需排序，使用二分法
- 沒搜尋到指定值，返回負值

```java
Arrays.sort(陣列名稱)
Arrays.binarySearch(陣列名稱, 欲搜索的值)
```

```java
int[] intArray3 = {100, 200, 300, 50};
int i1 = Arrays.binarySearch(intArray3, 50); // 0
int i2 = Arrays.binarySearch(intArray3, 150); // -3
```

# 6. String 類別(!)

- 不可變的 (immutable) 字串
- [每個字串都是不同記憶體位置](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/315732/)
  - String 一旦宣告後,即不能在原所在記憶體位置改變字串內容
- 存在 String Pool (字串池)
- new String() 存在 Heap Memory

#### 6-1. equals() 比對字串相等(!)

- 使用 `字串A.equals(要比對的值)`判斷字串是否相等
  - `==` 在 string 中比較的是記憶體空間，非內容

```java
String str1 = new String("abc"); // 新記憶體空間
String str2 = "abc"; // 新記憶體空間
String str3 = new String("abc");
String str4 = "abc"; // 因字串相同，同 str2 一個記憶體空間

System.out.println(str1 == str2); // true
System.out.println(str2 == str4); // true
System.out.println(str1 == str3); // false
System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // true
```

#### 6-2. compareTo() 比對字串是否相等

- 依照 ASCII 比對大小，`多用於排序`
- 若回傳值`=0`，表示兩個字串`相等`
- 若回傳值`>0`，表示`左`邊字串`大於右`邊字串
- 若回傳值`<0`，表示`左`邊字串`小於右`邊字串

```java
String s1 = "Hello", s2 = "Hello";
System.out.println(s1.compareTo(s4)); // 40
```

#### 6-3. charAt() 取得字串字元

```java
String s1 = "Hello";
System.out.println(s1.charAt(4)); // o
```

#### 6-4. length() 取得字串長度(!)

- 返回字串長度，`含空白`

```java
String s1 = "Hello";
System.out.println(s1.length()); // 5
```

#### 6-5. trim() 去除頭尾空白(!)

```java
String s4 = " ", s5 = " Hello ";
System.out.println(s4.trim()); // 空值
System.out.println(s5.trim()); // Hello
```

#### 6-6. isEmpty() 比對字串是否為空(!)

- 字串長度為 0 返回 true，否則 false，`長度含空白`

```java
String s4 = " ";
System.out.println(s4.isEmpty()); // false
System.out.println(s4.trim().isEmpty()); // true
```

#### 6-7. substring(int beginIndex) 擷取字串

- 擷取從`開始`索引值的字元`至結尾`字元的字串
- `由 0 開始`

```java
String s1 = "Hello";
System.out.println(s1.substring(1)); // ello
```

#### 6-8. substring(int beginIndex, int endIndex) 擷取開始至結束前的字串

- 擷取從`開始`索引值的字元`至結束`索引值`之間`的字串
- `由 0 開始`

```java
String s1 = "Hello";
System.out.println(s1.substring(1, 4)); // ell
```

# 7. Varargs 不固定參數個數

- Varargs 意思指`不固定參數個數`，也可稱為`可變參數個數`
- 用`...`宣告，`void method(int...arr){}`
- 需放在最後用
- 一個方法不能有兩個 Varargs

```java
public class AddInt {
  public int varArgTest(int a, int... c) {
    int sum = 0;
    for (int i = 0; i < c.length; i++) {
      sum += c[i];
    }

    return sum;
  }

  public String varArgTest(String... c) {
    String str = "";
    for (String item : c) {
      str += item;
    }

    return str;
  }

  public static void main(String[] args) {
    AddInt add = new AddInt();
    int sum1 = add.varArgTest(5, 1, 2);
    String sum3 = add.varArgTest("Hello", "World");

    System.out.println("sum1=" + sum1); // 3
    System.out.println("sum3=" + sum3); // HelloWorld
  }
}
```

# 8. 封裝三步曲(!)

`1. private` → `2. public getXXX` → `3. public setXXX`

<table>
<thead>
<tr>
<th style="text-align: left;">&nbsp;</th>
<th style="text-align: center;">the Same Class</th>
<th style="text-align: center;">the Same Package</th>
<th style="text-align: center;">SubClass</th>
<th style="text-align: center;">Universe</th>
<th style="text-align: center;">說明</th>
<th style="text-align: center;">類別</th>
<th style="text-align: center;">實體變數</th>
<th style="text-align: center;">方法</th>
<th style="text-align: center;">建構子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">public (公共)</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">所有類別皆能存取</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
</tr>
<tr>
<td style="text-align: left;">protected (保護)</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;"><a href="#">同套件下類別</a>或<a href="#">所有其子類別都可存取</a></td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
</tr>
<tr>
<td style="text-align: left;">default (預設)</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">同套件下的類別皆可存取</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
</tr>
<tr>
<td style="text-align: left;">private (私有)</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">只有該類別內部才可存取</td>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
<td style="text-align: center;">&radic;</td>
</tr>
</tbody>
</table>

# 9. 建構子

```java
public class PenGood {
  public void PenGood(...){...} // 方法 表示沒回傳值
  public PenGood(...){...} // 建構子
}
```

- 建構子也能 overloading

```java
public class PenGood {
  private String brand;
  private double price;

  public PenConstOverload(String brand, double price) {
    this.brand = brand; // "這個物件"的 brand
    this.price = price;
  }
  public PenConstOverload(String brand) {
    this(brand, 10); // 呼叫"這個物件"的其他建構子
  }
}
```

# 10. static 修飾子(!)

- 稱為`類別變數`或`靜態變數`
- 值能`共享共用`
- 建議用法: `ClassName.staticData`

```java
public class Count2 {

  // static區塊
  static {
    System.out.println("static 區塊");
  }

  public static void main(String[] args) {
  }

}
```

```cs
static 區塊
```

# 11. 標註(Annotation)的作用

- 可以協助提醒是否格式錯誤
- 用法: `@Override`

# 12. 繼承(!)

- 用法: A `extends` B
- 子類別繼承可存取的 `成員`, `變數` 與 `方法`
- 為了讓類別後續繼承用，故會留`空建構子(預設建構子)`
- 使用 `super` 呼叫父類別的`建構子`, `方法` 與 `變數`
  - `super.value`
  - `super.method()`
  - `super()`
- 父類別需強轉成子類別才能使用子類別的方法
- `Overriding` 改寫繼承後`方法`
- java 不允許多重繼承，一個類別只能繼承一個父類別

```java
// 類別1
class Employee2 {
  String ename;

  public Employee2(String ename) {
    this.ename = ename;
  }

  public void display() {
    System.out.println("ename = " + this.ename);
  }
}

// 類別2
class FullTimeEmployee2 extends Employee2 {
  public void display2() {
    System.out.println("Hi");
  }

  // Annotation 標注
  @Override
  public void display() {
    System.out.println(super.ename); // 叫父類別參數
  }

  public FullTimeEmployee2(String ename) {
    super(ename); // 叫父類別建構子
  }
}

// 類別3
public class other {
  public static void main(String[] args) {
    Employee2 m1 = new FullTimeEmployee2("Vlady");
    ((FullTimeEmployee2) m1).display2();
    System.out.println("來自父類別的 ename = " + m1.ename);
  }
}
```

---

```java
Hi
來自父類別的 ename = Vlady
```

# 13. final 修飾子(!)

- 宣告 final 後`不能被繼承`, `不能被修改`
- `final Pen myPen = new Pen();` 物件參考變數 final 後, 不能在指向另個物件
- `public static final` 任何人都能用, 但不可修改的值

# 14. 多型(Polymorphism)(!)

- 父類別可以當子類別的通用行別
- 可用 instanceof 判斷當下變數是否為此類別的實體

```java
Integer a = 10;
System.out.println(a instanceof Integer); // true
```

# 15. 抽象 abstract

1. `抽象方法`，那`類別`一定`得宣告成抽象`
2. `抽象類別`不一定要有`抽象方法`
3. `抽象類別`不能建立物件但能建立建構子
4. `抽象類別`入被繼承，則`必須實現`其中的`抽象方法`

- public `abstract` class className {
  public `abstract` void myMethod();
  }

# 16. 介面(interface) (!)

- class 子類別 `extends`，父類別 `implements` 介面 1,介面 2,...{...}

- **目的**

  - 貼標籤

  - 型態轉換

  - 降低相依性
    - 要改的東西都單獨開來不會影響其他人

# 17. 空界面(Tag Interface)(!)

1. `java.lang.Cloneable`

   - 使用此介面才可做物件的複製

```java
public class Test implements Cloneable {
  public static void main(String[] args) {
    Test a = new Test();
    Test b = new Test();

    a = (Test) b.clone(); // 會將記憶體位置的值放入
  }
}
```

2. `java.lang.Serializable`

   - 使用此介面可將物件續列化，永久保存

# 17. Object 的 11 個方法(!)

1. `clone()`：複製此物件
   1. obj1.clone(obj2)
   2. 需 implements Cloneable 介面
2. `equals(Object obj)`：比較兩個物件是否相等
3. `finalize()`：如果物件沒有任何參考指向它，則會呼叫垃圾收集器(garbage collector)回收
4. `getClass()`：取得此物件執行時期的類別
5. `hashCode()`：雜湊值
6. `notify()`：喚醒正在此物件監視上等待的單個線程。
7. `notifyAll()`：喚醒等待此物件監視上等待的所有線程。
8. `toString()`：回傳代表此物件的字串說明
9. `wait()`：導致當前線程等待，直到另一個線程調用此物件的 notify() 方法或 notifyAll() 方法。
10. `wait(long timeout)`：導致當前線程等待，直到另一個線程調用此物件的 notify() 方法或 notifyAll() 方法，或者已經過了指定的時間量。
11. `wait(long timeout, int nanos)`：導致當前線程等待，直到另一個線程為此對象調用 notify() 方法或 notifyAll() 方法，或者某個其他線程中斷當前線程，或者已經過了指定的時間量。

# 18. 包裝類別(!)

- boxing: 將基本型別，置入相對應的包裝類別中(裝箱/包裝)
  - byte 即 java.lang.Byte
  - short 即 java.lang.Short
  - ...
- 現已都含有自動裝拆箱的功能
- JDK5 後的功能

```java
Integer i1 = 1;
int i2 = i1;

int sum1 = i1 + i2;
Integer sum2 = i1 + i2;
System.out.println(sum1); // 2
System.out.println(sum2); // 2
```
