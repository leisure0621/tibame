<h1 id="top">目錄</h1>

- [1. 介面(interface)](#s1)
- [2. 使用介面的差別](#s2)
- [3. 空介面(Tag Interface)](#s3)

---

# <a id="s1" class="md-title" href="#top">1. 介面(interface)</a>

- 多重繼承

  - Java 只能單一繼承，而介面可以實現物件導向中的多重繼承(替代 C++中的多重繼承)

  - class 子類別 extends，父類別 implements 介面<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 1,介面 2,...{...}

  - ckass 子類別 implements 介面 1,介面 2,...{...}

- 定義規格

  - 預先**定義規格**給實作此介面的所有子類別

  - 介面可說是一種**所有方法皆為抽象方法的抽象類別**，所以子類別必須**實作**介面的所有抽象方法(class 內方法內全空)

  - 而介面跟介面之間是可以在**繼承(extends)**的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>

- 介面<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>類別強制其中的**方法**都是**公開(public)的抽象(abstract)方法**，所以 `void disp();` 跟 `public abstract void disp();` 相同

- 介面類別強制其中的**變數**都是**公開(public)靜態(static)常數(final)**，所以 `int num = 100;` 跟 `public static final int num = 100;`

- 貼標籤

- 型態轉換

- 降低相依性

  - X 低凝聚性 - 高相依性

    - 明明都有共同的用法卻不用，造成每次都要牽一髮而動全身

  - √ 高凝聚性 - 低相依性<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>

    - 把東西都分類好，要改的東西都單獨開來不會影響其他人

# <a id="s2" class="md-title" href="#top">2. 使用介面的差別</a>

- 使用前

  - 不相干的 class 都會繼承到 bird，會造成混亂且會有很多用不到的語法

<div style="overflow: auto; margin: 15px;">
  <div style="max-width: 652px; min-width: 652px;">
    <div
      style="
        background: rgba(66, 185, 130, 0.1);
        border-radius: 50%;
        text-align: center;
        padding: 30px;
        height: 500px;
        width: 500px;
      "
    >
      <div>Bird<br />fly(){...}</div>
      <div
        style="
          padding: 35px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Eagle<br />fly(){...}
      </div>
      <div
        style="
          padding: 40px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Sparrow<br />fly(){...}
      </div>
      <div
        style="
          padding: 45px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Superman<br />fly(){...}
      </div>
      <div
        style="
          padding: 35px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Plane<br />fly(){...}
      </div>
    </div>
  </div>
</div>

<br>

- 使用後

  - class 能直接繼承介面中宣告的方法、變數，實現 OOP 中的[多重繼承](#%E4%BB%8B%E9%9D%A2interface)

<div style="overflow: auto; margin: 15px;">
  <div style="max-width: 652px; min-width: 652px;">
    <div
      style="
        text-align: center;
        border: 1px dashed #ddd;
        margin: 0 auto 20px auto;
        padding: 15px;
        width: 628px;
      "
    >
      &lt;&lt; interface &gt;&gt;<br />Flyable<br />fly();
    </div>
    <div
      style="
        background: rgba(66, 185, 130, 0.1);
        border-radius: 50%;
        text-align: center;
        padding: 30px;
        height: 350px;
        width: 350px;
        float: left;
      "
    >
      <div>Bird<br />fly(){...}</div>
      <div
        style="
          padding: 35px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Eagle<br />fly(){...}
      </div>
      <div
        style="
          padding: 40px 30px;
          margin: 15px;
          background: rgba(66, 185, 130, 0.1);
          border-radius: 50%;
          float: left;
          margin-top: 40px;
        "
      >
        Sparrow<br />fly(){...}
      </div>
      <div
        style="
          height: 22px;
          background: #ddd;
          width: 1px;
          margin-left: 147px;
          margin-top: -91px;
        "
      ></div>
    </div>
    <div
      style="
        padding: 45px 30px;
        margin: 15px;
        background: rgba(66, 185, 130, 0.1);
        border-radius: 50%;
        float: left;
        margin-top: 40px;
        height: 130px;
      "
    >
      <div>Superman<br />fly(){...}</div>
      <div
        style="
          height: 61px;
          background: #ddd;
          width: 1px;
          margin-left: 35px;
          margin-top: -145px;
        "
      ></div>
    </div>
    <div
      style="
        padding: 35px 30px;
        margin: 15px;
        background: rgba(66, 185, 130, 0.1);
        border-radius: 50%;
        float: left;
        margin-top: 40px;
        height: 110px;
      "
    >
      <div>Plane<br />fly(){...}</div>
      <div
        style="
          height: 60px;
          background: #ddd;
          width: 1px;
          margin-left: 23px;
          margin-top: -135px;
        "
      ></div>
    </div>
  </div>
</div>

<br>

# <a id="s3" class="md-title" href="#top">3. 空介面(Tag Interface)</a>

- 沒有定義任何方法的介面叫做空介面

- `java.lang.Cloneable` 和 `java.lang.Serializable` 是比較著名的空介面

  - class 使用 Cloneable 空介面，才可以做物件的複製

  - class 使用 Serializable 空介面，才可以將物件作序列化，該物件永久儲存(persistence) 稱作序列化

- 一個類別可以 implements 某個空介面，好消息是不需實作任何方法，但**該類別的任何實體即已經成為該介面的一個合法實體**<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>

  ```java
  package ch11;

  public interface IWritable {
    void write();
  }
  ```

  ```java
  package ch11;

  public class WorkWithPens2 {
    private IWritable writable;

    public IWritable getWritable() {
      return writable;
    }

    public void setWritable(IWritable writable) {
      this.writable = writable;
    }

    public void writeWithPens() {
      writable.write();
    }
  }
  ```

  ***

  ```java
  package ch11;

  public class InkBrush2 implements IWritable {
    public void write() {
      System.out.println("用毛筆寫字");
    }
  }
  ```

  ```java
  package ch11;

  public class Pencil2 implements IWritable {
    public void write() {
      System.out.println("用鉛筆寫字");
    }
  }
  ```

  ```java
  package ch11;

  public class WriteBusinessTest2 {
    public static void main(String[] args) {
      WorkWithPens2 business1 = new WorkWithPens2();
      business1.setWritable(new Pencil2());
      business1.writeWithPens();

      WorkWithPens2 business2 = new WorkWithPens2();
      business2.setWritable(new InkBrush2());
      business2.writeWithPens();
    }
  }
  ```

  ***

  ```cs
  用鉛筆寫字
  用毛筆寫字
  ```

---

參考鏈接

- [Java(类作为成员变量类型)](https://blog.csdn.net/weixin_38088772/article/details/91041309)
- [How is it possible to use a class name as a variable name in Java?](https://www.quora.com/How-is-it-possible-to-use-a-class-name-as-a-variable-name-in-Java)
- [抽象類別 (Abstract Class) vs 介面 (Interface)](https://coffee0127.github.io/blog/2016/09/10/abstract-class-vs-interface/)
- [interface 是什麼東西](https://www.javaworld.com.tw/jute/post/view?bid=29&id=294242)
- [What does it mean for a function to return an interface?](https://stackoverflow.com/questions/5699427/what-does-it-mean-for-a-function-to-return-an-interface)

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>可以稱為<strong>介面</strong>、<strong>窗口</strong>、<strong>接口</strong> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>會考，建議加強概念 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>介面檔可以以 <code>I</code> 做開頭 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>資料庫則是低凝聚高相依 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Design Pattern 設計模式又稱做策略模式(相關資料可查詢<strong>歐萊禮</strong>的<strong>深入淺出</strong>系列書及) <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
