<h1 id="top">目錄</h1>

- [1. Math 類別](#s1)
- [2. Math 類別常用方法](#s2)
- [3. Math 使用範例](#s3)
- [4. String 類別與 StringBuffer 類別](#s4)
- [5. StringBuilder 類別](#s5)
- [6. Regular Expression 正規表示法](#s6)
- [7. Regex 範例與練習](#s7)
- [8. 取得日期與時間](#s8)
- [9. Calendar 類別常數](#s9)
- [10. java.util.Date 類別](#s10)
- [11. Calendar 時間用法](#s11)
- [12. 時間之 Calendar 與 GregorianCalendar](#s12)
- [13. 簡易格式化輸出](#s13)
- [14. 簡易格式化輸入](#s14)
- [15. 系統屬性](#s15)
- [16. 資源回收機制 (Garbage Collection)](#s16)
- [17. 列舉類型](#s17)
- [18. 排程跟實作](#s18)

# <a id='s1' class='md-title' href='#top'>1. Math 類別</a>

- java.lang.Math 類別提供許多數學上實用的方法如亂數、絕值、平方根、立方根與三角函數等,讓程式設計師在設計時,省去許多數學運算程式碼的撰寫

- 因為 java.lang.Math 類別所提供的屬性與方法都是類別等級(都是 static 修飾子),因此我們只要透過 Math 類別名稱,即可呼叫所需的屬性或方法,非常方便

# <a id='s2' class='md-title' href='#top'>2. Math 類別常用方法</a>

<table>
<tbody>
<tr style="height: 23px;">
<td style="height: 23px;">方法</td>
<td style="height: 23px;">說明</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double abs(double a)<br />float abs(float a)<br />int abs(int a)<br />long abs(long a)</td>
<td style="height: 83px;">回傳a的絕對值</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double max(double a, double b)<br />float max(float a, float b)<br />int max(int a, int b)<br />long max(long a, long b)</td>
<td style="height: 83px;">比較a, b大小後,回傳較大者</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double min(double a, double b)<br />float min(float a, float b)<br />int min(int a, int b)<br />long min(long a, long b)</td>
<td style="height: 83px;">比較a, b大小後,回傳較小者</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double pow(double a, double b)</td>
<td style="height: 23px;">回傳a的b次方運算結果</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">random()</td>
<td style="height: 23px;">回傳一個double類型的亂數,值介於0.0(含)~1.0(不含)</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double sqrt(double a)</td>
<td style="height: 23px;">回傳a的正平方根</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double cbrt(double a)</td>
<td style="height: 23px;">回傳a的立方根</td>
</tr>
</tbody>
</table>

# <a id='s3' class='md-title' href='#top'>3. Math 使用範例</a>

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestMath.java"
```

```java
package ch05;

public class TestMath {
  public static void main(String[] args) {
    System.out.println("Math.PI = " + Math.PI);
    System.out.println("Math.abs(-1.1) = " + Math.abs(-1.1));
    System.out.println("Math.random = " + Math.random());
    System.out.println("Math.max(1.1, 2.1) = " + Math.max(1.1, 2.1));
    System.out.println("Math.min(1.1, 2.1) = " + Math.min(1.1, 2.1));
    System.out.println("Math.pow(3, 3) = " + Math.pow(3, 3));
    System.out.println("Math.sqrt(9) = " + Math.sqrt(9));
    System.out.println("Math.cbrt(27) = " + Math.cbrt(27));
  }
}
```

# <a id='s4' class='md-title' href='#top'>4. String 類別與 StringBuffer 類別</a>

- String 類別不可在原字串所在記憶體位置改變字串內容

- StringBuffer 類別則在原字串所在記憶體位置改變字串內容(append, insert, delete, replace)

- 使用 StringBuffer 類別中的任何方法時,回傳的字串會使用原有的記憶體空間

- `StringBuffer 字串與 String 字串不可以比較`

  - SreintBuffer 未 Override equals 方法

- 如:
  - String s1 = new String(“test”);
  - String s2 = new StringBuffer(“test”);
  - if (s1 == s2) {...} //false
  - if (s1.equals(s2)) {...} //false

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestStringBuffer.java"
```

```java
package ch05;

public class TestStringBuffer {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("Hello Java ");
    sb.append("StringBuffer!");
    System.out.println(sb); // Hello Java StringBuffer!

    StringBuffer sb2 = new StringBuffer();
    sb2.append("現在是上午").append(11).append("點"); // 現在是上午11點

    StringBuffer sb3 = new StringBuffer("Hello  StringBuffer!");
    sb3.insert(6, "Java");
    System.out.println(sb3); // Hello Java StringBuffer!

    StringBuffer sb4 = new StringBuffer("Hello Java StringBuffer!");
    sb4.replace(7, 10, "AVA");
    System.out.println(sb4); // Hello JAVA StringBuffer!

    StringBuffer sb5 = new StringBuffer("Hello Java StringBuffer!");
    sb5.delete(6, 10);
    System.out.println(sb5); // Hello  StringBuffer!

    StringBuffer sb1 = new StringBuffer("AB");
    System.out.println("sb1= " + sb1); // sb1= AB

    StringBuffer sb2 = sb1.append("CD");
    System.out.println("sb1= " + sb1); // sb1= ABCD
    System.out.println("sb2= " + sb2); // sb2= ABCD

    System.out.println(sb1 == sb2); // true 比較址
    System.out.println(sb2.equals(sb1)); // true

    StringBuffer sb = new StringBuffer("AB"); // 需轉成string才能比較
    String s = "AB";
    System.out.println(s3.equals(sb1.toString())); // true
  }
}
```

# <a id='s5' class='md-title' href='#top'>5. StringBuilder 類別</a>

- StringBuilder 類別是 JDK 5 的新類別,其用法與 StringBuffer 類別完全一樣(append, insert, delete, replace)

- 老類別 StringBuffer 是 `thread-safe`(同步) ,新類別 StringBuilder 則是 non-thread-safe

  - 跟 vector , Hashtable 一樣有同步化的優點

- 使用上,如果不考慮多執行緒的問題可以使用 StringBuilder 來提升執行的效率

# <a id='s6' class='md-title' href='#top'>6. Regular Expression 正規表示法</a>

- 正規表示法(Regular Expression)就是由許多樣式的符號組成的樣式句,
  主要功能就是用來比對文字是否符合該規則的要求

- 正規表示法並非 Java 語法,但為了通過編譯,都是以字串型式存在,
  等到要執行時,再由特定的編譯器進行處理

- 正規表示法在本課程會簡略說明,如有興趣的同學可以在網路上搜尋
  到更多規則與說明

<table>
  <tbody>
    <tr style="height: 23px;">
      <td style="height: 23px;">符號</td>
      <td style="height: 23px;">說明</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[ABC]</td>
      <td style="height: 23px;">
        <p>
          A、B、C任一個字元都符合要求<br />例:[ABC]ook,可以是Aook, Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[^ABC]</td>
      <td style="height: 23px;">
        <p>
          不可以含有A、B、C任一個字元<br />例:[^ABC]ook,就不可以是Aook,
          Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[A-C]</td>
      <td style="height: 23px;">
        <p>
          可以是A到C連續字元的任何一個<br />例:[A-C]ook,可以是Aook, Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[^A-C]</td>
      <td style="height: 23px;">
        <p>
          不可以含有A到C連續字元的任何一個<br />例:[^A-C]ook,就不可以是Aook,
          Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n,m}</td>
      <td style="height: 23px;">
        代表指定字元出現次數最少n次,最多m次<br />逗號之間不得有空白,n與m都要是大於等於0的整數n
        &lt;= m<br />例:Book{1,2}代表k最少要出現1次,最多2次,即Book或Bookk
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n}</td>
      <td style="height: 23px;">
        <p>
          代表指定字元正好出現n次<br />例:Book{1}代表k要出現正好1次,所以只能是Book
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n,}</td>
      <td style="height: 23px;">
        <p>
          代表指定字元至少出現n次<br />
          例:Book{1,}代表k要出現至少1次以上,可以是Book, Bookk...
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\d</td>
      <td style="height: 23px;">可以是0~9任何一個數字,相當於[0-9]</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\D</td>
      <td style="height: 23px;">不可以是0~9任何一個數字,相當於[^0-9]</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\s</td>
      <td style="height: 23px;">可以是空白的字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\S</td>
      <td style="height: 23px;">不可以是空白的字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\w</td>
      <td style="height: 23px;">可以是一個英文字母或數字</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\W</td>
      <td style="height: 23px;">不可以是任何英文字母或數字</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">?</td>
      <td style="height: 23px;">
        指定字元最多出現1次,也可以不出現,相當於{0,1}<br />例:S?PP就可以是PP或SPP。?在S後面,則是S受到?限制
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">+</td>
      <td style="height: 23px;">指定字元至少要出現1次以上,相當於{1,}</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">*</td>
      <td style="height: 23px;">指定字元出現0次以上,相當於{0,}</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">.</td>
      <td style="height: 23px;">任一字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">( )</td>
      <td style="height: 23px;">
        <p>
          括弧內,代表同一個群組<br />例:(SPP){2}代表SPP是一體,必須同時出現2次:SPPSPP
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\</td>
      <td style="height: 23px;">
        取消原運算符號的功能,使其成為單純文字<br />例:2014\-06\-13代表取消「-」符號功能,這與Java的跳脫符號<br />「\」相同,所以結果一定要是2014-06-13
      </td>
    </tr>
  </tbody>
</table>

- 可搭配 String 類別提供的 boolean matches(String regex),回傳是否符
  合正規表示法的文字格式

- 另介紹 String 類別的 String[] split(String regex),符合運算式的部份會
  被當做分隔符號移除掉,剩下部份回傳到字串陣列裡

# <a id='s7' class='md-title' href='#top'>7. Regex 範例與練習</a>

- 手機號驗證

```java
package ch05;

import java.util.Scanner;

public class RegTest {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    System.out.println("請輸入手機號碼");
    String tel = sc.next();
    sc.close();

    String regex = "09[0-9]{2}-\\d{6}";
    if (tel.matches(regex)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }
  }
}
```

- [身分證字號驗證](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/320404/)

- 官方文件的 `java.util.regex` 中有詳細使用說明

```java
package ch05;

import java.util.Scanner;

public class RegTest {
  public static void main(String[] args) {
    Scanner sc2 = new Scanner(System.in);
    System.out.println("請輸入身分證");
    String IDcard = sc2.next();
    String regex2 = "[A-Za-z]{1}[12]{1}[0-9]{8}";

    if (IDcard.matches(regex2)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }

    // /p{Alpha} 忽略大小寫
    String regex3 = "^\\p{Alpha}[12]\\d{8}$";
    if (IDcard.matches(regex3)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }
    sc2.close();
  }
}
```

- 特殊處裡

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestSplit2.java"
```

```java
package ch05;

public class TestSplit2 {
  public static void main(String args[]) {

    String str1 = "boo:and:foo";

    // 因為不是最後一個字所以中間的O會變成空字串保留
    String[] tokens1 = str1.split(":"); // { "boo", "and", "foo" }
    for (int i = 0; i < tokens1.length; i++) {
      System.out.println(tokens1[i]);
    }

    System.out.println("-----------------------");

    String[] tokens2 = str1.split("o"); // { "b", "", ":and:f" } //參考String API文件的split方法
    for (int i = 0; i < tokens2.length; i++) {
      System.out.println(tokens2[i]);
    }

    System.out.println("-----------------------");

    // 正規表示法方式，解決所有O，正規處理後大數據工程師稱為wash data(清洗資料)
    String[] tokens3 = str1.split("o+"); // { "b", ":and:f" } //+指任意多個重複的字元
    for (int i = 0; i < tokens3.length; i++) {
      System.out.println(tokens3[i]);
    }

    System.out.println("-----------------------");

    String str = "http://tw.yahoo.com";
    String[] tokens = str.split("[:/.]+"); // { "http", "tw", "yahoo", "com" } //[]指在[]中的任意一個字元

    for (int i = 0; i < tokens.length; i++) {
      System.out.println(tokens[i]);
    }
  }
}
```

# <a id='s8' class='md-title' href='#top'>8. 取得日期與時間</a>

- 取得今天的日期與現在時間

  - Calendar rightNow = Calendar.getInstance();

    - `Calendar`為`抽象類別`(因為有設為 static，所以可以用類別直接呼叫方法)

  - `java.util.Date rightNow` = new java.util.Date();

    - `java.util.Date`表示某一時間點(一般是使用 util 中的方法)

- 其它與日期有關的常用類別還有

  - `GregorianCalendar` 此為`Calendar 的子類別`,適合用來設定某一特定的日期

    - `GregorianCalendar` 建構子提供的時間點

  - `java.sql.Date` 此為 java.util.Date 的子類別,用在資料庫的日期格式

  - `DateFormat` 用來`格式化` java.util.Date,可設定國別格式與時區,用在`國際化`

    - 國際化: `i18N` (InternationalizatioN)

      - i 中間 18 字母，最後 N

  - `SimpleDateFormat` 用來`格式化` java.util.Date,簡單的日期格式化

- 註:

  - 利用 Calendar 物件的 getTime()方法,可產生 java.util.Date 物件

    - `java.util.Date du = cal.getTime();` cal 是 `Calendar` 物件

  - 利用 java.util.Date 物件的 getTime() 方法,可得到自 1970 年 1 月 1 日 0 時 0 分 0 秒起的`總毫秒數`

    - `long len = du.getTime();` du 是 `java.util.Date` 物件

    - **1970 年 1 月 1 日 0 時 0 分 0 秒** (這是系統的起始時間，用來紀念 UNIX)

# <a id='s9' class='md-title' href='#top'>9. Calendar 類別常數</a>

- 周末是周六，周日是一天的開始

<table>
<tbody>
<tr style="height: 23px;">
<td style="height: 23px;">常數名稱</td>
<td style="height: 23px;">值</td>
<td style="height: 23px;">注意</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.YEAR</td>
<td style="height: 23px;">年</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.MONTH</td>
<td style="height: 23px;">月</td>
<td style="height: 23px;">得到的值須<code>+1</code></td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.DATE</td>
<td style="height: 23px;">日</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.HOUR_OF_DAY</td>
<td style="height: 23px;">24時制的時</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.MINUTE</td>
<td style="height: 23px;">分</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.SECOND</td>
<td style="height: 23px;">秒</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.DAY_OF_WEEK</td>
<td style="height: 23px;">星期幾</td>
<td style="height: 23px;">得到的值須<code>-1</code>，當索引值操作<br>["日", "一", "二", "三", "四", "五", "六"]</td>
</tr>
</tbody>
</table>

# <a id='s10' class='md-title' href='#top'>10. java.util.Date 類別</a>

- 在 Java 1.0.2 版中 java.util.Date 有數種功能,但在 `Java 1.1 開始,其中大部份的方法都已被淘汰(Deprecated)`,所以 java.util.Date 目前功能就是表示`某一時間點`

# <a id='s11' class='md-title' href='#top'>11. Calendar 時間用法</a>

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestCalendar.java"
```

```java
package ch05;

import java.util.Calendar;

public class TestCalendar {

  static String[] week = { "日", "一", "二", "三", "四", "五", "六" };

  public static void main(String args[]) {
    // 取得「執行環境」的系統時間
    Calendar cal = Calendar.getInstance();
    int y = cal.get(Calendar.YEAR);
    int m = cal.get(Calendar.MONTH) + 1;
    int d = cal.get(Calendar.DATE);
    int h = cal.get(Calendar.HOUR);
    int min = cal.get(Calendar.MINUTE);
    int sec = cal.get(Calendar.SECOND);
    System.out.print("今天是: ");
    System.out.println(y + "年" + m + "月" + d + "日");
    System.out.print("現在是: " + (cal.get(Calendar.AM_PM) == 0 ? "上午" : "下午"));
    System.out.println(h + "點" + min + "分" + sec + "秒");

    int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
    System.out.println("星期" + week[w]);

    System.out.println();
  }
}
```

# <a id='s12' class='md-title' href='#top'>12. 時間之 Calendar 與 GregorianCalendar</a>

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestGregorianCalendar.java"
```

```java
package ch05;

import java.util.Calendar;
import java.util.GregorianCalendar;

public class TestGregorianCalendar {
  static String[] week = { "日", "一", "二", "三", "四", "五", "六" };

  public static void main(String args[]) {
    Calendar cal[] = new Calendar[6];
    cal[0] = new GregorianCalendar(2015, Calendar.JANUARY, 15, 0, 0, 0); // 到秒 second
    cal[1] = new GregorianCalendar(2014, Calendar.JANUARY, 1, 0, 0); // 到分 minute
    cal[2] = new GregorianCalendar(2014, Calendar.JUNE, 1); // 到日 month
    cal[3] = new GregorianCalendar(); // 現在
    cal[4] = new GregorianCalendar();
    cal[5] = new GregorianCalendar(1991, (5 - 1), 29);

    for (int i = 0; i < cal.length; i++)
      showTime(cal[i]);
  }

  static void showTime(Calendar cal) {
    int y = cal.get(Calendar.YEAR);
    int m = cal.get(Calendar.MONTH) + 1;
    int d = cal.get(Calendar.DATE);
    int h = cal.get(Calendar.HOUR_OF_DAY);
    int min = cal.get(Calendar.MINUTE);
    int sec = cal.get(Calendar.SECOND);
    System.out.print("日期: ");
    System.out.println(y + "年" + m + "月" + d + "日");
    System.out.print("時間: ");
    System.out.println(h + "點" + min + "分" + sec + "秒");

    int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
    System.out.println("星期" + week[w]);

    // 與LinkedList一樣，欲使用isLeapYear方法不可使用多型寫法，需使用GregorianCalendar型態建立GregorianCalendar物件
    // 閏年判斷
    boolean isLeap = ((GregorianCalendar) cal).isLeapYear(y);
    System.out.println(isLeap);
  }
}
```

# <a id='s13' class='md-title' href='#top'>13. 簡易格式化輸出</a>

- Simple Formatter Output(簡易的格式化輸出:printf)

  - JDK 5 新增 System.out.printf()方法
  - printf() 方法源自於 java.util.Formatter 類別
  - 比如只需寫出: `"%tY/%<tm/%<td %<tT%n"`

    - `<` 沿用前面使用的參數資料

    - 即可輸出:2014/06/13 17:38:20 之結果

```java
java.util.Date d = new java.util.Date();
System.out.printf("%tY/%<tm/%<td %<tT%n", d);
```

- 範例

  - TestFormatter.java
    (printf()對照 DecimalFormat 與 SimpleDateFormat 類別)
  - TestDateFormat.java
    (熟悉 java.text.DateFormat 類別之應用)

- SimpleDateFormat 可以直接對日期做簡易格式化
  - `Format sfm = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");`

```CS
範例程式: "/JavaEx_Part2/src/ch05/TestFormatter.java"
```

```JAVA
package ch05;

import static java.lang.System.out;

import java.text.DecimalFormat;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.Date;

public class TestFormatter {
  public static void main(String[] args) {

    out.println("------------------數字格式化-------------------");

    double num1 = 12345.678;
    out.println(num1 + "【格式化之前】\n");

    // 使用DecimalFormat類別
    Format dfm1 = new DecimalFormat("#,###.00");
    out.println(dfm1.format(num1) + "【使用DecimalFormat類別格式化】");

    // 使用printf
    out.printf("%,.2f【使用printf格式化】%n", num1);

    out.println("\n------------------日期格式化-------------------");

    Date d1 = new Date();
    out.println(d1 + "【格式化之前的java.util.Date】\n");

    Format sfm1 = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
    out.println(sfm1.format(d1) + "【使用SimpleDateFormat類別格式化】");
    Format sfm2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    out.println(sfm2.format(d1) + "【使用SimpleDateFormat類別格式化】\n");

    out.printf("%tY/%<tm/%<td %<tT【使用printf格式化】%n", d1);
    out.printf("%tF %<tT【使用printf格式化】%n", d1);

    out.println("\n-----------------------------------------------");

    out.printf("我叫%s, 今年%d歲%n", "Peter", 18); // %s字串 , %d整數 , %n換行
    out.printf("PI值趨近於%f ,而自然對數E趨近於%f%n", Math.PI, Math.E); // %f浮點數
    out.printf("PI值不是null: %b", Math.PI); // %b非null為true , null為false

  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestDateFormat.java"
```

```java
package ch05;

import java.text.DateFormat;
import java.util.Locale;
import java.util.TimeZone;

public class TestDateFormat {
  public static void main(String[] args) {
    // 隨地區語言而變, 如
    Locale[] locale = new Locale[5];
    locale[0] = Locale.TAIWAN; // new Locale("zh","TW");
    locale[1] = Locale.US; // new Locale("en","US");
    locale[2] = Locale.JAPAN; // new Locale("ja","JP");
    locale[3] = Locale.KOREA; // new Locale("ko","KR");
    locale[4] = Locale.GERMANY; // new Locale("de","DE")等不同地區語言

    for (int i = 0; i < locale.length; i++) {
      timeFormats(locale[i]);
    }

    // 有那些時區
    String[] ids = TimeZone.getAvailableIDs();
    for (int i = 0; i < ids.length; i++)
      System.out.println(ids[i]);

    // 利用建構子放入自訂設定
    // 傳回所有語言環境的陣列
    Locale[] locales1 = DateFormat.getAvailableLocales();
    for (int i = 0; i < locales1.length; i++)
      System.out.println(locales1[i] + "=" + locales1[i].getDisplayName());

    Locale[] locales2 = Locale.getAvailableLocales();
    for (int i = 0; i < locales2.length; i++)
      System.out.println(locales2[i] + "=" + locales2[i].getDisplayName());
    // locales[i]: 使用由下劃線分隔的語言、國家/地區和變數來獲取整個語言環境的編程名稱。
    // locales[i].getDisplayName(): 傳回適合向用戶顯示的語言環境名

    // Locale常數測試
    System.out.println("Locale.TAIWAN=" + Locale.TAIWAN);
    System.out.println("Locale.TAIWAN=" + Locale.US);
    System.out.println("Locale.JAPAN=" + Locale.JAPAN);
    System.out.println("Locale.KOREA=" + Locale.KOREA);
    System.out.println("Locale.GERMANY=" + Locale.GERMANY);

  }

  static void timeFormats(Locale locale) {
    DateFormat[] df = new DateFormat[8];
    // 與地區無關(預設本地格式)
    df[0] = DateFormat.getInstance();
    df[1] = DateFormat.getDateInstance(DateFormat.FULL);
    df[2] = DateFormat.getTimeInstance(DateFormat.FULL);
    df[3] = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);

    // 設定時區
    df[4] = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, locale);
    df[5] = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);
    df[6] = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, locale);
    df[7] = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, locale);

    // 透過format方法, 將java.util.Date格式化為, 所要顯示的資訊
    for (int i = 0; i < df.length; i++) {
      // 設定時區, 如 Japan ; America/Los_Angeles ; Australia/Queensland 等不同的時區
      TimeZone tz = TimeZone.getTimeZone("Taiwan");
      df[i].setTimeZone(tz);
      System.out.println(tz.getDisplayName());// 傳回適合於展示給預設區域的用戶的時區名稱

      String dfu = df[i].format(new java.util.Date());
      System.out.println(dfu);
      System.out.println("-------------------------------");
    }

  }
}
```

# <a id='s14' class='md-title' href='#top'>14. 簡易格式化輸入</a>

- Simple Formatter Input(簡易的格式化輸入:Scanner)

- 如 JDK 5 之前的版本要從鍵盤讀入整數值的作法

```java
InputStreamReader isr = new InputStreamReader(System.in);
BufferedReader br = new BufferedReader(isr);
String s = br.readLine();
int n = Integer.parseInt(s);
```

- JDK 5 以後的版本可改寫成?

  - `int n = sc.nextInt();`

```java
Scanner sc = new Scanner(System.in);
String s = sc.next();
int n = sc.nextInt();
```

# <a id='s15' class='md-title' href='#top'>15. 系統屬性</a>

- 系統屬性(System Properties)可以顯示系統的環境資訊
- public static Properties getProperties():

  - 取得所有的系統屬性
  - 回傳 Properties 類別的物件

- public static String getProperty(String key):
  - 回傳特定系統屬性名稱的值
- public static String setProperty(String key, String value):
  - 設定特定的系統屬性
  - 要設定系統屬性,也可在程式執行時設定
    - java –DmyProperty=myValue HelloWorld
      -D 與屬性之間不得有任何空白字元

# <a id='s16' class='md-title' href='#top'>16. 資源回收機制 (Garbage Collection)</a>

- 通常 Java 會在記憶體不足時,自動執行垃圾收集的動作

- 如果想要自己強制 Java 進行垃圾收集時,可透過使用 System.gc();的方法

- JVM 將記憶體空間最佳化後,就會將控制權還給原來進行中的程式

- 嚴格來講 System.gc();只是建議系統應啟動 GC,它不一定會完全執行,我們也不知道 GC 的正確啟動時間

# <a id='s17' class='md-title' href='#top'>17. 列舉類型</a>

- `列舉類型(enum)`

  - 列舉 enum 適合使用在某些狀況的表現(如:`一年有四季`、`一週有七天`)
  - enum 除了常數設置功能外,還給了您許多編譯時期的檢查功能

- `enum 的特性`

  - enum 本質上還是一個`類別`,編譯器會將 enum 轉成類別,其內部除可定義本身的 enum
    types(列舉子)外,仍可以有 fields、methods 跟 constructors,但與一般類別不同的是:

    - enum 本身不具備類別的某些功能,如繼承
    - constructors 不能為 public 和 protected,因 enum 型別不能產生物件

  - 必需使用關鍵字 enum 定義列舉型態

    - enum 型態預設繼承自 java.lang.Enum 類別
    - enum types(`列舉子`)預設為 `public static final`
    - 列舉子的值其實是它本身的名稱

  - 它可以和泛型以及增強型 for 迴圈(for-each)很好地搭配
  - 它也可以使用在 switch 控制中

```cs
範例程式: "/JavaEx_Part2/src/ch05/EnumeratedTypes1.java"
```

```java
package ch05;

/*
 將數個參考值或名稱集合在一起。
 這種集合的方法，並不是陣列，也不屬於容器。通常我們之它為列舉：
 enum Month 是一個類別，姑且可稱之為列舉類別。
 - 列舉本身就是一種型別
 - 從 getClass() 中即可看出來是個類別。
 */

enum Month {
  JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
}

public class EnumeratedTypes1 {
  public static void main(String[] args) {

    for(Month xx : Month.values()) { // 增強式的 for 迴圈
      System.out.print(xx + " ");
    }

    System.out.println();

    Month yy = Month.JAN;
    System.out.println(yy); // JAN , 列舉子的值其實是它本身的名稱

    System.out.println(yy.getClass()); // class Month
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/ch05/EnumeratedTypes2_1.java"
```

```java
package ch05;

/*更複雜的列舉定義
 底下示範了一個比較複雜的例子，由這個例子中可以看出，
 列舉其實只是一種比較特殊的類別，
 所以我們也才一直稱呼 enum 為列舉「型別」。
 它可以擁有自訂建構式、欄位以及方法，
*/

enum SuitA {
  club(1), diamond(2), heart(3), spade(4);

  private int value; // 欄位

  SuitA(int value) { // 因為設定 club(1), ..，所以必須要撰寫此一建構式
    this.value = value;
  }

  public int getValue() { // 方法
    return value;
  }

  public void setValue(int value) {
    this.value = value;
  }
}

public class EnumeratedTypes2_1 {
  public static void main(String[] args) {
    for (SuitA suit : SuitA.values()) {
      System.out.println(suit + "=" + suit.getValue());
    }
    SuitA suit = SuitA.diamond;
    System.out.println(suit.getValue());
    suit.setValue(10);
    System.out.println(suit.getValue());
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/ch05/EnumeratedTypes2_2.java"
```

```java
package ch05;

/*更複雜的列舉定義
 底下示範了一個比較複雜的例子，由這個例子中可以看出，
 列舉其實只是一種比較特殊的類別，
 所以我們也才一直稱呼 enum 為列舉「型別」。
 它可以擁有自訂建構式、欄位以及方法，
*/

enum SuitB {
  spade("黑桃"), heart("紅心"), diamond("方塊"), club("梅花"), ;

  private String type; // 欄位

  SuitB(String type) { // 因為設定 club("梅花"), ..，所以必須要撰寫此一建構式
    this.type = type;
  }

  public String getType() { // 方法
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }
}

public class EnumeratedTypes2_2 {
  public static void main(String[] args) {
    for (SuitB suit : SuitB.values()) {
      System.out.println(suit + "=" + suit.getType());
    } // spade=黑桃 heart=紅心 diamond=方塊 club=梅花

    SuitB suit = SuitB.spade;
    System.out.println(suit.getType()); // 黑桃
    suit.setType("※我是黑桃");
    System.out.println(suit.getType()); // ※我是黑桃
  }
}
```

- 列舉的更多應用

```cs
範例程式: "idv.david.additional.enumevo"
```

# <a id='s18' class='md-title' href='#top'>18. 排程跟實作</a>

```cs
範例程式: "/JavaEx_Additional/src/schedule/MyTask.java"
```

```java
package schedule;

import java.util.Date;
import java.util.TimerTask;

public class MyTask extends TimerTask {

  @Override
  public void run() {
    System.out.println("執行時間為： " + new Date());
  }

}
```

```cs
範例程式: "/JavaEx_Additional/src/schedule/TestSchedule.java"
```

```java
package schedule;

import java.util.Calendar;
import java.util.Date;
import java.util.Timer;

public class TestSchedule {

  public static void main(String[] args) {
    TestSchedule ts[] = new TestSchedule[3];
    for (int i = 0; i < ts.length; i++)
      ts[i] = new TestSchedule();

    ts[0].testDelayTask();
    System.out.println("--------------------");
    ts[1].testDelayAndPeriod();
    System.out.println("--------------------");
    ts[2].testDateAndPeriod();
  }

  private void testDelayTask() {
    Timer timer = new Timer();

    System.out.println("Delay 5 seconds.");
    System.out.println("Start Time: " + new Date());

    timer.schedule(new MyTask(), 5000);

    try {
      Thread.sleep(10000);
    } catch (InterruptedException ie) {

    }
    timer.cancel();
    System.out.println("End Time: " + new Date());
  }

  private void testDelayAndPeriod() {
    Timer timer = new Timer();

    System.out.println("Delay 5 seconds. Period 2 seconds.");
    System.out.println("Start Time: " + new Date());

    timer.schedule(new MyTask(), 5000, 2000);

    try {
      Thread.sleep(10000);
    } catch (InterruptedException ie) {

    }
    timer.cancel(); // 取消排程
    System.out.println("End Time: " + new Date());

  }

  private void testDateAndPeriod() {
    Timer timer = new Timer();

    // 排程設定時間格式
    Calendar calendar = Calendar.getInstance();
    // 當下的15秒後值行
    calendar.set(Calendar.SECOND, calendar.get(Calendar.SECOND) + 15);
    Date firstTime = calendar.getTime();

    System.out.println("Start Time: " + new Date());
    System.out.println("設定執行Date為15秒後：" + firstTime + ", Period：10 seconds.");

    timer.schedule(new MyTask(), firstTime, 10000);

    try {
      Thread.sleep(30000);
    } catch (InterruptedException ie) {

    }
    timer.cancel();
    System.out.println("End Time: " + new Date());

  }
}
```

- 補足之前所有排程，與忽略之前所有排程

```cs
範例程式: "/JavaEx_Additional/src/schedule/Scheduler.java"
```

```java
package schedule;

import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Timer;

public class Scheduler {
	public static void main(String[] args) {

		Timer timer = new Timer();

		Calendar cal = new GregorianCalendar(2017, Calendar.FEBRUARY, 1, 0, 0, 0);

		// 補足所有未執行排程，補足後由設定時間每一分鐘值行一次
		timer.scheduleAtFixedRate(new MyAnotherTask(), cal.getTime(), 1 * 60 * 1000);

		// 當下每分鐘值行
		timer.schedule(new MyAnotherTask(), cal.getTime(), 1 * 60 * 1000);
	}
}
```
