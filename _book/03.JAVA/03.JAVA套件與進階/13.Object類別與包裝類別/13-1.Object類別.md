<h1 id="top">目錄</h1>

- [1. Object 類別](#s1)
- [2. 主動改寫(Override) equals() 方法](#s2)
- [3. 主動改寫(Override) toString() 方法](#s3)
- [4. 使用 filalize() 方法](#s4)
- [5. 使用 clone() 方法](#s5)
- [6. 總結](#s6)

---

# <a id='s1' class='md-title' href='#top'>1. Object 類別</a>

- Object 類別常用方法

  - boolean equals(Object obj)

    - 自訂類別產生的物件要比較內容是否相同，須主動改寫 equals 方法

  - String toString()

    - 通常會 override 此方法是為了方便觀察物件內容，或是 debug 時查看內容

  - protected void finalize()

    - 物件被回收前處裡<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>

  - final void wait() notify() notifyAll()

    - 屬於執行序的部分

# <a id='s2' class='md-title' href='#top'>2. 主動改寫(Override) equals() 方法</a>

- 父類別 Object 的 equal 方法

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

- 改寫 equal 方法

```java
package ch13;

public class Employee {
  private int empno;
  private String ename;

  public void setEmpno(int empno) {
    this.empno = empno;
  }

  public int getEmpno() {
    return empno;
  }

  public void setEname(String ename) {
    this.ename = ename;
  }

  public String getEname() {
    return ename;
  }

  public Employee(int empno, String ename) {
    this.empno = empno;
    this.ename = ename;
  }

  public Employee(int empno) {
    this(empno, "-");
  }

  public Employee(String ename) {
    this(0, ename);
  }

  public Employee() {
    this(0, "-");
  }

  public void display() {
    System.out.println("empno=" + empno);
    System.out.println("ename=" + ename);
  }

  // 要給任何物件使用，所以傳入值設定為 obj
  public boolean equals(Object obj) {
    // 仍要使用==來判斷，因為(也許)要比較的"物件參考變數"，其實指的是同一個實體(指向同一個記憶體空間)
    if (this == obj)
      return true;
    // 用(Object類別的)getClass()來確定是否隸屬於同一個class的物件
    // obj != null 表示沒有物件，沒有記憶體位置(門牌號碼)
    if (obj != null && getClass() == obj.getClass()) {
      if (obj instanceof Employee) {
        Employee e = (Employee) obj;
        // 選擇該類別的必要成員變數(實體變數)來加以判斷是否有相等(相同)
        if (empno == e.empno && ename.equals(e.ename)) {
          return true;
        }
      }
    }
    return false;
  }

  public int hashCode() {
    // 借用一下 String 類別現有的hashCode運算法則
    return this.ename.hashCode();
    // 或借用一下 Integer類別現有的hashCode運算法則
    // return new Integer(this.empno).hashCode();
  }
}
```

- 執行

```java
package ch13;

public class TestEquals {
  public static void main(String args[]) {
    Employee e1 = new Employee(7001, "king");
    Employee e2 = new Employee(7001, "king");

    System.out.println("e1==e2 = " + (e1 == e2));
    System.out.println("e1.equals(e2) = " + e1.equals(e2));
  }
}
```

***

```java
e1==e2 = false
e1.equals(e2) = true
```

# <a id='s3' class='md-title' href='#top'>3. 主動改寫(Override) toString() 方法</a>

- 主要用於 debug 方便

```java
package ch13;

public class TestEquals {
  public static void main(String args[]) {
    Employee e1 = new Employee(7001, "king");
    Employee e2 = new Employee(7001, "king");

    System.out.println(e1.getEmpno());
    System.out.println(e1.getEname());
    System.out.println("---------------------------");
    // 會自動執行 Employee 的 toString() 方法
    // toString()會默認執行，一般用於debug
    System.out.println(e1);
  }
}
```

```java
package ch13;

public class Employee {
  private int empno;
  private String ename;

  public void setEmpno(int empno) {
    this.empno = empno;
  }

  public int getEmpno() {
    return empno;
  }

  public void setEname(String ename) {
    this.ename = ename;
  }

  public String getEname() {
    return ename;
  }

  public Employee(int empno, String ename) {
    this.empno = empno;
    this.ename = ename;
  }

  public Employee(int empno) {
    this(empno, "-");
  }

  public Employee(String ename) {
    this(0, ename);
  }

  public Employee() {
    this(0, "-");
  }

  public void display() {
    System.out.println("empno=" + empno);
    System.out.println("ename=" + ename);
  }

  @Override
  public String toString() {
    String str = "empno=" + empno + ",ename=" + ename;
    return str;
  }
}
```

***

```cs
7001
king
---------------------------
empno=7001,ename=king
```

# <a id='s4' class='md-title' href='#top'>4. 使用 filalize() 方法</a>

- java 默認執行 filalize()

```java
package ch13;

class ClassFinalize {
  protected void finalize() {
    System.out.println("finalize方法執行了");
  }
}

public class TestFinalize {
  public static void main(String args[]) {
    ClassFinalize fin = new ClassFinalize();
    fin = null;
    System.out.println("強制進行垃圾收集");
    System.gc(); // 不一定執行
  }
}
```

***

```java
強制進行垃圾收集
finalize方法執行了
```

# <a id='s5' class='md-title' href='#top'>5. 使用 clone() 方法</a>

- `myShirt = yourShirt.clone();` 時會將記憶體位置的值放入

  - 看到物件中有 `native` ，表示使用更原生的語法(C++...)，如果要更深入的研究請參考 JVM 深入原理<br><br>

<table>
<thead>
<tr>
<th style="text-align:center">參數</th>
<th style="text-align:center">記憶體位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">yourShirt</td>
<td style="text-align:center">0x66</td>
</tr>
<tr>
<td style="text-align:center">myShirt</td>
<td style="text-align:center"><s>0x12</s> 0x88</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th style="text-align:center">新物件</th>
<th style="text-align:center">記憶體位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">0x66</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">0x12</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">0x88</td>
</tr>
</tbody>
</table>

```java
package ch13;

public class TestCloneableShirt implements Cloneable {

  private char colorCode = 'U'; // Unknown (未知)

  public char getColorCode() {
    return colorCode;
  }

  public void setColorCode(char newCode) {
    switch (newCode) {
    // ( R || G || B ) 只要符合都會執行 colorCode = newCode;
    case 'R':
    case 'G':
    case 'B':
      colorCode = newCode;
      break;
    default:
      System.out.println("不正確的顏色碼. 請使用 R, G, or B");
    }
  }

  public static void main(String[] args) {
    TestCloneableShirt myShirt = new TestCloneableShirt();
    TestCloneableShirt yourShirt = new TestCloneableShirt();
    myShirt.setColorCode('R');
    yourShirt.setColorCode('G');

    // System.out.println(myShirt.getColorCode()); // R
    try {
      myShirt = (TestCloneableShirt) yourShirt.clone();
    } catch (CloneNotSupportedException e) {
      System.out.println("不允許複製此物件!");
      e.printStackTrace();
    }
    System.out.println(myShirt.getColorCode()); // G
  }
}
```

- 淺層複製

```java
package ch13;

public class ShallowCopy { // 淺層複製
  public static void main(String[] args) {
    int[] iArray = { 1, 2, 3 };
    // java 對 array 可以直接複製副本並且用double回傳
    int[] iArray2 = iArray.clone();

    // 確認有正常複製，不互相影響
    iArray[0] = 0;
    System.out.println(iArray[0]);
    System.out.println(iArray2[0]);

    System.out.println("----------------------");

    Animal[] as = new Animal[2];
    as[0] = new Animal(2, 5.0f);
    as[1] = new Animal(10, 25.0f);

    // 指複製表面(淺層複製)，不會複製Animal中的結構，所以實際上只複製記憶體位置
    // 類別類型的複製，只複製記憶體位置
    Animal[] as2 = as.clone();
    as[0].setAge(100);

    System.out.println(as[0].getAge());
    System.out.println(as2[0].getAge());

  }
}
```

- 深層複製

```java
package ch13;

public class TestDeepCopy {

  public static void main(String[] args) {
    // 建立測試資料
    Animal a1 = new Animal(2, 5.0f);
    Animal a2 = new Animal(5, 15.0f);
    Animal[] as = new Animal[2];
    as[0] = a1;
    as[1] = a2;

    // 創建一個陣列, 到時候將複製好的Animal物件放入
    Animal[] as2 = new Animal[as.length];
    for (int i = 0; i < as.length; i++) {
      // 先從原本陣列取出要複製的Animal物件
      Animal originalAnimal = as[i];
      // new一個Animal物件 (才會是不同的記憶體空間)
      Animal newAnimal = new Animal();
      // 取出原本Animal物件的值
      int age = originalAnimal.getAge();
      float weight = originalAnimal.getWeight();
      // 將值設定到剛創建出來的Animal物件裡
      newAnimal.setAge(age);
      newAnimal.setWeight(weight);
      // 放進新的陣列裡
      as2[i] = newAnimal;
    }
    as[0].setAge(10);

    // 兩個陣列都是放著Animal物件, 但都是不同的記憶體空間, 因此不會有修改的情況發生
    System.out.println(as[0].getAge());
    System.out.println(as2[0].getAge());
  }
}
```

***

```java
10
2
```

# <a id='s6' class='md-title' href='#top'>6. 總結</a>

- Object 給所有東西都能用的物件，可自由延伸、更改

- JAVA 是物件導向嗎?

  - 資料全都是物件的操作方式，但 byte、short、int、long、flot、double、boolean、char 是基本資料型別，所以有的人說 java 不是純物件導向

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>finalize 一般很少用到 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
