<h1 id="top">目錄</h1>

- [1. 多型(Polymorphism)](#s1)
- [2. 晉升](#s2)
- [3. 轉型](#s3)
- [4. instancef 運算子](#s4)
- [5. 多型的 Overriding](#s5)
- [6. 簡化實體化做法](#s6)

---

# <a id="s1" class="md-title" href="#top">1. 多型(Polymorphism)</a>

- 所謂多型(Polymorphism)是**運用類別間繼承的關係**(is a)，使父類別(superclass)可以當成子類別(subclass)的通用**型態**(type)

# <a id="s2" class="md-title" href="#top">2. 晉升</a>

- 子類別可以[自動升級(晉升)](../3.定數、變數、常數與運算子/3-12.晉升與型別轉換.md)成父類別

  - 有繼承(此方式套用類別間的繼承關係)
  - Employee(員工) 位階低(子類別)
  - FullTimeEmployee(正職員工) 位階高(父類別)

```java
Employee e1 = new FullTimeEmployee(); // 型別晉升
```

```java
Employee e1 = new Manager(); // 型別晉升
```

```java
Employee e1 = new PartTimeEmployee(); // 型別晉升
```

<div style="overflow: auto; margin: 15px;">
<div style="max-width: 652px; min-width: 652px;">
<div
style="
background: rgba(66, 185, 130, 0.1);
width: 590px;
border-radius: 50%;
text-align: center;
padding: 30px;
"
>
<div>Employee</div>
<div>
<div
style="
padding: 35px 10px;
margin: 35px;
background: rgba(66, 185, 130, 0.1);
border-radius: 50%;
width: 210px;
"
>
FullTimeEmployee
<div
style="
  padding: 35px 10px;
  background: rgba(66, 185, 130, 0.1);
  border-radius: 50%;
  width: 100px;
  margin: 15px auto;
"
>
Manager
</div>
</div>
<div
style="
padding: 85px 10px;
margin: 35px;
background: rgba(66, 185, 130, 0.1);
border-radius: 50%;
width: 210px;
"
>
PartTimeEmployee
</div>
</div>
</div>
</div>
</div>

# <a id="s3" class="md-title" href="#top">3. 轉型</a>

- **父類別**若是要**轉型**成**子類別**，則需要靠強迫轉型(Casting)，但是會在執行時期檢查是否能夠轉回適當的子類別
  轉型要比對`EmployeePoly e1 = new FullTimeEmployee(7002, "peter", 50000.0)` 的 `FullTimeEmployee`
  `FullTimeEmployee` 繼承 `EmployeePoly`，所以轉型成 `FullTimeEmployee` 或 `EmployeePoly` 都可以

  ```java
  EmployeePoly e1 = new FullTimeEmployee(7002, "peter", 50000.0);
  FullTimeEmployee f = (FullTimeEmployee)e1; // 轉型 FullTimeEmployee = FullTimeEmployee 轉型成功
  ```

  - `java.lang.ClassCastException` 轉型失敗的例外(不符合繼承關係)

    - 因為物件實體是**動態**(程式執行時)產生的，所以在編譯時無法得知參考變數指向的物件實體是什麼
    - 物件轉型比基礎類別轉型危險度更高，因為要執行後才看得出效果<br><br>

  ```java
  Manager m = (Manager)e1; // 執行時發生 java.lang.ClassCastException
  ```

# <a id="s4" class="md-title" href="#top">4. instancef 運算子</a>

- instanceof 運算子常被用來判斷父類別[參考真正指向何種子類別的實體](#s1)

```java
EmployeePoly e1 = new FullTimeEmployeePoly(7002, "peter", 50000.0);

System.out.println(e1 instanceof FullTimeEmployeePoly); // true
System.out.println(e1 instanceof ManagerPoly); // false
System.out.println(e1 instanceof PartTimeEmployeePoly); // false
System.out.println(e1 instanceof EmployeePoly); // true
```

```java
EmployeePoly e2 = new ManagerPoly(7003, "merry", 50000.0, 10000.0);

System.out.println(e3 instanceof FullTimeEmployeePoly); // true
System.out.println(e3 instanceof ManagerPoly); // true
System.out.println(e3 instanceof PartTimeEmployeePoly); // false
System.out.println(e3 instanceof EmployeePoly); // true
```

```java
EmployeePoly e3 = new PartTimeEmployeePoly(7004, "John", 1000.0, 8);

System.out.println(e3 instanceof FullTimeEmployeePoly); // false
System.out.println(e3 instanceof ManagerPoly); // false
System.out.println(e3 instanceof PartTimeEmployeePoly); // true
System.out.println(e3 instanceof EmployeePoly); // true
```

# <a id="s5" class="md-title" href="#top">5. 多型的 Overriding</a>

- 使**不同類別**中的**方法**可在**繼承後**改為自己所需的結構

```java
public class FullTimeEmployeePoly extends EmployeePoly {
  ...
  // add
  public double getSalary() {
    return monthlySalary;
  }
  ...
}
```

```java
public class ManagerPoly extends EmployeePoly {
  ...
  // add
  public double getSalary() {
    double monthlySalary = super.getSalary();
    return monthlySalary + bonus;
  }
  ...
}
```

```java
public class PartTimeEmployeePoly extends EmployeePoly {
  ...
  // add
  public double getSalary() {
    return hourPay * workHour;
  }
  ...
}
```

# <a id="s6" class="md-title" href="#top">6. 簡化實體化做法</a>

- 用父類別的型別(參考)，指向子類別的物件，並對應到子類別(Overriding)的方法

  - **執行時期**父類別會先判斷實際的子類別物件是哪一個，再呼叫此子類別裡對應的 `Overriding` 方法，此機制在物件導向裡稱為 `dynamic binding` 或 `late binding`

  - 不同型別，不能一致的處裡資料

  - 相同型別，可以一致的處裡資料

  - 放在一起(一致性處裡，程式碼簡化)

```java
// 不同型別，不能一致的處裡資料
ManagerPoly e0 = new ManagerPoly(7003 ,"merry", 50000.0 , 10000.0);
```

```java
// 相同型別，可以一致的處裡資料
EmployeePoly e0 = new ManagerPoly(7002 ,"peter", 40000.0 );
```

```java
// 放在一起(一致性處裡，程式碼簡化)

// 使用共同型別的宣告是為了資料的一致性處裡
EmployeePoly[] e = new EmployeePoly[3]; // 1. 宣告物件的陣列大小
e[0] = new FullTimeEmployeePoly(7002 ,"peter", 40000.0 ); // 2. 將物件實體化
e[1] = new ManagerPoly(7003 ,"merry", 50000.0 , 10000.0);
e[2] = new PartTimeEmployeePoly(7004 , "John" , 1000.0, 8);

// 因為簡化了前面的實體化作法，故在此可以一次處裡所有 getSalary() 方法，且會確認物件是否真的存在(物件執行到new了後才存在)
for (int i = 0; i < e.length; i++)
  System.out.println(e[i].getSalary());

// 也能夠一起檢查可否轉型成 FullTimeEmployeePoly 類別
for (int i = 0; i < e.length; i++)
  if (e[i] instanceof FullTimeEmployeePoly)
    System.out.println("yes");
  else
    System.out.println("no");
```

- Java 自動判斷繼承關係

  - 編譯時期，Java 會根據我們宣告使用的類別來檢查呼叫的方法，或是存取的屬性是否存在(身分(資料型別)決定你的行為與特徵)

  - 父類別的方法不能省去，否則會無法進行對應造成錯誤

```java
EmployeePoly[] e = new EmployeePoly[3];
FullTimeEmployeePoly e0 = new FullTimeEmployeePoly(7002, "peter", 40000.0);
ManagerPoly e1 = new ManagerPoly(7003, "merry", 50000.0, 10000.0);
PartTimeEmployeePoly e2 = new PartTimeEmployeePoly(7004, "John", 1000.0, 8);
e[0] = e0; // JAVA會自動判斷類別間有沒有繼承關係，符合就可Polymorphism
e[1] = e1;
e[2] = e2;
for (int i = 0; i < e.length; i++)
  // 父類別的方法 getSalary 不能隨意省略
  System.out.println(e[i].getSalary());
```

---

參考鏈接

- [物件陣列的運用](http://www.tsnien.idv.tw/Java2_WebBook/chap5/5-4%20%E7%89%A9%E4%BB%B6%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8.html)
- [JAVA - 物件轉成陣列](https://blog.xuite.net/webrsb/study/61707633-JAVA+-+%E7%89%A9%E4%BB%B6%E8%BD%89%E6%88%90%E9%99%A3%E5%88%97)
