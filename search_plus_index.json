{"./":{"url":"./","title":"Introduction","keywords":"","body":"BACKGROUND 因為之前工作的原因有豐富的網站接案經驗， 能與設計師合作將靜態設計內容轉換成動態網頁， 並可在溝通中討論出更適合的視覺排版效果， 並在溝通中加速合作效率，並完整實現。 熟悉 code: vue、小程序、公眾號、C# mvc、jquery、php CMS: wordpress 開發: wordpress plugin 接入: line api、綠界 api SEO: yest seo、Google Analytics 經手站台: 尚孔教育: http://www.sunkongedu.com/ 七見櫻堂: http://www.nksdchoco.com/ ... 現正在學習 java 領域 "},"0.一些上课需要注意的地方/note.html":{"url":"0.一些上课需要注意的地方/note.html","title":"Note","keywords":"","body":"Tibame Java 實體班課程 老師聯繫方式 班導的聯係方式 名稱：黃馨瑧 信箱：Cinderella_Huang@wiedu.com 公司：緯育 電話：0800-022282 #217 Line ID：dodohuang01 上課注意事項 每個學員會輪值日，寫教室日誌 課程進度與內容大綱要好好寫 沒有作業就寫 \"無\" 值日生照座號輪 當日體溫大於等於 37.5 度，需在家上課 實體教室與班級 班級：EA102 教室：205 注意 教學樓：8.30am ～ 8.00pm 開放 周末有課才開放教學樓，平時不開放 上課樓無下課鍾聲，如果時鐘慢了需報修 上課前都須使用 QRCode 打卡 遲到可跟櫃臺說補簽到 每天帶身份證（勞動部不定期訪查） 老師都在資源服務組中 上課時間 上午：9.00 ～ 12.00 下午：13.30 ～ 16.30 夜間：18.30 ～ 21.30 打卡時段 上午：8.00~9.15 下午：12.30~13.45 夜間：17.30~18.45 請假 請假可到一樓櫃臺拿假單（可事後補），老師們都在一個事務室 曠課 3 小時 = 請假 6 小時 出缺勤超過 60 小時及成績未達 60 或 F就不發證書 結訓後需歸還隨身硬碟 借教室 需在當天 4 點前上 google 文件申請完成 6 人以上才能申請教室 晚班教室在時間到前不能出樓，即 8 點前不能走 2-3 樓有休息室，學校不開放室內運動場，室外開放 信件包裹 學校信箱：中央大學郵局第 01 號信箱 EA102 郵寄包裹：中壢市中大路 300-1 號 中央大學內專案二館 資策會 EA102 班 停班停課 桃園放颱風假公佈停止上班，則不用上課 遠距離學習方式 上課工具 zoom 會議號：303 538 7511 密碼：4257387 無帳號也可線上加入會議 名稱需寫本名 TibaMe 可在此回顧課程影片(如沒影片可提醒老師，當日錄影約隔日上傳成功) 提供三本教科書，還有講義與電子檔 學校公約 非吸菸區外全校禁菸 便當廚餘拿到一樓分類 上課不準帶小型電器 垃圾拿到 1 樓丟 結訓候補助 課程結束後有 勞保 就可以申請補助 "},"1.雲端應用/1-1.雲端應用與介紹.html":{"url":"1.雲端應用/1-1.雲端應用與介紹.html","title":"1-1.雲端應用與介紹","keywords":"","body":"目錄 1. 老師與課程介紹 2. 雲端應用的優缺點 3. 常見網路技術 4. MVC 架構 5. 好用工具推薦 1. 老師與課程介紹 課程名稱: 雲端應用 老師名稱: 傅俊皓(稱呼學長就好) 老師信箱: aa107g407@gmail.com 有跨領域之類的疑問，可以跟學長們討論學習心得。每周 1-2 天出現在班級上可詢問，可到學長姐班級找學長。學長們會輪班，所以不一定會一直看見同一個 2. 雲端應用的優缺點 優: 跨平臺、全球化操作、即時同步 缺: 瀏覽器支援技術差異、硬體資源使用低、無法離線使用 學習時仍會練習如何支援 IE 瀏覽器 平常可多看看其他人後端服務都做哪些 QRCode 掃碼確認 掃碼支付等等 3. 常見網路技術 JAVA EE + Oracle + Html-CSS-JavaScript C# + MSSQL + Html-CSS-JavaScript PHP + MySQL + Html-CSS-JavaScript 4. MVC 架構 M 資料庫 V 前端回響 C 後端邏輯 5. 好用工具推薦 GOOGLE 插件 keep (線上便簽) OneNote (微軟線上筆記) hackmd (markdown 記事工具，可貼代碼) 工作中常用 專案提問 stackoverflow (專案社區，可以提問) Github (代碼庫，可以保存代碼並看其他人的解決方案) 可學習 git 推送，雲端保存資料 唐鳳的 github 可以多學習 問題搜尋方式 java string stackoverflow js float mdn E102 班級手冊 https://reurl.cc/V6DARQ "},"2.Html/1.初階學習.html":{"url":"2.Html/1.初階學習.html","title":"1.初階學習","keywords":"","body":" 額，原來 HTML Anchor 已經變成要用 id 不能用 name 了啊 HTML 中显示特殊字符,如尖括号 “\" "},"2.Html/2.表格的變化-含合併欄位的表格.html":{"url":"2.Html/2.表格的變化-含合併欄位的表格.html","title":"2.表格的變化-含合併欄位的表格","keywords":"","body":"目錄 1. 表格的變化-含合併欄位的表格 2. 作法 1. 表格的變化-含合併欄位的表格 排版還是用 div 比較好的 一般用在後台表格化的排版 2. 作法 Document 平地原住民 山地原住民 男 女 男 女 100 200 300 400 平地原住民 男 100 女 200 山地原住民 男 300 女 400 類別 就業人口 未就業人口 合計 平地原住民 山地原住民 平地原住民 山地原住民 男 40歲以下 100 150 110 160 520 40歲以上 200 250 210 260 920 女 40歲以下 300 350 310 360 1320 40歲以上 400 450 410 460 1720 合計 1000 1200 1040 1240 4480 參考鏈接: table mdn "},"2.Html/3.播放視訊與音訊檔.html":{"url":"2.Html/3.播放視訊與音訊檔.html","title":"3.播放視訊與音訊檔","keywords":"","body":"目錄 1. 播放視訊與音訊檔 2. 方法撰寫 1. 播放視訊與音訊檔 video 影片撥放 embed 大多數不支持 audio 音源撥放 2. 方法撰寫 視訊 (可設定不支援視訊時的提示字) 播放視訊檔 Your Browser ... 音訊 播放音訊檔 "},"2.Html/4.form標籤.html":{"url":"2.Html/4.form標籤.html","title":"4.form 標籤","keywords":"","body":"目錄 1. 表單的使用與發送 2. input 的使用 3. Button 標籤 4. textarea 標籤 5. select 標籤 6. fieldest 標籤、legend 標籤 7. label 標籤 1. 表單的使用與發送 主要是讓使用者在客戶端的瀏覽器中輸入資料，以提交資料給伺服器端的程式使用 action 伺服器端連結 method 提交方式 get/post enctype 數據編碼 提交方式 get 資料會在網頁鏈接上出現，資料不安全性較高(明碼、量有限、放到 cache 區) memAdd.jsp?account=123&psw=123&sex=123 post 較安全，可傳送較多的資料(具體依照 server 規定)，部會放到 cache 區 memAdd.jsp 具體作法 Document 申請加入會員 帳號 密碼 性別 確定加入 2. input 的使用 標籤說明 required=\"required\" 或 required ，設定必填 name 給後端使用 id 給前端使用 輸入框種類 type = \"text\" 輸入文字 ，value 設定初始值 type = \"password\" 輸入密碼 ，value 設定初始值 type = \"radio\" 單選框，name 設置需相同(才能用擇一的方式)，可加 checked 設定預設勾選 ，value 設定回傳值 type = \"checkbox\" 多選框，name 設置需相同，可加 checked 設定預設勾選 ，value 設定回傳值 type = \"submit\" 送出鈕，用於發送表單資料 ，value 設定按鈕上的文字 type = \"reset\" 重設鈕，用於重置表單至初始狀態 ，value 設定按鈕上的文字 type = \"button\" 一般按鈕，用來設定一般按鈕會配合 javascript 使用 ，value 設定按鈕上的文字 3. Button 標籤 標籤說明 (button 中可遷入圖片或其他信息) 確認下單 4. textarea 標籤 標籤說明 (多行文字輸入) 預設文字 wrap=\"off\" 關掉自動換行功能 5. select 標籤 標籤說明 (下拉選單) 選項名稱 multiple 多選 Ctrl + size = 6 設定一次顯示六行 6. fieldest 標籤、legend 標籤 將相關資料框起來，以增加資訊的閱讀性 性別 男 女 7. label 標籤 方便操作者點案介面上的輸入欄位 label 設定後，可選到指定欄位(使點擊區域更大更好用) 使用方法 1: 直接添加 label 男 女 使用方法 2: 設定 id 使 label 點擊後可選種指定位置 性別 男 女 "},"2.Html/5.HTML5.html":{"url":"2.Html/5.HTML5.html","title":"5.HTML5","keywords":"","body":"目錄 1. HTML5 2. input 新增 3. datalist 標籤 4. HTML5 新增的標籤 5. nav 標籤 6. eta 標籤 1. HTML5 新的屬性: placeholder,... 新的標籤: section,audio,canvas,... (強烈有結構性，語意化) 2. input 新增 3. datalist 標籤 讓文字輸入盒使用預先設置好的標籤 使用 input 配合 datalist 與 select 差別為，選項內沒有的值可以在 input 中自行填寫 課程名稱 網頁基礎 網頁美化 互動機制 4. HTML5 新增的標籤 相當於比 div 更語意化的標籤 article section header footer nav meter progress ... 5. nav 標籤 設定導覽列 HTML CSS JAVASCRIPT 6. eta 標籤 提供訊息給瀏覽器、搜尋引擎等。一率放在 header 中 設定網頁編碼 設定網頁關鍵字(SEO 主要搜尋地方) 設定網頁相關描述(主要適用於網頁上的簡短描述，若要優化 SEO 也要對此區塊作處理) "},"2.Html/6.CSS.html":{"url":"2.Html/6.CSS.html","title":"6.CSS","keywords":"","body":"目錄 1. CSS 2. 樣式選擇器的寫法 3. 樣式撰寫的位置 1. CSS 語法 選擇器 { 屬性1: 值1; 屬性2: 值2; ...; } pre { color: blue; font-style: italic; } 2. 樣式選擇器的寫法 標籤名稱 a { color: pink; } 標題 標題連結 描述 描述 標籤名稱 . 類別名稱 a.active { color: pink; } 標題 標題連結 描述 描述 . 類別名稱 .active { color: pink; } 標題 標題連結 描述 描述 # ID 名稱 #active { color: pink; } 標題 標題連結 描述 描述 後代選擇器 h1 a { color: pink; } 標題 標題連結 描述 描述 子代選擇器 h1 > a { color: pink; } 標題 標題連結 描述 描述 相鄰選擇器 h1 + a { color: pink; } 標題 描述 描述 虛擬選擇器 /* 設定虛擬選擇器的樣式(pseudo class selector) */ /* 超連結 */ a:link { color: yellow; } /* 已拜訪過的超連結 */ a:visited { color: green; } /* 停駐在超連結上 */ a:hover { color: blue; font-size: 30px; } /* 作用中的超連結 */ a:active { color: red; } 3. 樣式撰寫的位置 撰寫在標籤中 連結 撰寫在 head 段落中 a { color: pink; } 連結 定義在外部檔案 使用定義在外部檔案中的樣式檔(css 文件也可使用 @import 引入外部樣式，但可能會有速度差) /* Import 進來 css 檔案 */ @import url('style.css'); 定義頁簽 icon 參考鏈接: @import 了解 CSS 中的@import 從這四點了解 css 的 link 和@import 使用和區別，以後別再亂用了！ 不要使用@import "},"2.Html/7.HTML課後練習.html":{"url":"2.Html/7.HTML課後練習.html","title":"7.HTML 課後練習","keywords":"","body":"目錄 表單 實戰練習 表單 表格練習 實戰練習 Form練習 * { font-family: 微軟正黑體, 微軟雅黑; } h1 { text-align: center; } .col-2 { width: 20%; } .present-5 { width: 5%; } input { min-width: 30%; } label { display: flex; } form { width: 650px; margin: auto; } form > div { display: flex; width: 100%; } form > div > div { box-shadow: 2px 4px 4px #e2e2e2; margin-right: 10px; margin-bottom: 10px; border-radius: 5px; padding: 10px; } form > div > div:nth-child(1) { width: 20%; } form > div > div:nth-child(2) { display: flex; text-align: center; width: 80%; margin-right: 0; } form > div > div:nth-child(2) div { margin-right: 10px; display: flex; } form > div > div:nth-child(2) div input { width: 100%; } form > div > div:nth-child(2) div input[type='checkbox'] { width: 15px; } form > div.form-footer div { margin-top: 20px; text-align: center; width: 10%; color: #ddd; border: 1px solid rgba(0, 0, 0, 0); padding: 6px 15px; transition: 0.3s; margin: 20px auto; } form > div.form-footer div:hover { color: black; border: 1px solid black; } 報名資料 *性名: 民國 年 月 日 *生日: *身分證字號: *地址: 郵遞區號 家中電話: - (電話至少填一項) 行動電話: 公司電話: - 分機 傳真: - *Email: *密碼: *確認密碼: *學歷: 博士 碩士 學士 *消息來源: MAS聊天 YAHOO廣告 GOOGLE廣告 送出 "},"3.JAVA/01.JAVA基礎學習/01.JAVA導論/1-1.JAVA開課介紹與起源.html":{"url":"3.JAVA/01.JAVA基礎學習/01.JAVA導論/1-1.JAVA開課介紹與起源.html","title":"1-1.JAVA 開課介紹與起源","keywords":"","body":"目錄 1. JAVA 開課介紹 2. JAVA 白皮書與專業術語 3. JAVA 技術源起 4. JAVA 程式語言的關鍵概念 5. JAVA 執行環境 6. Write once,run anywhere 7. JAVA 技術種類 8. JAVA 小知識 1. JAVA 開課介紹 每五個章節結束後會有第一次小考， Section 1 Module 1-5 五個章節 基礎、資料類型、流程控制 Section 2 Module 6-13 物件導向 Section 3 Module 2-1~2-5 JAVA API 多執行續 2. JAVA 白皮書與專業術語 由 Oka 項目改造 1995 年 5 月改造完成並釋出 JAVA 1995 年 5 月 23 正式改名 JAVA 在改名後發表 JDK1.0a2 版 3. JAVA 技術源起 Java 白皮書 Java 的 11 個專業術語 Simple 簡單 Object-Oriented 物件導向 Network-Savvy 具備網路功能的 Robust 穩固 Secure 安全 Architecture Neutral 結構中立(跨平台) Portable 可攜帶的(可攜的代碼) Interpreted 直譯 High-Performance 高效能 Multithreading 多執行續 Dynamuc 動態 4. JAVA 程式語言的關鍵概念 Simple 簡單 不允許使用者使用指標(pointer) 只允許程式設計者使用物件參考(Object refence)，並提供回收機制 JAVA 提供布林(boolean)可用 true 或 false，不像舊的語言只有 1 與 0(閱讀性佳) Object-Oriented 物件導向 程序性程式語言(PprocedurAL Programming) 著重程式撰寫的先後次序 (缺點: 功能間的相關性太嚴重) 物件導向程式語言 (Object-Oriented Programming,OOP) 注重物件之間可以相互作用的關係解決問題 Distributed 分散式運算 Java 是一種分散式程式語言，支援多種分散式網路技術 RMI(Remote Method Invocation) CORBA (Common Object RequestBroker Architecture) URL (Universal Resource Locator) 另外如 Applet，可動態仔入功能並允許部分程式碼由網路下載 但現在已棄用 Multitjreading 多執行續 可以在同個時間執行多個程序(Multi-processor) 意思是可以有效率的寫程式 Secure 安全性 禁止使用指標(pointer)操控記憶體 驗證所有 Java 程式是否擁有合法的程式碼 支持數位簽章(Digital Signatures) JAVA 技術的程式碼可以由公司具有的數位簽章或個人所擁有的數位簽章來簽屬 Platform-independent 跨平台 使用 JAVA 編輯器(JAVA Compiler)，將 Java 程式碼譯成與平台無關的位元碼(byte code) 位元碼(byte code)透過各系統專有的 Java 虛擬機器(JVM，Java Virtual Machine) 上的硬體去執行 *.java 編譯後產生 *.class ，並使用 JVM 直譯 給各系統 java 既使用編譯，也直譯至各系統。 JVM 目前已有多種平台版本，因此可在同 cpu 或系統環境上執行，JVM 即是能跨平台的主要原因 5. JAVA 執行環境 JAVA 程式的執行環境 一個 java 只要一個 JAVA 虛擬機器(JVM)執行 也需要一套針對此平台所設計的標準 JAVA 類別含式庫(Java Class Libraries) JVM 與 JAVA 類別函式庫被稱為 JAVA 執行環境(JAVA Runtime Environment，JRE) 6. Write once,run anywhere 開發時已在常見的系統都提供了 JAVA 執行環境，故不需考慮硬體平台問題 7. JAVA 技術種類 Java Stander Edition (Java SE) 標準版 (熟悉認識 java) 適用於開發用戶端程式 JavaEnterprise Edition (JAVA EE) 企業版 (工作使用) 適用於開發伺服器端程式 Java Micro Edition (Java ME) 手持裝置版 (已經逐漸不用了) 適用於開發手機、無線設備等程式 自 JAVA6 後取消 J2SE、J2EE 用法，現在經常稱為 SE7 8. JAVA 小知識 JAVA5 叫 Tiger JAVA6 叫 螳螂 JAVA7 叫 海豚 "},"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-1.JAVA開發環境建立.html":{"url":"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-1.JAVA開發環境建立.html","title":"2-1.JAVA 開發環境建立","keywords":"","body":"目錄 1. JAVA 開發環境建立 2. 總結 1. JAVA 開發環境建立 下载 jdk JDK 下載 JRE 已包含在 JDK 中(一般家庭使用，只是有某個工具要用的話安裝 JRE 就好) 安装 jdk 安装目录勿有空白，安装时 JRE 路径不需修改 设定环境变数 我的電腦 > 右鍵 > 內容 > 進階 > 環境變數 > 系統變數 JAVA_HOME : C:/jdk1.8.0_201 Path : %JAVA_HOME%\\bin classpath : .; 确认设定完成 設定好環境變數後按確認，當窗口自動關閉後才式設定完成 在 cmd 窗口中輸入 javac 並 Enter，順利執行則安裝完成 2. 總結 JRE 與 JDK 差別為何? JDK 即開發者使用 JRE 則是一般用戶專用 如何替換新 JDK? JAVA_HOME 路徑修改即可 "},"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-2.TXT撰寫第一隻JAVA.html":{"url":"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-2.TXT撰寫第一隻JAVA.html","title":"2-2.TXT 撰寫第一隻 JAVA","keywords":"","body":"目錄 1. 第一支 JAVA 程式 2. 總結 1. 第一支 JAVA 程式 創建/編輯 HlloWord.java public class HlloWord{ public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 編譯並執行 HlloWord.java cd C:\\EA102_Workspace javac HelloWord.java java HelloWord 執行結果 Hello World! 2. 總結 JAVA 文件名 與 Class 名 需相同 一定要用 ; 作為一句話的結束 記得縮排 (方便閱讀與程式排版) public class HlloWord{...} 中 {} 稱為 blok (區塊，在程式內表示範圍) 錯誤: 找不到或無法載入主要類別 HelloWord.class 編譯時不要使用 HelloWord.class 要使用 class 名稱 HelloWord ， 否則會出錯 "},"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-3.Eclipse各種操作.html":{"url":"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-3.Eclipse各種操作.html","title":"2-3.Eclipse 各種操作","keywords":"","body":"目錄 1. Eclipse 安裝 2. Eclipse 修改所有文件預設編碼為 UTF-8 3. Eclipse 導入壓縮項目 4. Eclipse 導入的驚嘆號(！)問題 5. Eclipse 導入後文件錯誤(X)問題 6. Eclipse 快捷 7. Eclipse 改變字體大小 8. Eclipse 中 package 錯誤 9. Eclipse 除錯(Debug)功能 10. Eclipse Outline 功能 11. Eclipse 還原測試視窗 12. Eclipse 保存代碼時自動格式化 13. Eclipse 無法正常導入項目 14. Eclipse 創建介面(Interface)檔 15. Eclipse 匯出(Export) jar 16. Eclipse 引入類別函式庫(第三方或自己的) 17. Eclipse 移除引入的類別函式庫 18. Eclipse 生成 hashCode()與 equals() 19. 注意 1. Eclipse 安裝 Eclipse 下載企業版(Eclipse IDE for Enterprise Java Developers) 執行後的 Workspace(工作區) 選擇自己的項目資料夾 2. Eclipse 修改所有文件預設編碼為 UTF-8 Window > Perferences > General > Workspace > Text file encoding > Other > UTF-8 3. Eclipse 導入壓縮項目 File > Import > Existing Projects into Workspace Select archive file 選擇需導入的項目 > 點選 Finish 4. Eclipse 導入的驚嘆號(！)問題 因為項目中無此 jar 包，故需更改 解決辦法 Build Path > Configure Build Path > Libraries 標籤 雙擊出現 x 符號的 JRE System Library[Java SE...](JAR 包) Alternate JRE > Finish JAR路徑錯誤 解決辦法 修改 JAR 路徑位置 開啟目錄 套件複製至新位置 Build Path > Configure Build Path > Libraries 標籤 > 雙擊出現 x 符號的項目 > 選擇自訂的 Library 位置 選擇 localhost 資料庫版本 改完結果 5. Eclipse 導入後文件錯誤(X)問題 問題原因 文字編碼不同，會導緻文字亂碼 解決方法 照著 Eclipse 修改所有文件預設編碼為 UTF-8步驟操作即可 6. Eclipse 快捷 一次註解 Ctrl + / 7. Eclipse 改變字體大小 Window > Perferences > General > Apperance > Colors and Fonts > Java > Java Editor Text Font > Change 8. Eclipse 中 package 錯誤 假設複製文件到新的 package 時應該注意 package xxx; 需要跟當下 package name 相同，否則會有錯誤産生 9. Eclipse 除錯(Debug)功能 設定中斷點 Ctrl + Shift + B 執行 Debug F11 跳至下一行 F6 Debug TestWhile > switch > Step Over(F6) 跳至下個中斷點 F5 Debug TestWhile > switch > Step Into(F5) 關閉測試 Ctrl + F2 Run > Terminate(Ctrl + F2) variables 視窗中 name 左方 L 字樣的小 icon 錶示區域變數 10. Eclipse Outline 功能 可用 Outline 方式跳到資料再程式碼中的執行位置(類似錨點) 11. Eclipse 還原測試視窗 Window > Perspective > Reset Perspective... 12. Eclipse 保存代碼時自動格式化 windows > Preferences > Java > Editor > Save Actions 勾選 Perform the selected actions on save 13. Eclipse 無法正常導入項目 錯誤提示 Some projects cannot be imported because they already exist in the workspace； 問題原因 workspace 中已經存在相同名稱的項目，所以不能導入 項目資料已刪，但資料夾未在 workspace 中刪除 解決方法 方法 1: 找到設定 workspace 項目時的地點，將該資料夾移除 方法 2: 修改項目名：右擊 refactor > rename 或 F2 方法 3: 打開項目中 .project 文件 > 修改 projectName 14. Eclipse 創建介面(Interface)檔 15. Eclipse 匯出(Export) jar file (或在 Package Explore 區域右鍵) > Export > JAR file 可指定選擇要製成 jar 的項目 ok 匯出成功 16. Eclipse 引入類別函式庫(第三方或自己的) 創建自訂函式庫存放位置 開啟引入介面 選擇要引入的函式庫 成功引入 17. Eclipse 移除引入的類別函式庫 Build Path > Configure Build Path... 選擇需移除的函式庫 > Remove > 移除成功 18. Eclipse 生成 hashCode()與 equals() Alt + Shift + S > Generate hashCode() and equals()... 19. 注意 JDK 的位元(32 位)，需和 Eclipse 相同否則會報錯 參考鏈接: Eclipse 修改所有文件預設編碼為 UTF-8 Eclipse 導入壓縮項目 Eclipse 出現大紅感歎號問題 Eclipse 中斷點測試 Eclipse 保存代码时自动格式化 Eclipse 導入項目提示已存在（Some projects cannot be imported because they already exist in the workspace) "},"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-4.JAVA基本形式.html":{"url":"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-4.JAVA基本形式.html","title":"2-4.JAVA 基本形式","keywords":"","body":"目錄 1. JAVA 程式基本形式 2. 章節分布 3. 結論 1. JAVA 程式基本形式 基本的 Java 類別架構 所有 java 程式碼都一定式位於某個類別裡面 public class HlloWord{ public static void main(String[] args) { System.out.println(\"Hello World!\"); } } * class { * * * } 存取修飾詞 class class名{ 屬性宣告 建構子(式)宣告 方法宣告 } 類別宣告 * class {...} public class HlloWord {...} 方法宣告 修飾子: public static 傳回值型態: void 方法名: main 可接受 0~多個字串作為參數從 (String[] args) 傳入，String[] 是一種陣列 * () {...} public static void main(String[] args) {...} 2. 章節分布 *: Ch9 說明 *:Ch07 說明 *: Ch09 說明 *: Ch06 說明 3. 結論 * 中 * 意思是指不一定要有 一個類別成員分為變數變數與方法兩種成員 "},"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-5.創建Eclipse項目.html":{"url":"3.JAVA/01.JAVA基礎學習/02.JAVA開發環境建立/2-5.創建Eclipse項目.html","title":"2-5.創建 Eclipse 項目","keywords":"","body":"目錄 1. 寫個 HelloWord 2. 修改檔名方法 3. Eclipse 自動產生方法的功能 4. 注意 1. 寫個 HelloWord 第一次開 Eclipse (可自定工作區) File > Switch Workspace 創建項目 第一次創建項目 File > New > Other > Java > java Project > name 第二次創建項目 File > New > java Project > name 創建 package src > new > package 創建 java 檔案 package > class > name 創建檔案內容 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"hello world\"); } } 執行並展示成果 Ctrl + F11 hello world 2. 修改檔名方法 方法 1: 選中文件 > refactor > rename 方法 2: 選中文件 > F2 > 輸入新文件名 方法 3: 選中文件 > ALT+SHIFT+R > 輸入新文件名 3. Eclipse 自動產生方法的功能 在已經寫好的方法基本概念.html>)(ex.speak，只要打好這樣就可)上使用 Alt + / @Override // JDK5時加入的功能(Annotation 標註) public void speak() { // TODO Auto-generated method stub super.speak(); } 4. 注意 設定 Workspace 後以後項目都在該位置保存 修改檔名時會自動修改 class 名稱 參考鏈接: eclipse 中如何修改类名及文件名 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-01.JAVA變量.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-01.JAVA變量.html","title":"3-01.JAVA 變量","keywords":"","body":"目錄 1. JAVA 定數(Literal) 2. 什麼是變數 3. 變數命名規則 4. JAVA 常數 5. 注意 1. JAVA 定數(Literal) 基本資料型態 整數型別(Data type) byte short int 預設整數資料型別 long 浮點數型別 float double 預設浮點數資料型別 布林值型別 boolean 字元型別(用來表示一個 Unicode 字元) char 其他資料型態 字串型別 String 2. 什麼是變數 讓我們在程式設計時，可以將資料暫存的機制 變數代表記憶體中某個記憶體位置 3. 變數命名規則 命名用法 可用 A-Z , a-z , 0-9 , _ , $ 命名 變數區分大小寫(case-sensitive) 命名注意 第一個字不可以是數字 不能重複建立 不能是關鍵字或保留字 命名潛規則 大駝峰法 (MyName) 用於 class 名與檔案名 小駝峰法 (myName) 用於 method 名與變數名 4. JAVA 常數 常數(Constant): 常用到且不變的數 通常全大寫，且用底線來分開字組(MY_NAME) 常數宣告方式 final int MY_AGE = 10; ，前方加上 final 資料就不可異動 5. 注意 JAVA7 後，10,000 在 java 中可以用 10_000 表示 根據整數程度大小(記憶體使用大小)，提供四種整數資料型別 浮點數可用科學記號表示法，也因為浮點數預設是 double，故 float 在使用上時需在後方加上 f (例: 1.0f) 才可正常使用(位數太多時會自動轉為科學記號) \\u 表示 unicode 用數字表示 bit(位元): 電腦最小的儲存單位 1byte = 8bits 1KB = 1024 bytes 1MB = 1024KBs 1GB = 1024MBs 參考鏈接: Eclips 快捷 大驼峰命名法和小驼峰命名法 驼峰式命名法(CamelCase) "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-02.變數種類與有效範圍.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-02.變數種類與有效範圍.html","title":"3-02.變數種類與有效範圍","keywords":"","body":"目錄 1. 變數種類與有效範圍 1. 變數種類與有效範圍 區域變數(方法變數/自動變數) 方法(method)中的變量都叫區域變數 相同資料型別才能一次宣告多個 區域變數只能在自己所屬範圍內直接使用 區域變數的生命跟著所屬的範圍執行時存在，該範圍執行完畢即消失 須設定值才能使用(域變數可以宣告後在設定初始值)，JAVA 不會給予預設值 功能性: 即可拋 public class TestArithmeticOP { public static void main(String[] args) { int i,j,k,l; // 一次宣告多個 show(); // 結果: 2 System.out.println(\"-----------------\"); show(); // 執行即消失，故: 2 } public static void show() { int i=1; i++; System.out.println(i); } } 2 ----------------- 2 實體變數(屬性變數，成員變數)，需透過物件參考變數進行操作 實體變數在宣告時，JAVA 會自動給予初始值(boolean 初始值是 false) 實體變數的初始值需宣告後自訂初始值 可以在同個類別(class)中，不同的方法內直接使用(注意: 該方法不可以出現 static 關鍵字) 功能性: 覆用 只要物件未消滅皆可存取(怎樣表示物件消滅?) public class Pen { // 實體變數(屬性變數，成員變數)，需透過物件參考變數進行操作 String brand; double price = 10.0; int i1; // 方法成員，需透過物件參考變數進行呼叫 public void showInfo() { System.out.println(++i1); } } public class PenTest { public static void main(String[] args) { Pen myPen = new Pen(); myPen.showInfo(); // 1 myPen.showInfo(); // 2 } } 1 2 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-03.JAVA常數與命名方式.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-03.JAVA常數與命名方式.html","title":"3-03.JAVA 常數與命名方式","keywords":"","body":"目錄 1. JAVA 常數與命名方式 1. JAVA 常數與命名方式 命名方式 通常全大寫 習慣用 _ 隔開 宣告前使用 final ， final int NUM = 10; 參考鏈接 告别编码 5 分钟，命名 2 小时！史上最全的 Java 命名规范参考！ "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-04.算術運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-04.算術運算子.html","title":"3-04.算術運算子","keywords":"","body":"目錄 1. 算術運算子 2. 注意 1. 算術運算子 + 加法，也可用於兩種文字合併 System.out.println(\"A\"+\"B\"); > AB - 減法 * 乘法 / 除法，10 / 3 > 3.333... % 被稱作 mob 取餘數，10 % 9 > 1 2. 注意 double 跟 int 型別做運算，因為 double 型別較大故會變成小數 int num1 = 5, num2 = 2; double numD = 2.0; System.out.println(num1 * num2 + numD); 12.0 避免發生溢位(overflow) byte、short 運算的話會自動提升至 int byte i = 3; byte j = 120; byte sum1 = i + j; // 錯誤: 這會出現error int sum2 = i + j; // 正確: java自動轉至int double sum3 = i+j; // 正確: 也可用更高型別的保存 整數以上系統型別就不會提示錯誤，要自己解決溢位問題 参考链接: 2038 年問題 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-05.遞增遞減運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-05.遞增遞減運算子.html","title":"3-05.遞增遞減運算子","keywords":"","body":"目錄 1. 遞增遞減運算 2. 實際用例 1. 遞增遞減運算 一元運算子 a++ a-- ++a = a = a + 1 = a += 1 --a = a = a - 1 = a -= 1 2. 實際用例 public class TestInDecrementOP { public static void main(String[] args) { int num1 = 3, num2 = 4; System.out.println(num1++); // 3 System.out.println(++num1); // 1+3+1 = 5 System.out.println(--num2); // 4 - 1 = 3 System.out.println(num2--); // 3 System.out.println(num1); // 5 System.out.println(num2); // 3 - 1 = 2 } } "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-06.指定運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-06.指定運算子.html","title":"3-06.指定運算子","keywords":"","body":"目錄 1. 指定運算子 2. 實際用例 1. 指定運算子 = = a=2 = a=2 += = a+=2 = a=a+2 -= = a-=2 = a=a-2 *= = a*=2 = a=a*2 /= = a/=2 = a=a/2 % = = a%=2 = a=a%2 2. 實際用例 public class TestAssignOP { public static void main(String[] args) { int num = 1; num += 2; String s = \"1\"; s += 2; System.out.println(num); // 3 System.out.println(s); // 12 } } "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-07.關係運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-07.關係運算子.html","title":"3-07.關係運算子","keywords":"","body":"目錄 1. 關係運算子 2. 實際用例 3. 總結 1. 關係運算子 = 小於 = 小於等於 == = 等於等於 != = 不等於 >= = 大於等於 > = 大於 2. 實際用例 public class TestRelationalOP { public static void main(String[] args) { int num1 = 5, num2 = 3; System.out.println(num1 = num2); System.out.println(num1 > num2); } } 3. 總結 主要在 if、else 等判斷中使用 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-08.條件運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-08.條件運算子.html","title":"3-08.條件運算子","keywords":"","body":"目錄 1. 條件運算子 2. 實際用例 3. 注意 1. 條件運算子 && = AND(且) = a && b = 條件同時符合 || = OR(或) = a || b = 符合一個條件 ! = NOT(否) = !a = 反轉此值 2. 實際用例 public class TestConditionOP { public static void main(String[] args) { int num1 = 3, num2 = 4; // false && true = false System.out.println(num1 > num2 && num1 != num2); // false && false = false System.out.println(num1 > num2 && num1 == num2); // false || true = true System.out.println(num1 > num2 || num1 != num2); // !false = true System.out.println(!(num1 > num2)); // false System.out.println(!true); } } 3. 注意 && 這種方法又稱為短路運算(shORt-circuit) 短路 AND(&&) 、 OR(||) 執行效率高 當條件前面條件已經足夠成立邏輯運算就不會繼續執行 非短路 AND(&) 、 OR(|) 執行效率低 當條件前面條件已經足夠成立邏輯運算還是會繼續執行 && 與 & 差異 && 效能較好 & 會全部判斷 參考鏈接: Java 运算符 邏輯運算元(短路與非短路) "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-09.位元運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-09.位元運算子.html","title":"3-09.位元運算子","keywords":"","body":"目錄 1. 位元運算子 1. 位元運算子 AND(&) ， 都為 1 才 1 0 0 1 0 1 1 0 1 & 0 1 0 0 1 1 1 1 = 0 0 0 1 1 0 1 OR(|) ， 一個是 1 就是 1 0 0 1 0 1 1 0 1 & 0 1 0 0 1 1 1 1 = 0 1 1 1 1 1 1 XOR(^) ， 一個 1 一個 0 才是 1 0 0 1 0 1 1 0 1 & 0 1 0 0 1 1 1 1 = 0 1 1 0 0 1 0 ~ 反轉 ~ 0 0 1 0 1 1 0 1 = 1 1 0 1 0 0 1 0 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-10.移位運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-10.移位運算子.html","title":"3-10.移位運算子","keywords":"","body":"目錄 1. 移位運算子 1. 移位運算子 : 左移运算符，num >> : 右移运算符，num >> 1,相当于 num 除以 2 >>> : 无符号右移，忽略符号位，空位都以 0 补齐 参考链接: java 中的移位运算符：>,>>>总结 "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-11.三元運算子.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-11.三元運算子.html","title":"3-11.三元運算子","keywords":"","body":"目錄 1. 三元運算子 1. 三元運算子 使用單行就可做出簡易判斷，是個簡略的 if else 判斷 (條件判斷) ? 正確結果 : 錯誤結果 ; public class TestTernaryOP { public static void main(String[] args) { int income = 10000, outcome = 12000; System.out.println((income > outcome) ? \"有積蓄\" : \"入不敷出\"); } } "},"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-12.晉升與型別轉換.html":{"url":"3.JAVA/01.JAVA基礎學習/03.定數、變數、常數與運算子/3-12.晉升與型別轉換.html","title":"3-12.晉升與型別轉換","keywords":"","body":"目錄 1. 晉升與型別轉換 1. 晉升與型別轉換 晉升 小型別(等號左邊)會自動晉升為大型別(等號右邊) 型別轉換 較大資料轉為較少資料，需使用強制轉換 型別轉換用法 (target type) value public class TestCast { public static void main(String[] args) { int i = 1; double d = 11.1; int sum2 = (int)(i + d); // (target type) value System.out.println(sum2); // 輸出: 12 System.out.println(char)25105); // 我 System.out.println((int)'我'); // 25015 } } 参考链接: Java 中 int 转 String 和 String 转 int 各方法效率对比 java 中单引号和双引号有什么区别？ "},"3.JAVA/01.JAVA基礎學習/04.流程控制/4-1.if...else.html":{"url":"3.JAVA/01.JAVA基礎學習/04.流程控制/4-1.if...else.html","title":"4-1.if...else","keywords":"","body":"目錄 1. 選擇性敘述 2. 實際用例 1. 選擇性敘述 單向選擇 if(條件判斷) { 敘述1; ... } 雙向選擇 if(條件判斷) { 敘述1; ... } else { 敘述2; ... } 多重選擇 if(條件判斷) { 敘述1; ... } else if(條件判斷){ 敘述2; ... } else if(條件判斷){ 敘述3; ... } else { 敘述4; ... } 2. 實際用例 public class TestIfElse1 { public static void main(String[] args) { int a = 10; if (a == 10) { //因為條件成立，故會執行 System.out.println(\"a 的值是 10\"); } if (a == 20) { System.out.println(\"a 的值是 20\"); } else { //因為條件成立，故會執行 System.out.println(\"a 的值不是 20\"); } if (a == 20) { System.out.println(\"a 的值是 20\"); } else if (a == 30) { System.out.println(\"a 的值是 30\"); } else { //因為條件成立，故會執行 System.out.println(\"a 的值不是 20 也不是 30\"); } } } 省略用法 public class TestIfElse1 { public static void main(String[] args) { int a = 20; // 因為單行 所以這樣這樣做 if (a == 10) System.out.println(\"a 的值是 10\"); // 因為沒括號 所以只套用一行結果 if (a == 10) System.out.println(\"a 的值是 10\"); System.out.println(\"a 的值還是 10 嗎?\"); } } 因為沒括號就只會執行一行結果，所以 \"a 的值還是 10 嗎?\" 不算在條件判斷中，故最終只有這段真的運行出來 a 的值還是 10 嗎? "},"3.JAVA/01.JAVA基礎學習/04.流程控制/4-2.課堂練習.html":{"url":"3.JAVA/01.JAVA基礎學習/04.流程控制/4-2.課堂練習.html","title":"4-2.課堂練習","keywords":"","body":"目錄 1. 題目 2. 作法 1. 題目 建立一個 TestBMI.java，並計算自己的 BMI BMI 公式: 體重(kg)/身高平方(m) BMI=24 為過胖 運算子+if-else 判斷 2. 作法 一般做法 import java.text.DecimalFormat; public class TestBMI { public static void main(String[] args) { double height = 1.55; double killgrem = 52; double BMI = killgrem/(height*height); if(BMI>=24) { System.out.println(\"過胖\"); } else if(BMI 優化方式 1 import java.text.DecimalFormat; // 引入功能 public class TestBMI { public static void main(String[] args) { double height = 1.55; double killgrem = 52; double BMI = killgrem/Math.pow(height, 2); String say = \"\"; DecimalFormat df = new DecimalFormat(\"######0.00\"); // 格式化方法 if(BMI>=24) say = \"過胖\"; else if(BMI 優化方式 2 public class TestBMI { public static void main(String[] args) { double height = 1.55; double killgrem = 52; double BMI = killgrem/Math.pow(height, 2); String say = \"\"; if(BMI>=24) say = \"過胖\"; else if(BMI 参考链接: 使用 Java 將 double 變數四捨五入到小數點後第二位 Java 開根號與平方 java 保留兩位小數 Java 中 printf()的用法 "},"3.JAVA/01.JAVA基礎學習/04.流程控制/4-3.巢狀結構.html":{"url":"3.JAVA/01.JAVA基礎學習/04.流程控制/4-3.巢狀結構.html","title":"4-3.巢狀結構","keywords":"","body":"目錄 1. 巢狀(Nested)結構說明 2. 實際用例 1. 巢狀(Nested)結構說明 較複雜的判斷情況可使用巢狀嵌套 if(...){ ... if(...){ ... }else { ... } }else{ ... } 2. 實際用例 public class TestIfElse2 { public static void main(String[] args) { int age = 29; String sex = \"女\"; // \"男\" if (age "},"3.JAVA/01.JAVA基礎學習/04.流程控制/4-4.switch.html":{"url":"3.JAVA/01.JAVA基礎學習/04.流程控制/4-4.switch.html","title":"4-4.switch","keywords":"","body":"目錄 1. switch case 2. 實際用例 3. 總結 1. switch case switch (n) {...} 只可為整數(int)、字元(char)，不可為浮點數。 JDK7 後可以比對字串(String) 若省略 break(中斷) 敘述，則會繼續執行下一個 case 中的敘述 switch(n){ case 1: 敘述1; break; case 2: 敘述2; break; case 3 敘述3; break; default: 敘述4; break; // 可加 break 也可省略 } 2. 實際用例 public class TestSwitchCase { public static void main(String[] args) { int n = 30; switch (n) { case 10: System.out.println(\"n 的值是 10\"); break; case 20: System.out.println(\"n 的值是 20\"); break; default: System.out.println(\"n 的值不是 10 也不是 20\"); } System.out.println(\"我仍有執行到!\"); } } 我仍有執行到! 3. 總結 使用 switch 可以減少資料存取次數故效能會提升，所以如果是用於比對的話盡量使用 switch switch 不支持 long 比對，原因是不支持比較太大量的資料比對 参考链接: Java break 跳出多层循环 "},"3.JAVA/01.JAVA基礎學習/05.迴圈/5-1.迴圈敘述.html":{"url":"3.JAVA/01.JAVA基礎學習/05.迴圈/5-1.迴圈敘述.html","title":"5-1.迴圈敘述","keywords":"","body":"目錄 1. 迴圈敘述 1. 迴圈敘述 Java 迴圈方法 for( 初值設定 ; 條件判斷 ; 計次 ){ 敘述 }; 單行跑完就計次 while( 條件判斷 ){ 敘述 }; 跑到最下方才計次 do{ 敘述 }while( 條件判斷 ); 跑到下方後才計次，但第一圈會先跑 迴圈三要素 初始值設定 設定迴圈起始值 條件判斷 判斷是否重複執行迴圈的依據 直到條件為 false 才跳出迴圈 計次 經過一次迴圈就計算一次，常用遞增或遞減 參考鏈接 Java 循环结构 - for, while 及 do...while java for 循环的几种写法 "},"3.JAVA/01.JAVA基礎學習/05.迴圈/5-2.課堂作業.html":{"url":"3.JAVA/01.JAVA基礎學習/05.迴圈/5-2.課堂作業.html","title":"5-2.課堂作業","keywords":"","body":"目錄 1. 作業題目 2. 做法實現 1. 作業題目 請設計一隻 Java 程式,計算 12,6 這兩個數值的和與積 請設計一隻 Java 程式,計算 200 顆蛋共是幾打幾顆? (一打為 12 顆) 請由程式算出 256559 秒為多少天、多少小時、多少分與多少秒 請定義一個常數為 3.1415(圓周率),並計算半徑為 5 的圓面積與圓周長 某人在銀行存入 150 萬,銀行利率為 2%,如果每年利息都繼續存入銀行, 請用程式計算 10 年後,本金加利息共有多少錢 請寫一隻程式,利用 System.out.println()印出以下三個運算式結果: 5 + 5 5 + \"5\" 5 + \"5\" 並請用註解各別說明答案的產生原因 2. 做法實現 public class HK1 { public static void main(String[] args) { // 題目 1: 請設計一隻 Java 程式,計算 12,6 這兩個數值的和與積 int num1 = 12, num2 = 6; int sum = num1 + num2, primary = num1 \\* num2; System.out.printf(\"兩數之和 = %d%n兩數之基 = %d %n\", sum, primary); System.out.println(\"------------------------------\"); // 題目2: 請設計一隻Java程式,計算200顆蛋共是幾打幾顆? (一打為12顆) int eggs = 200; int dozen = eggs / 12; eggs = eggs % 12; System.out.println(\"共是 \" + dozen + \" 打 \" + eggs + \" 顆\"); System.out.println(\"------------------------------\"); // 題目3: 請由程式算出256559秒為多少天、多少小時、多少分與多少秒 int second = 256559; int days = second / 86400; second = second % 86400; int hours = second / 3600; second = second % 3600; int minutes = second / 60; second = second % 60; System.out.println(days + \" 天 \" + hours + \" 時 \" + minutes + \" 分 \" + second + \" 秒\"); System.out.println(\"------------------------------\"); // 題目4: 請由程式算出256559秒為多少天、多少小時、多少分與多少秒 double halfDiameter = 5, circlePerimeter = halfDiameter * 2 * 3.1415, circleArea = halfDiameter * halfDiameter * 3.1415; System.out.printf(\"圓面積: %s, 圓周長: %s%n\", circleArea, circlePerimeter); System.out.println(\"------------------------------\"); // 題目5: 請定義一個常數為3.1415(圓周率),並計算半徑為5的圓面積與圓周長 int principal = 1500000; double interestRate = 1.02; double interest = principal * Math.pow(interestRate, 10); System.out.printf(\"本金加利息: %.0f 元%n\", interest); System.out.println(\"------------------------------\"); // 題目6: 請寫一隻程式,利用System.out.println()印出以下三個運算式結果: // 5 + 5 // 5 + '5' // 5 + \"5\" System.out.println(5 + 5); // 5+5 = 10; 正常的兩數之合 System.out.println(5 + '5'); // 5+53 = 58; char為一個 Unicode 字元，故 '5' 轉數字為53 System.out.println(5 + \"5\"); // \"5\"+\"5\" = 55; 若將數字跟字串相加，則實為兩字串拼接，故是 55 } } "},"3.JAVA/01.JAVA基礎學習/05.迴圈/5-3.迴圈練習與比較.html":{"url":"3.JAVA/01.JAVA基礎學習/05.迴圈/5-3.迴圈練習與比較.html","title":"5-3.迴圈練習與比較","keywords":"","body":"目錄 1. break 、 continue 與 outer 2. 實際做法 1. break 、 continue 與 outer continue continue; 跳過並繼續執行(跳過並回到迴圈的起始點)，只能在迴圈中用 break break; 跳出並結束循環(跳離迴圈) outer outer: 標籤，循環跳出時定的迴圈位置(outer 名稱可自訂)，類似 c 的 goto 2. 實際做法 continue package xxx; public class HK2 { public static void main(String[] args) { for (int k = 0; k 0 2 4 6 8 break package xxx; public class HK2 { public static void main(String[] args) { for (int k = 0; k 0 outer package xxx; public class HK2 { public static void main(String[] args) { int i = 1; int j; while (i 123123123 package xxx; public class HK2 { public static void main(String[] args) { int i = 1; int j; outer: while (i 123 public class HK2 { public static void main(String[] args) { int i = 1; int j; outer: while (i 123123123 public class HK2 { public static void main(String[] args) { int i = 1; int j; while (i 123561235612356 "},"3.JAVA/01.JAVA基礎學習/05.迴圈/5-4.迴圈內的break與continue.html":{"url":"3.JAVA/01.JAVA基礎學習/05.迴圈/5-4.迴圈內的break與continue.html","title":"5-4.迴圈內的 break 與 continue","keywords":"","body":"目錄 1. 迴圈練習與比較 1. 迴圈練習與比較 重複結構(前測試) - 先進行條件判斷 - 0~n 次 for、while 重複結構(後測試) - 後進行條件判斷 - 1~n 次 - do...while 課堂練習: 輸出 0~100 中 4 的倍數 public class demo5 { public static void main(String[] args) { for (int i = 0; i public class demo5 { public static void main(String[] args) { for (int i = 0; i 課堂練習: 輸出九九乘法表 for+for 迴圈 public class demo5 { public static void main(String[] args) { for (int i = 1; i public class demo5 { public static void main(String[] args) { for (int i = 1; i for+while 迴圈 public class demo5 { public static void main(String[] args) { for (int i = 1; i for+do...while 迴圈 public class demo5 { public static void main(String[] args) { for (int i = 1; i while+do...while 迴圈 public class demo5 { public static void main(String[] args) { int i = 1; while (i 課堂練習: unreachable code 無窮迴圈，會使代碼無限循環，並讓迴圈外的語法產生語法錯誤(被認為無意義的資料) public class demo5 { public static void main(String[] args) { int i = 0; for (;;) {} } } public class demo5 { public static void main(String[] args) { while(true){} } } 課堂練習: 繪製 5*5 的三角(外層迴圈控制縱向 ↓ 內層回圈控制橫向 → ) public class demo5 { public static void main(String[] args) { for (int i = 1; i 参考链接: Java 中 print、printf、println 的区别 详解 "},"3.JAVA/01.JAVA基礎學習/06.方法的宣告與使用/6-1.方法的建立與呼叫與傳值.html":{"url":"3.JAVA/01.JAVA基礎學習/06.方法的宣告與使用/6-1.方法的建立與呼叫與傳值.html","title":"6-1.方法的建立與呼叫與傳值","keywords":"","body":"目錄 1. 方法的定義與呼叫 1. 方法的定義與呼叫 定義 可重複使用的程式碼片段 增加程式碼的閱讀性(因為方法可命名) 範例 public static void main(String[] args){...} 修飾存取方式 回傳值型別 方法名稱 傳入參數 {...} * * {...} public static void main String[] args {...} 注意 回傳值需與回傳值型別類型相同 void 沒有回傳結果，若要回傳結果則不可定 void public static void main(String[] main){ return; } 因為沒有回傳值，所以這樣使用也是合法的 方法的呼叫 呼叫不同類別中的方法(參數需照順序提供對應的資料) package ch06; public class TestCalculator { public static void main(String[] args) { // 1. 建立 Calculator 型態的物件形體 Calculator myCalculator = new Calculator(); // 2. 呼叫 Calculator 的方法 sum ， 有順序的提供對應的參數值 int sum1 = myCalculator.sum(1,2); // 4. 列印值 System.out.println(sum1); } } public class Calculator { public int sum(int x, int y) { System.out.println(\"method-1\"); // 3. 回傳相加後的值 return x + y; } } 呼叫相同類別中的方法 package ch06; public class TestCalculator { public static void main(String[] args) { // 直接使用方法(如果後面還有要用到這方法執行完的結果，可以用個變數保存) int sum1 = sum(1,2); System.out.println(sum1); } static int sum(int x, int y) { System.out.println(\"method-1\"); return x + y; } } 参考链接: Java 入門指南 "},"3.JAVA/01.JAVA基礎學習/06.方法的宣告與使用/6-2.方法覆載.html":{"url":"3.JAVA/01.JAVA基礎學習/06.方法的宣告與使用/6-2.方法覆載.html","title":"6-2.方法覆載","keywords":"","body":"目錄 1. 方法覆載(Overloading) 2. 實際用例 3. 注意 1. 方法覆載(Overloading) 定義 用統一名稱呼叫相同功能 自動依據參數的數目以及不同的資料型別自動呼叫對應的方法 public void println(int i) public void println(float f) public void println(String s) public void println(int i,float f) public void println(int i,float f,String s) public int println(int x, int y) public float println(float x, float y) public float println(int x, float y) 錯誤用法 無法根據回傳值的型態不同而區別 void method(int i) int method(int i) // 重複宣告 String method(int i) // 重複宣告 String method(int i,int i) // 重複宣告 int method(int i,int i) // 重複宣告 2. 實際用例 public class TestOverloading { // 圓形面積 public static double areaMeasure(double radius) { return radius * radius * 3.14; } // 長方形面積 public static double areaMeasure(double height, double width) { return height * width; } // 梯形面積 public static double areaMeasure(double upper, double bottom, double height) { return (upper + bottom) * height / 2; } public static void main(String args[]) { double i = areaMeasure(3.0); double j = areaMeasure(3.0, 4.0); double k = areaMeasure(3.0, 4.0, 5.0); System.out.println(\"圓形面積=\" + i); System.out.println(\"長方形面積=\" + j); System.out.println(\"梯形面積=\" + k); } } 3. 注意 int i = 0.5f 是錯誤的，原因是因為右邊的資料型別不能比左邊大 多載名子肯定是相同的 參考鏈接 java 線上教學 "},"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-1.何為物件何為類別.html":{"url":"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-1.何為物件何為類別.html","title":"7-1.何為物件何為類別","keywords":"","body":"目錄 1. 何為物件(Object)，何為類別(Class) 2. 生活用例 3. 具體解釋 4. 類別(class)是物件(object)的資料型態 5. 類別實作 1. 何為物件(Object)，何為類別(Class) 所見即物件(只要是物件就一定有此兩項) 特徵(Characteristics)或屬性(Attribute) 行為(Operation)或操作(Operation) Java 通過類別(Class)實現物件的概念，讓程式設計師能更具體與直覺的方式進行資料處裡 類別(Class) 資料成員(Data Member) > 變數(Variable) 方法成員(Method Member) > 方法(Method) 類別(class)是物件(object)的資料型態(type)，而物件(object)是由某個類(class)別產生的實體(實際存在的物體 instance) 實體就是我們口語上的物件 2. 生活用例 狗 特徵 毛皮 四隻腳 行為 公有 吠叫 私有 顛癬 滑鼠 特徵 公有 黑色 會發光 有線的 行為 公有 可操控畫面 私有 使用時偶爾按鈕沒效果 書本 特徵 紙 作者 出版商 頁數 行為 展示資訊 電視 特徵 藍芽 尺寸 解析度 產地 行為 看影片 3. 具體解釋 筆(類別 Class) 特徵(資料，變數 Variable) 顏色 廠牌 價格 行為(功能，方法 Method) 能寫 能摔 能丟 概念 舉例 類別 Pen 資料(變數) brand price size color 功能(方法) write() showInformation() 4. 類別(class)是物件(object)的資料型態 public class PenTest { public static void main(String[] args) { // 1. 物件實體化 產生物件，會自動找尋類別並載入 // 2. 類別是物件的資料型態 Pen myPen = new Pen(); myPen.brand = \"SKB\"; myPen.price = 10; Pen yourPen = new Pen(); yourPen.brand = \"MontBlanc\"; yourPen.price = 12000; myPen.showInfo(); yourPen.showInfo(); } } 5. 類別實作 宣告變數與方法 public class demo7_1 { String color; double size; double price; public void showInfo() { System.out.println(color); System.out.println(size); System.out.println(price); } } 實體化並使用 public class demo7_2 { public static void main(String[] args) { demo7_1 pen = new demo7_1(); pen.color = \"紅色\"; pen.price = 100; pen.size = 17; pen.showInfo(); } } 參考鏈接 物件導向程式設計/面向对象程序设计 物件(objcet) 類別(class) 實體(instance) "},"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-2.物件參考變數.html":{"url":"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-2.物件參考變數.html","title":"7-2.物件參考變數","keywords":"","body":"目錄 1. 物件參考(reference)變數 2. 記憶體中儲存物件參考變數 3. 記憶體空間區別 4. 查看記憶體位置 5. 垃圾物件的產生與清理 6. method 與 void 7. 更完整的解釋 1. 物件參考(reference)變數 宣告 類別名稱 變數名稱 即 Pen myPen 實體化物件 欲產生該物件真正的記憶體空間，必須以 new 關鍵字建立 new Pen() 初始化物件 用 = (指定運算子)指派該物件至物件參考變數 myPen = new Pen() 注意物件參考變數(Object Reference Variables)是個儲存物件在記憶體中位置的變數 操作資料 最普遍的方法是利用 . 運算子來操作物件的值 myPen.brand = \"SKB\" yourPen.price = 12000.0 2. 記憶體中儲存物件參考變數 類別型別(物件參考變數) 儲存記憶體位置(memory address) 即是存在 heap Memery 基本資料型別(基本資料型別變數) byte > short > int > long >　float > double > boolean > char 儲存值(value) 存在 stack Memery java 語言裡，資料型別分成兩種 基本資料型別 (stack Memery) 類別資料型別 (heap Memery) stack Memery 儲存門牌(reference，記憶體位置)，heap Memery 依照門牌找到資料，java 將 heep 的操作全交由 jvm 處理，工程師只能操作 stack 3. 記憶體空間區別 將 myPen1 = myPen2 時，也會變成相同的記憶體空間 不同的記憶體空間 相同的記憶體空間 Pen myPen1 = new Pen(); Pen myPen1 = new Pen(); Pen myPen2 = new Pen(); Pen myPen2 = myPen1; 4. 查看記憶體位置 直接 print 類別物件可以查看系統給予的記憶體位置 package xxx; public class Student { public static void main(String[] args) { Student ene = new Student(); System.out.println(ene); } } xxx.Student@15db9742 5. 垃圾物件的產生與清理 垃圾的產生 此物件已不被任何物件參考到，便稱之為垃圾 將物件參考變數指定給另一個物件 (指定的是記憶體位置) public class Student { public static void main(String[] args) { Student ene = new Student(); Student eve = new Student(); // 將物件參考變數指定給另一個物件 // 因為ene的位置跟eve相等了，所以會產生\"垃圾\"資料 ene = eve; System.out.println(ene); System.out.println(eve); } } xxx.Student@15db9742 xxx.Student@15db9742 垃圾的清理 java 有自動回收機制，由 jvm 管理並回收 因為 java 是強行別語言，所以在練習時也能增強程式上的概念 6. method 與 void 方法上如果使用的是 value，則不須另寫回傳值 物件導向的特性可以說是以類別為基礎(class-based)的程式設計 7. 更完整的解釋 package ch07; /* * 此範例為傳值傳址測試 */ public class PassArgTest { static void passValue(double value) { value = 20.0; } static void passReference(Pen reference) { reference.price = 20.0; } public static void main(String[] args) { // 基本資料型別變數: 儲存值(value) double price = 10.0; passValue(price); // 這種寫法對price完全不會有任何更動 System.out.println(price); // 10 // 物參考變數: 儲存記憶體位置(memory address) Pen myPen = new Pen(); myPen.price = 10.0; passReference(myPen);// 但用此方法將物件傳過去，代表物件可以在方法中被使用、修改。 // JAVA官方定義中，JAVA的運行是PASS BY VALUE。 // reference(參考) 在JAVA中指的是物件實體的記憶體位置，而這個位置對JAVA來說也是代表一個值，所以所有傳遞都是值 } } package ch07; /* * 設計一個筆的類別，搭配PenTest.java一起參考使用 * 此為物件導向設計之基礎 */ public class Pen { // 實體變數(屬性變數，成員變數)，需透過物件參考變數進行操作 String brand; double price; // 方法成員，需透過物件參考變數進行呼叫 public void showInfo() { System.out.println(\"牌子為：\" + brand); System.out.println(\"價格為：\" + price); } } 參考鏈接 Java 面試考題 "},"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-3.課堂練習.html":{"url":"3.JAVA/02.JAVA物件導向/07.物件導向概論/7-3.課堂練習.html","title":"7-3.課堂練習","keywords":"","body":"目錄 1. 題目 2. 作答 1. 題目 建立一個方法 Student.java，並定義一個屬性為 score，型別為 int，另定義兩個方法分別為 play()與 study()，功能如下: public void play(int hours) 每玩樂一小時，score 就會減 1 public void study(int hours) 每玩樂一小時，score 就會加 1 2. 作答 方法 1 package xxx; public class demo6 { public static void main(String[] args) { int score; score = play(10) + study(3); System.out.print(score); } public static int play(int hours) { return hours * (-1); } public static int study(int hours) { return hours; } } 方法 2 public class Student { int score = 90; public void play(int hours) { score -= hours; } public void study(int hours) { score += hours; } public static void main(String[] args) { Student ene = new Student(); Student eve = new Student(); ene.play(5); ene.study(3); eve.play(5); eve.study(3); System.out.println(ene.score); System.out.println(eve.score); } } 方法 3 package xxx; public class Student { int score = 90; public void play(int hours) { for (int i = 0; i 方法 4 package xxx; public class Student { int score = 90; public void play(int hours) { score -= hours; } public void study(int hours) { score += hours; } public static void main(String[] args) { Student myScore = new Student(); myScore.play(5); myScore.study(3); System.out.println(myScore.score); } } "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-1.陣列.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-1.陣列.html","title":"8-1.陣列","keywords":"","body":"目錄 1. 陣列基本使用方式 2. 變數初始值 3. 實際做法 4. 領域知識 1. 陣列基本使用方式 需使用 new 來分配陣列的儲存空間，且宣告時需指定陣列長度且不可再更改 陣列的指定運算也是傳遞陣列的記憶體位置(memory address) int x[],y[]; 相等於 int[] x,y 取得陣列的長度 陣列名稱.length 一維陣列為元素個數 int x[] = {1,2,3} int x[] = new int(); 二維陣列為列數(小陣列的數量) int xx[][] = {{1,2,3},{1,2,3}} 宣告好陣列並用 new 關鍵字分配好儲存空間後，所有元素都會自動賦予初始值 跟實體變數的御蛇初始值一樣內容 2. 變數初始值 變數型態 值 byte 0 short 0 int 0 long 0L float 0.0f double 0.0 boolean false char '\\u0000' 實體變數 null 3. 實際做法 package xxx; public class HelloEclipse { public static void main(String[] args) { // 1. 宣告時就將資料一起同時放入，在陣列的資料都稱為\"元素\" (element) // 元素是有順序性的，因此元素就有索引值可以使用(index) // index 從 0 開始 double[] socres = { 100, 100, 95, 97, 99.8 }; for (int i = 0; i 4. 領域知識 Domain Knowledge 撰寫代碼時可以遇到不同領域的公司，都要去學習該領域的知識 參考鏈接 Java Gossip: 一維陣列物件 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-2.隨機亂數.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-2.隨機亂數.html","title":"8-2.隨機亂數","keywords":"","body":"目錄 1. 亂數隨機方法 1. 亂數隨機方法 (Math.random() * 30) 意思是 0 ~ 30 (Math.random() * 31) + 1 意思是 1 ~ 30 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-3.課堂練習.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-3.課堂練習.html","title":"8-3.課堂練習","keywords":"","body":"目錄 1. 作答 1. 作答 方法 1: 逐行撰寫操作 package xxx; public class PricticeArray { public void printArray(int[][] arr) { for (int i = 0; i 方法 2: 切割成方法以符合 OOP 概念 (將重複使用的功能切割成小的方法模塊) refactor (重構): 方便理解、維護、擴充 package xxx; public class PricticeArray { // 設定陣列值 public int[][] getRandomArray() { int arr[][] = new int[3][3]; for (int i = 0; i 方法 3 package xxx; public class PricticeArray { // 列印陣列元素 public void printArray(int[][] arr) { for (int i = 0; i "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-4.陣列指定的敘述.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-4.陣列指定的敘述.html","title":"8-4.陣列指定的敘述","keywords":"","body":"目錄 1. 陣列指定的敘述 2. 解析 1. 陣列指定的敘述 指定運算 = 指定的是記憶體位置而不是陣列 傳遞陣列資料跟物件參考變數一樣，都是傳地址的值，所以方法中面對陣列元素修改會影響來源的陣列內容 修改方法 1 public class TestAssignArray1 { public static void main(String[] args) { int[] intArray1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // 將 intArray1指定給 intArray2 int[] intArray2 = intArray1; // 將intArray2所有元素乘改成0 for (int i = 0; i 0000000000 修改方法 2 public class TestAssignArray2 { static void passReference(int[] intArray) { for (int i = 0; i 0000000000 2. 解析 步驟 1: 因為此時 int[] intArray2 = intArray1; 所以此時記憶體位置相同 int[] intArray1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int[] intArray2 = intArray1; 值 記憶體位置 intArray2 0x12 intArray1 0x12 步驟二: 此時若修改 intArray2 則表示修改當下 array 記憶體位置的值，也就是修改 0x12 陣列位置值，又因為 intArray1 與 intArray2 相等，所以都會修改到 for (int i = 0; i 步驟三: 顯示結果 for (int i = 0; i 0000000000 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-5.static與其他物件關係.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-5.static與其他物件關係.html","title":"8-5.static 與其他物件關係","keywords":"","body":"目錄 1. static 靜態 1. static 靜態 當有物件對這屬性資料有加減的動作時，這物件的狀態成員資料不會影響到另外一個物件成員資料 意思是說物件在建立後，要使用這資料會存在自己物件的記憶體，而不是共用的 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-6.進階陣列操作.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-6.進階陣列操作.html","title":"8-6.進階陣列操作","keywords":"","body":"目錄 1. 進階陣列操作 1. 進階陣列操作 只要有物件就有類別，int[]由 JVM 自動產生，所以不包含在官方教學文件當中 陣列排序(Natural Order，自然順序，由小到大) Arrays.sort(arrayName); // 陣列排序 int[] intArray = { 200, 300, 100 }; Arrays.sort(intArray); // 呼叫sort方法並傳入欲進行排序的陣列 for (int i = 0; i 陣列搜尋 使用二分搜尋法搜尋陣列內某值的位置(index)並回傳 int Arrays.binarySearch(ayyarName,searchData); // 複製陣列 int[] intArray2 = { 100, 200, 300 }; // 呼叫copyOf方法並傳入兩個參數：欲複製的陣列、欲複製的陣列長度 int[] intArray2B = Arrays.copyOf(intArray2, intArray2.length); intArray2[0] = 0; System.out.println(intArray2[0]); System.out.println(intArray2B[0]); 複製陣列(非複製位置，且不互相影響)(JDK6 後新增方法)(一維陣列才可使用此方法]) 複製出的陣列可以不用預先初始化(不用 new)，直接回傳(複製出)一個新陣列，即不同的記憶體位置 Arrays.copyOf(copyArrayName,copyArrayName.length); // 搜尋陣列內的值 int[] intArray3 = { 100, 200, 300, 50 }; // 呼叫binarySearch方法並傳入兩個參數：欲搜尋的陣列、欲搜尋的值(具體是使用二分搜尋法) // {50, 100 | 200, 300} 自中央開始判斷，會先由靠左的開始比大小 // 注意：欲搜尋前必先將陣列進行排序 // 沒搜尋到則為負數 Arrays.sort(intArray3); int i1 = Arrays.binarySearch(intArray3, 50); // 有要搜尋的值 int i2 = Arrays.binarySearch(intArray3, 150); // 沒有搜尋到值 System.out.println(i1); // 回傳負索引減1的值 System.out.println(i2); 顯示陣列內容 方便觀察 String str = Arrays.toString(arrayName); System.out.println(str); 參考鏈接 binarySearch 二分搜尋法 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-7.String特性與常用方法.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-7.String特性與常用方法.html","title":"8-7.String 特性與常用方法","keywords":"","body":"目錄 1. String 物件的特性 2. String 類別常用方法 1. String 物件的特性 不可變的(immutable)字串 String 一旦宣告後就不能在記憶體位置改變字串內容; String 的 length 是方法，不是屬性 使用 String 類別任何方法時，傳回的字串都會放在新的記憶體空間 為加快程式執行，Java 會把此類字串放在字串池(String Pool)裡，Pool 的目的都是為了讓資源重複使用 new String(); 是存在 heat 空間，String str = \"Hello\" 是存在字串池(可重複使用) 比較字串內容時應該使用 equals 的方法 String str1 = \"Hello\"; String str2 = \"Hello\"; str1.equals(str2); 並非使用 == ，因為在 Java 字串中比較的是記憶體位置(判斷是否占用相同的記憶體空間)而不是內容 == 在 Java 中用來比較兩個變數的值是否相等，小心型別與類別型別兩種變數 String s1 = \"hello\"; String s2 = \"hello\"; // 字串型別 String s3 = new String(\"hello\"); // 類別型別(獨立的記憶體空間) System.out.println(s1 == s2); // true 比對字串值是否相等 System.out.println(s1 == s3); // false 比對記憶體空間是否相等 System.out.println(s1.equals(s3)); // true 字串內容比對 2. String 類別常用方法 str.charAt() 透過索引值(index 從 0 開始)取得字串內某個字元 str.length() 取得字串長度 str.isEmpty() null (空值) 只能搭配物件參考變數使用，多用於一開始初值宣告，代表這個變數目前沒有物件實體記憶體位置的意思 str.substring(int beginIndex) 擷取從開始索引值的字元至最終字元 str.substring(1) 範圍是 (1 ~ 最後) str.substring(int beginIndex, int endIndex) 從開始索引值至結束索引值範圍的內容(結束索引值的內容不取，endIndex - 1) str.substring(1, 3) 範圍是 (1 ~ 3) \"Hello\".substring(1, 3) 結果 el str.trim() 去掉字串頭尾所有空白 str.equals(str2) 比較字串是否相等，Java 的字串比對須用此方式 str.compareTo(str2) 返回兩個 ASCII 碼的差值(unicode 包含 ascii) ascii 是 10 進位，unicode 是 16 進位 compare(比較) 回傳=0，兩個字串相等 回傳>0，左字串大於右字串 回傳小於右字串 String str = \"hello\" String str2 = \"hello\" String str.compareTo(str2) 当 str 不为 String 类型时，会报错 JDK6 前測試是否為空字串 String s = \"\" 時 ，需使用 if(s.length() == 0) ，JDK6 後則使用 if(s.isEmpty()) 來測試 參考鏈接 java 中 equals 和 compareTo 的区别---解惑 "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-8.命令列參數.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-8.命令列參數.html","title":"8-8.命令列參數","keywords":"","body":"目錄 1. 用 CMD 測試第一個 main 方法 1. 用 CMD 測試第一個 main 方法 撰寫並編譯 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Today is\" + args[0] + \" \" + args[1]); } } javac HelloWorld.java java HellWorld Monday Today is Monday 輸入 class 與字串 編輯時是依照空白做區隔，故須使用 \"\" 方式將文字以字串型式放入 java HelloWorld Monday Today is nice! Today is Monday Today java HelloWorld Monday \"Today is nice!\" Today is Monday Today is nice! "},"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-9.不固定參數個數.html":{"url":"3.JAVA/02.JAVA物件導向/08.陣列與字串/8-9.不固定參數個數.html","title":"8-9.不固定參數個數","keywords":"","body":"目錄 1. 不固定參數個數(Varargs) 1. 不固定參數個數(Varargs) 不固定參數個數用法 int (參數型態) 後添加 ... 即 int... int... c 須放在最後，否則資料會造成混淆 void methods (String a,int b,int... c) { ... } 一個方法只能放置一個不固定參數 public class AddInt { public int varArgsTest(int... c){ int sum = 0; for(int i = 0; i "},"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-1.封裝的基本概念.html":{"url":"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-1.封裝的基本概念.html","title":"9-1.封裝的基本概念","keywords":"","body":"目錄 1. 封裝的基本概念 2. 封裝範例 3. 總結 1. 封裝的基本概念 封裝的基本就是類別 做到資料隱藏與存取限制，當我們將設計好料與方法包在物件裡，都須透過該物件的成員方法對資料進行存取動作，且其他程式無法直接對物件的資料存取 Java 使用了 private 、 default 、 protected 與 public 四種存取修飾子(Modifier)做為封裝權限的等級 開放等級由大至小: public > protected > default > private the Same Class the Same Package SubClass Universe 說明 public (公共) √ √ √ √ 所有類別皆能存取 protected (保護) √ √ √ 同套件下類別或所有其子類別都可存取 default (預設) √ √ 同套件下的類別皆可存取 private (私有) √ 只有該類別內部才可存取 中文說明 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public √ √ √ √ √ protected √ √ √ √ default √ √ √ private √ 存取修飾子適用場合(區域變數沒有存取修飾子) 因為方法變數(區域變數)的存取權限已經由他所屬的方法決定好了，所以在方法變數上使用存取修飾子就沒有意義 類別 實體變數 方法 建構子 public √ √ √ √ protected √ √ √ default √ √ √ √ private √ √ √ 沒有任何存取修飾關鍵字就是預設(default)的範例，不用也不要在前方填寫 default (不是用 default 關鍵字) class PenTest{ ... } 實體變數 class PenTest{ private String brand; double price; } 2. 封裝範例 未使用封裝的情況，請以多人(團隊)使用角度來思考此問題 在 getter/setter 方法裡實現對資料檢查或過濾的邏輯 public class PenGood { private String brand; private double price; public String getBrand() { return brand; } public void setBrand(String brandXXX) { brand = brandXXX; } public double getPrice() { return price; } public void setPrice(double priceXXX) { if(priceXXX > 0) price = priceXXX; else System.out.println(\"請確認售價設定\"); } } public class PenTestGood { public static void main(String[] args) { PenGood p = new PenGood(); p.setBrand(\"SKB\"); p.setPrice(-10); // 會跳出 \"請確認售價設定\" ，因價格不會有負數 System.out.println(p.getBrand()); System.out.println(p.getPrice()); } } 3. 總結 理想的程式碼來說，大多數甚至全部變數 (Variable) 都會是 private 修飾子 這表示他們無法直接被自己所屬以外的類別修改或查詢，只能藉由自己類別中的方法來修改或查看 參考鏈接 package 與存取修飾 Java 修飾符 private,default,protected,public 區別的再辨識 "},"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-2.建構子的使用.html":{"url":"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-2.建構子的使用.html","title":"9-2.建構子的使用","keywords":"","body":"目錄 1. 區分建構子與類別依據 2. 建構子的目的 3. 實際用例 1. 區分建構子與類別依據 建構子跟類別名稱(class name)相同 建構子沒有回傳(return)，因為建構子不允許回傳值 public void PenGood(...){...} 方法 public PenGood(...){...} 建構子 不用寫 void，寫了就變方法 一個類別可以有多個建構子 建構子可使用 Overload 使用建構子一定要 new (建構子代表一個物件的出生，所以只執行一次) PenGood p = new PenGood(); Java 會預設給一個不帶參數的建構子，一旦宣告其他建構子則 Java 會自動將此預設建構子移除 PenGood p = new PenGood(); 預設建構子 PenGood p = new PenGood(\"123\", 100); 自訂建構子 2. 建構子的目的 解決在創建物件時，能更簡化該物件屬性初始值的設定動作 3. 實際用例 public class PenGood { private String brand; private double price; public PenGood(String brandXXX, double priceXXX) { // PenGood 為建構子 setBrand(brandXXX); setPrice(priceXXX); } public String getBrand() { return brand; } public void setBrand(String brandXXX) { brand = brandXXX; } public double getPrice() { return price; } public void setPrice(double priceXXX) { if (priceXXX > 0) price = priceXXX; else System.out.println(\"請確認售價設定\"); } } package ch09; /* * 試著操作給不同的值 * 看結果有何變化 */ public class PenTestGood { public static void main(String[] args) { PenGood p = new PenGood(\"123\", 100); System.out.println(p.getBrand()); System.out.println(p.getPrice()); } } "},"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-3.建構子與方法.html":{"url":"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-3.建構子與方法.html","title":"9-3.建構子與方法","keywords":"","body":"目錄 1. 建構子 2. 覆載(Overloading)建構子 1. 建構子 使用 this (這個物件，即物件的代名詞) 就可獲取到實體變數(跟著物件實體)，this.實體變數 就表示使用這個物件。又可稱為執行當下物件的一個通稱表示。 public class Animal { int age; // 實體變數 float weight; // 建構子 public Animal(int age, float weight) { // 實體變數 = 函數參數 this.age = age; this.weight = weight; } // 方法 public void speak() { System.out.println(age + \"歲\"); System.out.println(weight + \"公斤\"); } } public class AnimalTest { public static void main(String[] args) { // 實體化建構子 Animal animal = new Animal(2, 5.0f); // 使用 speak 方法 animal.speak(); } } 2. 覆載(Overloading)建構子 建構子可以呼叫其他建構子(僅限同個類別的其他建構子) 方便類別的使用者可以根據不同狀況都能產生物件 使 user 可以在各種情況選擇適合的建構子來創建物件 搭配 this(...) 對物件設計可以有我們自訂的預設值 有參數要給值就都要給，才能運作 如要設定預設值，則要使用呼叫其他建構子的方式，這樣在資料跳轉時就能在不同場合(情境)給予相應值 public class PenConstOverload { private String brand; private double price; public PenConstOverload(String brand, double price) { // 4. 設定資料 this.brand = brand; this.price = price; } public PenConstOverload(double price) { this(\"SKB\", price); } public PenConstOverload(String brand) { // 2. Overloading 至指定建構子 this(brand, 10); // 3. 給值 並呼叫其他建構子 } public PenConstOverload() { this(\"SKB\", 10); } public void showInfo() { // 6. 顯示資料 System.out.println(\"牌子為： \" + brand); System.out.println(\"價格為： \" + price); System.out.println(\"=============\"); } public static void main(String[] args) { PenConstOverload p1 = new PenConstOverload(\"A\", 20); PenConstOverload p2 = new PenConstOverload(40); // 1. 輸入資料 PenConstOverload p3 = new PenConstOverload(\"B\"); PenConstOverload p4 = new PenConstOverload(); p1.showInfo(); p2.showInfo(); // 5. 呼叫方法 p3.showInfo(); p4.showInfo(); } } ============= 牌子為： SKB 價格為： 40.0 ============= 牌子為： B 價格為： 10.0 ============= 牌子為： SKB 價格為： 10.0 ============= "},"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-4.static修飾子.html":{"url":"3.JAVA/02.JAVA物件導向/09.使用封裝與建構子/9-4.static修飾子.html","title":"9-4.static 修飾子","keywords":"","body":"目錄 1. static 修飾子(類別變數) 2. 用類別名稱呼叫類別變數 3. static 修飾子與存取控制 4. 能夠使用 static 的情境 1. static 修飾子(類別變數) 實體變數 由物件各自獨立維護，彼此不受干擾 商品(每支筆)有單獨價格 類別變數(static) 屬於類別變數，但可由該類別所創造(new) 出來的物件共享共用 商品(每支筆)都統一價格 實體變數宣告 static 稱為類別變數或靜態變數 方法宣告 static 稱為類別方法或靜態方法 類別變數跟實體變數都有初始值 類別變數與類別方法會跟著類別存在 當類別第一次被載入 JVM(.class 檔)時，實體被建構前就已經先載入靜態變數與方法(隨著檔案停止運行後消亡) 建議用類別名稱呼叫類別變數 儲存空間 類別變數 global 實體變數 heep 方法變數 stack 區塊變數 stack 程式碼區 靜態區: 編譯時期配置 global 動態區 字串常數池 String constant pool 堆疊 stack 堆積 heap 2. 用類別名稱呼叫類別變數 類別變數的創建與呼叫 物件可以創建後馬上用 static 的，static 的不能馬上使用 static 外的物件 (需使用記憶體的先後順序思考) 太陽是(static)，所有的人(non-static)看到的都是太陽。 因為太陽(static)已經先出現了，所以所有人(non-static)都能用太陽的資源。 但因為太陽(static)是先出現的，所以不知道什麼是人(non-static)。 public class Count { // 產品序號 private int serialNumber; public int getSerialNumber() { return serialNumber; } // 產品數量 private static int counter; public static int getTotalCount() { return counter; } // 建構式 public Count() { counter++; serialNumber = 1000 + counter; } } public class TestCount { public static void main(String[] args) { System.out.println(\"起始數量:\" + Count.getTotalCount() + \"\\n\"); Count count1 = new Count(); System.out.println(\"累計數量:\" + Count.getTotalCount()); System.out.println(\"序號:\" + count1.getSerialNumber() + \"\\n\"); Count count2 = new Count(); System.out.println(\"累計數量:\" + Count.getTotalCount()); System.out.println(\"序號:\" + count2.getSerialNumber() + \"\\n\"); } } 起始數量:0 累計數量:1 序號:1001 累計數量:2 序號:1002 3. static 修飾子與存取控制 static 修飾子 package ch09; public class Count { // 產品序號 private int serialNumber; public int getSerialNumber() { return serialNumber; } // 產品數量 private static int counter; public static int getTotalCount() { return counter; } // 建構式 public Count() { counter++; serialNumber = 1000 + counter; } } static 修飾子與區塊 static 區塊裡也不能直接使用 non-static 的資料與方法 package ch09; public class Count2 { // 產品序號 private int serialNumber; public int getSerialNumber() { return serialNumber; } // 產品數量 private static int counter ; // static區塊 static { counter = 0; System.out.println(\"起始數量:\" + counter + \"\\n\"); } public static int getTotalCount() { return counter; } // 建構式 public Count2() { counter++; serialNumber = 1000 + counter; } } 4. 能夠使用 static 的情境 方法中沒用到物件的資源就能設定成 static package ch09; /* * 此範例為示範static方法使用 */ public class TestStaticMethod { public static void main(String[] args) { System.out.println(\"請畫三角形!\"); int count = 9; drawTriangle(count); System.out.println(\"畫的還不錯!\"); } public static void drawTriangle(int count){ int i, j; for ( i = 1; i 複習重點 get set 方法的使用 get 回傳值用 set 設定值用 建構子怎麼分辨/特性上的不同 static this 的使用(物件的代名詞) 註[i] JVM，JAVA 工具運行平台 參考鏈接 Java 複習筆記 : 變數與記憶體 24 个 Jvm 面试题总结及答案 "},"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-1.繼承基本概念.html":{"url":"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-1.繼承基本概念.html","title":"10-1.繼承基本概念","keywords":"","body":"目錄 1. 繼承基本概念 2. 繼承優點與好處 3. 繼承與法與注意事項 4. 覆寫(Overriding)目的與規定 5. final 修飾子 6. 呼叫父類別的方法 7. 呼叫父類別的建構子 8. 複雜的繼承關係 9. 課堂練習 10. 因為 super()產生的錯誤 11. 標註(Annotation)的作用 1. 繼承基本概念 子類別(subclass)延伸(extence)父類別(superclass) 使用繼承的話子類別(subclass)就可以直接擁有父類別(superclass)的東西，且不用在子類別再寫一次 子類別可以擴充自己的東西 類別的延伸與擴展(包含成員變數與方法) 父類別(superclass) 具有共同成員的類別 一般化(generalization) 子類別(subclass) 繼承父類別的類別 特別化(specialization) 父類別 子類別 2. 繼承優點與好處 主要目的就是提高程式的重複使用姓 子類別將會繼承到父類別中所有可以存取的成員，包括變數與方法 (雖然可以存取，但還是會受到存取修飾關鍵字的影響) 共同資料只要描述一次(會隱含在子類別裡面) 處裡共同資料的成員方法也只要描述一次 3. 繼承與法與注意事項 繼承(inhert)的關鍵字 extends ， 使用方法 class SubClassName extends SuperClassName{...} 只能繼承方法跟成員 當 B 繼承 A，以 B is a A(is a 可以理解為 是一種) 表示 FullTimeEmployee is a Employee 自動門 is a 門 FullTimeEmployee has a MonthlySalary 自動門 has a 尺寸 自動門 has a 自動化開關 注意 Java 不支援多重繼承，一個子類別只能 extends 一個父類別 OOP 來說是可以多重繼承的(ex.C++) 建構子(Constructor)無法被繼承 無法被繼承是因為他是私有物?? 建構子的特性: 需跟 class 名稱相同，但繼承到新的 class 就肯定跟當下的 class 名稱不同了，要用也沒辦法使用 java.lang.Object 類別為所有類別的共同父類別(所有類別的根) 源頭找上去就能找到 Object public class LetMeAskYou extends Object {...} ，所有 class 都有隱藏的父類別 Object Pen Pencil AutoPencil AutoPencil is a Pencil AutoPencil is a Pen Everything is a Object 4. 覆寫(Overriding)目的與規定 目的 子類別繼承父類別後，不滿意父類別定義的方法時子類別可以在繼承後重新改寫，即為 Overriding 規定(只是對方法內容改變，所以方法宣告的結構不可以亂動) 方法名稱、參數數量、參數型別、回傳型別要一樣 子類別覆寫方法時存取修飾子的等級不能小於原方法 存取修飾子 : public > protected > default > private final 修飾子 一個類別宣告為 final(常數) 時不能被繼承(絕子絕孫) public final class String {...} public final class Math {...} public class A extends Math {...} 會提示錯誤，因為 String 為 final public final Methods(...){...} method 也可變成 final final Pen myPen = new Pen(); 物件參考變數宣告為 final，表示這個變數在初始值化後不得在指向另一個物件 固定不變的是址的值，而該物件的屬性是否能修改要看宣告屬性時是否有加上 final final Pen myPen = new Pen(); Pen yourPen = new Pen(); myPen = yourPen; // 會產生錯誤，因為 myPen 被宣告為 final public static final double price = 10.0; 固定不能變動的值，繼承後也不能改變 任何人都能用，不能直接修改，固定的，double 型態的，金額 5. final 修飾子 super.MethodName(); 子類別通過 super. 可以呼叫上一層類別的方法，無法越級呼叫(就是只能呼叫上一個) 6. 呼叫父類別的方法 呼叫父類別的建構子 子類別透過建構子，用 supper(...) 將共同的建構子參數傳給父類別(指共同的資料應使用父類別的建構子) 物件產生時，建構子呼叫的順序為先父類別在子類別，所以 建構子中若有出現super(...)，一定要放在第一個敘述位置 建構子中若未出現super(...)，JAVA 預設會有一個隱形的 super() 相當於沒有建立建構子，則類別中預設會有一個隱形的建構子 呼叫父類別不帶參數的建構子，預設自動放 super() 在第一個敘述的位置 所有 class 都有隱藏的父類別 Object this() 與 super() 在建構子的設計上都得放在第一個敘述位置，才能符合建構子執行順序規則，所以兩個只能擇一使用 建構子的特性，一次性，所以一個方法內不能重複用 this() 與 super() super(1,2) 呼叫同個類別的建構子 this(1,2) 7. 呼叫父類別的建構子 8. 複雜的繼承關係 通過繼承方式來產生兩個 animal 方法 1 package xxx; public class Elephant extends Animal { String name; public Elephant(){ } public Elephant(String name, int age, float weight) { super(age, weight); this.name = name; } public void speak() { super.speak(); System.out.println(name); } public static void main(String[] args) { Elephant Animal = new Elephant(\"Animal\", 3, 8); Elephant Elephone = new Elephant(\"Elephone\", 8, 1200); Animal.speak(); Elephone.speak(); } } package xxx; public class Animal { private int age; private float weight; public Animal(){ } public Animal(int age, float weight) { this.age = age; this.weight = weight; } public void speak() { System.out.println(age + \"歲\"); System.out.println(weight + \"公斤\"); } public void setAge(int age) { this.age = age; } public float getWeight(float weight) { return weight; } public void setWeight(float weight) { this.weight = weight; } } 3歲 8.0公斤 Animal 8歲 1200.0公斤 Elephone 方法 2 package xxx; public class Animal { private int age; private float weight; public Animal(){ } public Animal(int age, float weight) { this.age = age; this.weight = weight; } public void speak() { System.out.println(\"Age is = \" + age); System.out.println(\"Weight is = \" + weight); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public float getWeight() { return weight; } public void setWeight(float weight) { this.weight = weight; } } package xxx; public class Elephant extends Animal { private String name; public Elephant(){ } public Elephant(int age, float weight, String name) { super(age, weight); this.name = name; } public void speak() { System.out.println(name + \"，\" + super.getAge() + \" 歲，\" + super.getWeight() + \" 公斤\"); } public static void main(String[] args) { Elephant Animal = new Elephant(3, 8, \"Animal\"); Elephant Elephone = new Elephant(8, 1200, \"Elephone\"); Animal.speak(); Elephone.speak(); } } 9. 課堂練習 public 建構子(){} 因為程式撰寫會再結合框架，也為了讓後續繼承時要用，所以會保留一個空的建構子(預設建構子) 做到此步驟時 Elephant 會有警示 public class Elephant extends Animal { } 原因是因為繼承時會有隱形的 super() 父類別功能 public class Elephant extends Animal { public Elephant(){ super(); // 使用父類別的建構子 } } 但又因為 Animal 類別中符合不需傳入參數的建構子，所以找不到而出錯 public class Animal { private int age; private float weight; // 父類別建構子，沒有空的建構子 public Animal(int age, float weight) { this.age = age; this.weight = weight; } public void speak() { System.out.println(\"Age is = \" + age); System.out.println(\"Weight is = \" + weight); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public float getWeight() { return weight; } public void setWeight(float weight) { this.weight = weight; } } 為了符合目前有的父級建構子的資料，就要入參，讓 super 可有值 (到此步驟就將出現的錯誤修改完成了) public class Elephant extends Animal { public Elephant(int age, float weight){ super(int age, float weight); } } 10. 因為 super()產生的錯誤 可以協助提醒是否格式錯誤 @Override // JDK5時加入的功能(Annotation 標註) public void speak() { // TODO Auto-generated method stub super.speak(); } 有這種綠色鍵頭表示格式正確 "},"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-2.多型.html":{"url":"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-2.多型.html","title":"10-2.多型","keywords":"","body":"目錄 1. 多型(Polymorphism) 2. 晉升 3. 轉型 4. instancef 運算子 5. 多型的 Overriding 6. 簡化實體化做法 1. 多型(Polymorphism) 所謂多型(Polymorphism)是運用類別間繼承的關係(is a)，使父類別(superclass)可以當成子類別(subclass)的通用型態(type) 2. 晉升 子類別可以自動升級(晉升)成父類別 有繼承(此方式套用類別間的繼承關係) Employee(員工) 位階低(子類別) FullTimeEmployee(正職員工) 位階高(父類別) Employee e1 = new FullTimeEmployee(); // 型別晉升 Employee e1 = new Manager(); // 型別晉升 Employee e1 = new PartTimeEmployee(); // 型別晉升 Employee FullTimeEmployee Manager PartTimeEmployee 3. 轉型 父類別若是要轉型成子類別，則需要靠強迫轉型(Casting)，但是會在執行時期檢查是否能夠轉回適當的子類別 轉型要比對EmployeePoly e1 = new FullTimeEmployee(7002, \"peter\", 50000.0) 的 FullTimeEmployee FullTimeEmployee 繼承 EmployeePoly，所以轉型成 FullTimeEmployee 或 EmployeePoly 都可以 EmployeePoly e1 = new FullTimeEmployee(7002, \"peter\", 50000.0); FullTimeEmployee f = (FullTimeEmployee)e1; // 轉型 FullTimeEmployee = FullTimeEmployee 轉型成功 java.lang.ClassCastException 轉型失敗的例外(不符合繼承關係) 因為物件實體是動態(程式執行時)產生的，所以在編譯時無法得知參考變數指向的物件實體是什麼 物件轉型比基礎類別轉型危險度更高，因為要執行後才看得出效果 Manager m = (Manager)e1; // 執行時發生 java.lang.ClassCastException 4. instancef 運算子 instanceof 運算子常被用來判斷父類別參考真正指向何種子類別的實體 EmployeePoly e1 = new FullTimeEmployeePoly(7002, \"peter\", 50000.0); System.out.println(e1 instanceof FullTimeEmployeePoly); // true System.out.println(e1 instanceof ManagerPoly); // false System.out.println(e1 instanceof PartTimeEmployeePoly); // false System.out.println(e1 instanceof EmployeePoly); // true EmployeePoly e2 = new ManagerPoly(7003, \"merry\", 50000.0, 10000.0); System.out.println(e3 instanceof FullTimeEmployeePoly); // true System.out.println(e3 instanceof ManagerPoly); // true System.out.println(e3 instanceof PartTimeEmployeePoly); // false System.out.println(e3 instanceof EmployeePoly); // true EmployeePoly e3 = new PartTimeEmployeePoly(7004, \"John\", 1000.0, 8); System.out.println(e3 instanceof FullTimeEmployeePoly); // false System.out.println(e3 instanceof ManagerPoly); // false System.out.println(e3 instanceof PartTimeEmployeePoly); // true System.out.println(e3 instanceof EmployeePoly); // true 5. 多型的 Overriding 使不同類別中的方法可在繼承後改為自己所需的結構 public class FullTimeEmployeePoly extends EmployeePoly { ... // add public double getSalary() { return monthlySalary; } ... } public class ManagerPoly extends EmployeePoly { ... // add public double getSalary() { double monthlySalary = super.getSalary(); return monthlySalary + bonus; } ... } public class PartTimeEmployeePoly extends EmployeePoly { ... // add public double getSalary() { return hourPay * workHour; } ... } 6. 簡化實體化做法 用父類別的型別(參考)，指向子類別的物件，並對應到子類別(Overriding)的方法 執行時期父類別會先判斷實際的子類別物件是哪一個，再呼叫此子類別裡對應的 Overriding 方法，此機制在物件導向裡稱為 dynamic binding 或 late binding 不同型別，不能一致的處裡資料 ManagerPoly e0 = new ManagerPoly(7003 ,\"merry\", 50000.0 , 10000.0); 相同型別，可以一致的處裡資料 EmployeePoly e0 = new ManagerPoly(7002 ,\"peter\", 40000.0 ); 放在一起(一致性處裡，程式碼簡化) // 使用共同型別的宣告是為了資料的一致性處裡 EmployeePoly[] e = new EmployeePoly[3]; // 1. 宣告物件的陣列大小 e[0] = new FullTimeEmployeePoly(7002 ,\"peter\", 40000.0 ); // 2. 將物件實體化 e[1] = new ManagerPoly(7003 ,\"merry\", 50000.0 , 10000.0); e[2] = new PartTimeEmployeePoly(7004 , \"John\" , 1000.0, 8); // 因為簡化了前面的實體化作法，故在此可以一次處裡所有 getSalary() 方法，且會確認物件是否真的存在(物件執行到new了後才存在) for (int i = 0; i Java 自動判斷繼承關係 編譯時期，Java 會根據我們宣告使用的類別來檢查呼叫的方法，或是存取的屬性是否存在(身分(資料型別)決定你的行為與特徵) 父類別的方法不能省去，否則會無法進行對應造成錯誤 EmployeePoly[] e = new EmployeePoly[3]; FullTimeEmployeePoly e0 = new FullTimeEmployeePoly(7002, \"peter\", 40000.0); ManagerPoly e1 = new ManagerPoly(7003, \"merry\", 50000.0, 10000.0); PartTimeEmployeePoly e2 = new PartTimeEmployeePoly(7004, \"John\", 1000.0, 8); e[0] = e0; // JAVA會自動判斷類別間有沒有繼承關係，符合就可Polymorphism e[1] = e1; e[2] = e2; for (int i = 0; i 參考鏈接 物件陣列的運用 JAVA - 物件轉成陣列 "},"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-3.方法到與建構子的差異.html":{"url":"3.JAVA/02.JAVA物件導向/10.繼承與多型/10-3.方法到與建構子的差異.html","title":"10-3.方法到與建構子的差異","keywords":"","body":"目錄 1. 方法到與建構子的差異 1. 方法到與建構子的差異 方法的宣告 沒回傳值 void method(){} 有回傳值 int method(){return 0;} 要定義型別，並設定回傳值 public class TestCount { TestCount(){} // 建構子 void TestCount(){} // 方法 public static void main(String[] args) { } } 參考鏈接 為什麽 java 的 main 方法是 public static void "},"3.JAVA/02.JAVA物件導向/11.介面與多型/11-1.抽象類別.html":{"url":"3.JAVA/02.JAVA物件導向/11.介面與多型/11-1.抽象類別.html","title":"11-1.抽象類別","keywords":"","body":"目錄 1. 抽象類別 abstract class 2. 抽象類別使用時機 3. 成功使用抽象方法的畫面 4. 一個檔案多個類別注意事項 1. 抽象類別 abstract class 抽象方法沒有方法主體，且必須加上 abstract 修飾子 指的是沒有大括號跟方法內容 public abstract void myMethod();，需添加 abstract(Java 中 abstract void myMethod(){} 就表示有內容，所以直接使用分號結尾) 抽象類別不一定要有抽象方法，但具有抽象方法的類別一定要宣告為抽象類別 public abstract class className{...} 一個類別只要加上 abstract 修飾子(即使它裡面不含任何 abstract 方法)，他就無法產生實體，只能透過繼承來建立延伸類別 一個(子)類別若繼承了抽象父類別，除非他實作(implement，跟 Override 完全一樣操作)了抽象父類別當中的所有抽象方法，否則他仍然只是個抽象類別 抽象類別不能建立物件，但可以寫建構子 2. 抽象類別使用時機 用於在父類別寫個空方法，讓後來的人繼續撰寫相應的資料(OOP 概念)(專案合作用) 在建立類別時，若有方法尚未決定如何設計內容主體時，就可將此方法加上 abstract 修飾子成為抽象方法，之後在由繼承的子類別來實作 一般來說，並不會將一個類別同時寫在一個檔案當中 package ch10; // 抽象(abstract)類別 public abstract class EmployeePoly { private int empno; private String ename; public String getEname() { return ename; } public EmployeePoly(int empno, String ename) { this.empno = empno; this.ename = ename; } public EmployeePoly() { this(0, \"-\"); } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } // 新增getSalary方法 抽象(abstract)方法 public abstract double getSalary(); } package ch10; public class FullTimeEmployeePoly extends EmployeePoly { private double monthlySalary; // 月薪 public void display() { super.display(); System.out.println(\"月薪=\" + monthlySalary); } public FullTimeEmployeePoly(int empno, String ename, double monthlySalary) { super(empno, ename); this.monthlySalary = monthlySalary; } // 標註也是使用 Override @Override public double getSalary() { return monthlySalary; } } 3. 成功使用抽象方法的畫面 4. 一個檔案多個類別注意事項 一個 java 檔可以宣告多個類別，但須注意以下兩點 一個 *.java 最多只能有一個公開(public)類別 此公開類別的名子就得跟該 java 檔名完全相同 繼承的好處由此案例可逐漸展示 package ch11; // 筆類別(父類別) // 抽象類別 abstract class Pen { protected String brand; protected double price; // 抽象方法 public abstract void write(); public void setdata(String brand, double price) { this.brand = brand; this.price = price; } } // 自訂的筆類別(子類別) class MyPen extends Pen { // 定義抽象類別的動作 public void write() { System.out.print(\"牌子是： \" + brand); System.out.println(\"價格為： \" + price); } } // 公開類別(一個file中不可有兩個公開類別，且class名需跟檔名相同) public class TestAbstract { public static void main(String args[]) { MyPen myPen = new MyPen(); myPen.setdata(\"SKB\", 10); myPen.write(); } } "},"3.JAVA/02.JAVA物件導向/11.介面與多型/11-2.介面與空介面.html":{"url":"3.JAVA/02.JAVA物件導向/11.介面與多型/11-2.介面與空介面.html","title":"11-2.介面與空介面","keywords":"","body":"目錄 1. 介面(interface) 2. 使用介面的差別 3. 空介面(Tag Interface) 1. 介面(interface) 多重繼承 Java 只能單一繼承，而介面可以實現物件導向中的多重繼承(替代 C++中的多重繼承) class 子類別 extends，父類別 implements 介面[1] 1,介面 2,...{...} ckass 子類別 implements 介面 1,介面 2,...{...} 定義規格 預先定義規格給實作此介面的所有子類別 介面可說是一種所有方法皆為抽象方法的抽象類別，所以子類別必須實作介面的所有抽象方法(class 內方法內全空) 而介面跟介面之間是可以在繼承(extends)的[2] 介面[3]類別強制其中的方法都是公開(public)的抽象(abstract)方法，所以 void disp(); 跟 public abstract void disp(); 相同 介面類別強制其中的變數都是公開(public)靜態(static)常數(final)，所以 int num = 100; 跟 public static final int num = 100; 貼標籤 型態轉換 降低相依性 X 低凝聚性 - 高相依性 明明都有共同的用法卻不用，造成每次都要牽一髮而動全身 √ 高凝聚性 - 低相依性[4] 把東西都分類好，要改的東西都單獨開來不會影響其他人 2. 使用介面的差別 使用前 不相干的 class 都會繼承到 bird，會造成混亂且會有很多用不到的語法 Birdfly(){...} Eaglefly(){...} Sparrowfly(){...} Supermanfly(){...} Planefly(){...} 使用後 class 能直接繼承介面中宣告的方法、變數，實現 OOP 中的多重繼承 >Flyablefly(); Birdfly(){...} Eaglefly(){...} Sparrowfly(){...} Supermanfly(){...} Planefly(){...} 3. 空介面(Tag Interface) 沒有定義任何方法的介面叫做空介面 java.lang.Cloneable 和 java.lang.Serializable 是比較著名的空介面 class 使用 Cloneable 空介面，才可以做物件的複製 class 使用 Serializable 空介面，才可以將物件作序列化，該物件永久儲存(persistence) 稱作序列化 一個類別可以 implements 某個空介面，好消息是不需實作任何方法，但該類別的任何實體即已經成為該介面的一個合法實體[5] package ch11; public interface IWritable { void write(); } package ch11; public class WorkWithPens2 { private IWritable writable; public IWritable getWritable() { return writable; } public void setWritable(IWritable writable) { this.writable = writable; } public void writeWithPens() { writable.write(); } } package ch11; public class InkBrush2 implements IWritable { public void write() { System.out.println(\"用毛筆寫字\"); } } package ch11; public class Pencil2 implements IWritable { public void write() { System.out.println(\"用鉛筆寫字\"); } } package ch11; public class WriteBusinessTest2 { public static void main(String[] args) { WorkWithPens2 business1 = new WorkWithPens2(); business1.setWritable(new Pencil2()); business1.writeWithPens(); WorkWithPens2 business2 = new WorkWithPens2(); business2.setWritable(new InkBrush2()); business2.writeWithPens(); } } 用鉛筆寫字 用毛筆寫字 參考鏈接 Java(类作为成员变量类型) How is it possible to use a class name as a variable name in Java? 抽象類別 (Abstract Class) vs 介面 (Interface) interface 是什麼東西 What does it mean for a function to return an interface? 可以稱為介面、窗口、接口 ↩︎ 會考，建議加強概念 ↩︎ 介面檔可以以 I 做開頭 ↩︎ 資料庫則是低凝聚高相依 ↩︎ Design Pattern 設計模式又稱做策略模式(相關資料可查詢歐萊禮的深入淺出系列書及) ↩︎ "},"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-1.Java原始檔案格式.html":{"url":"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-1.Java原始檔案格式.html","title":"12-1.Java 原始檔案格式","keywords":"","body":"目錄 1. Java 原始檔案格式 1. Java 原始檔案格式 在 Java 檔案中可能會出現三個稱為編譯單元(compilation units)的元素，這些元素皆非必要，但如果有這些元素則一定要依照以下順序出現 package 宣告 import 引用敘述 class 類別 "},"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-2.套件編譯與執行.html":{"url":"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-2.套件編譯與執行.html","title":"12-2.套件編譯與執行","keywords":"","body":"目錄 1. 套件編譯與執行(package) 2. CMD 執行 package 文件 1. 套件編譯與執行(package) java.util utility(工具) java 目錄下的 util 目錄 util 表示 java 的子套件 編譯 -d(目的地)，.表示編譯後的 class 檔至於目前的目錄位置，在文字介面(cmd)下，代表現在的路徑位置 C:\\Workspace> javac -d . HelloWorld.jaja 執行 要在原來的目錄執行 C:\\Workspace> java packageName.HelloWorld 給客戶檔案 一般給 *.class 就好，因為就可以執行了 給 *.java 就不能讓他們花錢繼續消費(即一次買斷) 2. CMD 執行 package 文件 編譯並執行 錯誤原因 文件中 package 名為 tibame，這樣之前產生的 class 檔必須要在 tibame 目錄中 新增 tibame 目錄，並將執行檔放入其中 執行成功 若下次要直接執行並放入其 package 中，則照此動作執行 "},"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-3.import套件或特定別.html":{"url":"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-3.import套件或特定別.html","title":"12-3.import 套件或特定別","keywords":"","body":"目錄 1. import 套件或特定別 1. import 套件或特定別 引用套件中所有類別 * import java.sql.*; * 代表該套件下的所有類別 引用套件中的特定類別 import java.sql.Date; 自動 import java 會自動 import java.lang.* 套件 自動引用該套件(package) 下的所有類別 不同套件仍須 import package ch08; // 套件 import ch08.*; // 該套件下所有類別 import java.lang.*; import java.xxx.*; 不包含其子目錄的類別 import java.xxx.*; 跟 import java.xxx.yyy.*; 是不同套件 不使用 import敘述，則必須用到的地方都使用類別長名稱撰寫 package ch12; public class TestImport { public static void main(String[] args) { int[] intArray = {1, 3, 2, 0}; // 正確，不 import 則每行都要這麼寫 java.util.Arrays.sort(intArray); // 錯誤，不使用 import 須嚴格按照上面方法 Arrays.sort(intArray); for(int i = 0; i 同名稱套件同時要用 一個可以 import，另個須用長名稱這樣對套件的定義才清晰 "},"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-4.靜態套件.html":{"url":"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-4.靜態套件.html","title":"12-4.靜態套件","keywords":"","body":"目錄 1. 靜態(引用)套件(sugar 功能) 2. 引用方法 3. 靜態套件與方法名、變數名相同的情形 1. 靜態(引用)套件(sugar 功能) JDK5 加入的功能 可導入類別內所有 static fields 與 static methods ，亦即使用這些 static members 無須再指定其類別名稱 用 * 可導入類別中所有靜態成員 避免過度使用 static import 功能，否則容易造成混淆而不利維護 2. 引用方法 方法 1: package ch12; // 引用靜態套件 import static java.lang.System.out; public class TestStaticImport { public static void main(String[] args) { //可省略System. out.println(\"看起來有點不習慣...\"); } } 方法 2: package ch12; import static java.lang.Math.PI; import static java.lang.Math.random; import static java.lang.System.out; public class TestStaticImport { public static void main(String[] args) { // 可省略System. out.println(\"看起來有點不習慣...\"); out.println(random()); out.println(PI); } } 方法 3: 省略的極致 package ch12; import static java.lang.Math.*; import static java.lang.System.out; public class TestStaticImport { public static void main(String[] args) { // 可省略System. out.println(\"看起來有點不習慣...\"); out.println(random()); out.println(PI); } } 3. 靜態套件與方法名、變數名相同的情形 class 中撰寫的方法、變數名會優先執行 import static java.lang.Math.*; public class TestStaticImport { public static void main(String[] args) { // 可省略System. out.println(\"看起來有點不習慣...\"); out.println(random()); out.println(PI); } public static double random() { return 0.0; } } 看起來有點不習慣... 0.0 3.141592653589793 "},"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-5.類別路徑.html":{"url":"3.JAVA/03.JAVA套件與進階/12.套件、import與類別路徑/12-5.類別路徑.html","title":"12-5.類別路徑","keywords":"","body":"目錄 1. 類別路徑(classpath) 2. 使用 cmd 執行含 import 項目 1. 類別路徑(classpath) *.jar 不能隨意移動，否則容易損壞 *.jar 是一種程式碼的壓縮包 classpath 可以讓 Java 應用程式在編輯和執行時可以找到要用的相關類別 根據 JDK 文件說明，Java 以下面三類 classpath 順序，依序找尋需的 class Boothstrap classes(Core classes) Java2 Platform 核心類別函式庫 現有，已置於 %JAVA_HOME%\\jre\\lib\\rt.jar 檔案 JDK 預設會自動載入，不必額外設定 Extension classes Java2 Platform 擴充的類別函式庫 指的是 %JAVA_HOME%\\jre\\lib\\ext 目錄下的 jar 檔或 zip 檔，third-party(第三方)的類別函式庫可以放在這幕錄下 JDK 玉社會自動載入此目錄內的所有 zip 或 jar 檔，不必再做額外設定 Users classes[1] 指使用者自己寫的類別函式庫(third-party 的類別函式庫也可) 使用者必須額外做設定，JDK 才會載入類別 是指我們在環境變數 classpath 設定路徑下的 classes 或 jar 檔 作業系統環境變數預先新增 classpath 變數可能為 .;C:\\myLib\\xxx.jar;C:\\myLib\\yyy.jar;C:\\myClass; JDK6 C:\\myLib\\xxx.jar;C:myLib\\yyy.jar; 可簡化為 C:\\myLib\\* 2. 使用 cmd 執行含 import 項目 有 import 其他項目的 class 需要每次都執行 javac -d . -cp .:....[2] 若設定了 classpath 則直接執行就好 eclipse jar 檔設定參考 p.182 (針對 java project 的說明) ↩︎ 很麻煩，現在已經不用了。早期無開發工具時使用 ↩︎ "},"3.JAVA/03.JAVA套件與進階/13.Object類別與包裝類別/13-1.Object類別.html":{"url":"3.JAVA/03.JAVA套件與進階/13.Object類別與包裝類別/13-1.Object類別.html","title":"13-1.Object 類別","keywords":"","body":"目錄 1. Object 類別 2. 主動改寫(Override) equals() 方法 3. 主動改寫(Override) toString() 方法 4. 使用 filalize() 方法 5. 使用 clone() 方法 6. 總結 1. Object 類別 Object 類別常用方法 boolean equals(Object obj) 自訂類別產生的物件要比較內容是否相同，須主動改寫 equals 方法 String toString() 通常會 override 此方法是為了方便觀察物件內容，或是 debug 時查看內容 protected void finalize() 物件被回收前處裡[1] final void wait() notify() notifyAll() 屬於執行序的部分 2. 主動改寫(Override) equals() 方法 父類別 Object 的 equal 方法 public boolean equals(Object obj) { return (this == obj); } 改寫 equal 方法 package ch13; public class Employee { private int empno; private String ename; public void setEmpno(int empno) { this.empno = empno; } public int getEmpno() { return empno; } public void setEname(String ename) { this.ename = ename; } public String getEname() { return ename; } public Employee(int empno, String ename) { this.empno = empno; this.ename = ename; } public Employee(int empno) { this(empno, \"-\"); } public Employee(String ename) { this(0, ename); } public Employee() { this(0, \"-\"); } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } // 要給任何物件使用，所以傳入值設定為 obj public boolean equals(Object obj) { // 仍要使用==來判斷，因為(也許)要比較的\"物件參考變數\"，其實指的是同一個實體(指向同一個記憶體空間) if (this == obj) return true; // 用(Object類別的)getClass()來確定是否隸屬於同一個class的物件 // obj != null 表示沒有物件，沒有記憶體位置(門牌號碼) if (obj != null && getClass() == obj.getClass()) { if (obj instanceof Employee) { Employee e = (Employee) obj; // 選擇該類別的必要成員變數(實體變數)來加以判斷是否有相等(相同) if (empno == e.empno && ename.equals(e.ename)) { return true; } } } return false; } public int hashCode() { // 借用一下 String 類別現有的hashCode運算法則 return this.ename.hashCode(); // 或借用一下 Integer類別現有的hashCode運算法則 // return new Integer(this.empno).hashCode(); } } 執行 package ch13; public class TestEquals { public static void main(String args[]) { Employee e1 = new Employee(7001, \"king\"); Employee e2 = new Employee(7001, \"king\"); System.out.println(\"e1==e2 = \" + (e1 == e2)); System.out.println(\"e1.equals(e2) = \" + e1.equals(e2)); } } e1==e2 = false e1.equals(e2) = true 3. 主動改寫(Override) toString() 方法 主要用於 debug 方便 package ch13; public class TestEquals { public static void main(String args[]) { Employee e1 = new Employee(7001, \"king\"); Employee e2 = new Employee(7001, \"king\"); System.out.println(e1.getEmpno()); System.out.println(e1.getEname()); System.out.println(\"---------------------------\"); // 會自動執行 Employee 的 toString() 方法 // toString()會默認執行，一般用於debug System.out.println(e1); } } package ch13; public class Employee { private int empno; private String ename; public void setEmpno(int empno) { this.empno = empno; } public int getEmpno() { return empno; } public void setEname(String ename) { this.ename = ename; } public String getEname() { return ename; } public Employee(int empno, String ename) { this.empno = empno; this.ename = ename; } public Employee(int empno) { this(empno, \"-\"); } public Employee(String ename) { this(0, ename); } public Employee() { this(0, \"-\"); } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } @Override public String toString() { String str = \"empno=\" + empno + \",ename=\" + ename; return str; } } 7001 king --------------------------- empno=7001,ename=king 4. 使用 filalize() 方法 java 默認執行 filalize() package ch13; class ClassFinalize { protected void finalize() { System.out.println(\"finalize方法執行了\"); } } public class TestFinalize { public static void main(String args[]) { ClassFinalize fin = new ClassFinalize(); fin = null; System.out.println(\"強制進行垃圾收集\"); System.gc(); // 不一定執行 } } 強制進行垃圾收集 finalize方法執行了 5. 使用 clone() 方法 myShirt = yourShirt.clone(); 時會將記憶體位置的值放入 看到物件中有 native ，表示使用更原生的語法(C++...)，如果要更深入的研究請參考 JVM 深入原理 參數 記憶體位置 yourShirt 0x66 myShirt 0x12 0x88 新物件 記憶體位置 G 0x66 R 0x12 G 0x88 package ch13; public class TestCloneableShirt implements Cloneable { private char colorCode = 'U'; // Unknown (未知) public char getColorCode() { return colorCode; } public void setColorCode(char newCode) { switch (newCode) { // ( R || G || B ) 只要符合都會執行 colorCode = newCode; case 'R': case 'G': case 'B': colorCode = newCode; break; default: System.out.println(\"不正確的顏色碼. 請使用 R, G, or B\"); } } public static void main(String[] args) { TestCloneableShirt myShirt = new TestCloneableShirt(); TestCloneableShirt yourShirt = new TestCloneableShirt(); myShirt.setColorCode('R'); yourShirt.setColorCode('G'); // System.out.println(myShirt.getColorCode()); // R try { myShirt = (TestCloneableShirt) yourShirt.clone(); } catch (CloneNotSupportedException e) { System.out.println(\"不允許複製此物件!\"); e.printStackTrace(); } System.out.println(myShirt.getColorCode()); // G } } 淺層複製 package ch13; public class ShallowCopy { // 淺層複製 public static void main(String[] args) { int[] iArray = { 1, 2, 3 }; // java 對 array 可以直接複製副本並且用double回傳 int[] iArray2 = iArray.clone(); // 確認有正常複製，不互相影響 iArray[0] = 0; System.out.println(iArray[0]); System.out.println(iArray2[0]); System.out.println(\"----------------------\"); Animal[] as = new Animal[2]; as[0] = new Animal(2, 5.0f); as[1] = new Animal(10, 25.0f); // 指複製表面(淺層複製)，不會複製Animal中的結構，所以實際上只複製記憶體位置 // 類別類型的複製，只複製記憶體位置 Animal[] as2 = as.clone(); as[0].setAge(100); System.out.println(as[0].getAge()); System.out.println(as2[0].getAge()); } } 深層複製 package ch13; public class TestDeepCopy { public static void main(String[] args) { // 建立測試資料 Animal a1 = new Animal(2, 5.0f); Animal a2 = new Animal(5, 15.0f); Animal[] as = new Animal[2]; as[0] = a1; as[1] = a2; // 創建一個陣列, 到時候將複製好的Animal物件放入 Animal[] as2 = new Animal[as.length]; for (int i = 0; i 10 2 6. 總結 Object 給所有東西都能用的物件，可自由延伸、更改 JAVA 是物件導向嗎? 資料全都是物件的操作方式，但 byte、short、int、long、flot、double、boolean、char 是基本資料型別，所以有的人說 java 不是純物件導向 finalize 一般很少用到 ↩︎ "},"3.JAVA/03.JAVA套件與進階/13.Object類別與包裝類別/13-2.包裝類別.html":{"url":"3.JAVA/03.JAVA套件與進階/13.Object類別與包裝類別/13-2.包裝類別.html","title":"13-2.包裝類別","keywords":"","body":"目錄 1. 包裝類別(Wrapper Class) 2. 類別類型測試 3. 裝箱拆箱 4. 型別轉換 5. 自動裝箱/拆箱(Autoboxing/Unboxing) 1. 包裝類別(Wrapper Class) Java 每一個基本資料型態都有一個相對應的 Wrapper 類別(包裝類別) boxing: 將基本型別，置入相對應的包裝類別中(裝箱/包裝) 比較兩物件是否相等 包裝類別都已經 override equals 方法了 所以比較是否相等的話是使用 boolean equals(Object obj);[1] 基本資料型態 包裝類別 byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double boolean java.lang.Boolean char java.lang.Char 整數型態跟浮點數型態，都是 java.lang.Number 的子類別 2. 類別類型測試 Integer 即 int 型別測試 package ch13; public class ShallowCopy { public static void main(String[] args) { Integer i = new Integer(10); Integer j = new Integer(10); System.out.println(i == j); System.out.println(i.equals(j)); } } 3. 裝箱拆箱 裝拆箱測試 package ch13; public class ShallowCopy { public static void main(String[] args) { Integer i = new Integer(10); // boxing(裝箱) Integer j = new Integer(10); int i3 = i1.intValue(); // unboxing(拆箱) } } 4. 型別轉換 文字轉數字 package ch13; public class ShallowCopy { public static void main(String[] args) { String s1 = \"123\"; int i1 = Integer.parseInt(s1); System.out.println(i1 + 100); } } 5. 自動裝箱/拆箱(Autoboxing/Unboxing) JDK5 加入的功能，由編譯器幫我們處裡裝/拆箱 Autoboxing(自動裝箱) 基本資料型別自動轉為包裝型態(Wrapper Types)，如 int 轉 Integer Unboxing(自動拆箱) 包裝型態自動轉為基本資料型別，如 Integer 轉 int package ch13; /* 說明: int 包裝成 Integer 稱之為 Autoboxing，反之則是 Auto-unboxing。 在 Java 中的八種基本型別，分別是 byte, short, int, long, float, double, char 和 boolean。 理論上來說，真正的物件導向中的型別應該都必須是類別定義， 像是 Short, Integer 等等類別。 不過為了我們使用上的方便，Java 提供了基本型別。 同時存在這兩種型別常常會造成我們在設計上要加上許多額外的程式碼， 例如在做數字運算時，使用 int 或 double 型別來處理， 但是要將數字存入容器時，必須要將其轉換成 Integer 或 Double 型別， 才能使用 add(new Integer(i))， 在使用容器或多型處理時常常要多一道轉型手續。 Java 1.5 中，已經增加了這方面的處理， 稱之為 Autoboxing 和 Auto-unboxing， 編譯器會自動幫我們在 int 和 Integer 之中轉換。 */ public class TestAutoboxing { public static void main(String[] args) { Integer i1 = 1; // boxing int i2 = i1; // unboxing int sum1 = i1 + i2; Integer sum2 = i1 + i2; System.out.println(sum1); System.out.println(sum2); } } 跟 String 做法相同 ↩︎ "},"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-1.Exception物件.html":{"url":"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-1.Exception物件.html","title":"14-1.Exception 物件","keywords":"","body":"目錄 1. Exception 例外處裡 2. 例外的類別層級架構 3. try-catch 4. try-catch-finally 5. throws 關鍵字 6. 常見的 Runtime Exception 7. 其他 1. Exception 例外處裡 提升 Java 的穩固性 Java 程式執行時，如果發生異常狀況，可以借助例外處裡 程式發生(產生)例外時，視為產生一個 Exception 物件 Java 的例外處裡可將一般正常處裡程序與錯誤處裡程序做到分開敘述，讓程式可讀性提高 五個關鍵字: try、catch、finally、throws、throw 適合使用的時機: 如資料庫連結失敗、找不到檔案、除 0、參數為空、參數型態不符、陣列索引超出範圍..等 2. 例外的類別層級架構 Throwable 層級架構 Throwable Error AssertionError VirtualMachineError StackOverflowError OutOfMemoryError Exception(也是一定要處裡的例外) 不一定要處裡的例外 RuntimeException ArithmeticException ClassCastException IndexOutOfBoundsException ArrayIndexOutOfBoundsException IllegalArgumentException NumberFormatException IllegalStateException NullPointerException IllegalMonitorStateException 一定要處裡的例外 ParaseException IOException EOFException FileNotFoundException InterruptedException 3. try-catch Java 的例外處裡 MyException e ，MyException 指定該 catch 要處裡的例外種類(類型)，e 對接進來的例外物件的名稱(可自行取名) 每個 catch 就是一種例外處裡方式，所以 catch 可以很多個 例外處裡中，類別位階高(父類別)者需置於類別位階低(子類別)者後方 因為如果位階高的在前方，則後續 catch 則永遠不可能執行到 try{ 正常處裡程序的程式碼...; } catch(MyException e){ 錯誤處裡程序的程式碼...; } catch(Exception e){ 錯誤處裡程序的程式碼...; } ... 例外用法 package ch01; public class TestTryCatch { public static void main(String[] args) { int i = 0; String[] strs = { \"1\", \"2\", \"Hello3\" }; while (i 1 2 java.lang.NumberFormatException: For input string: \"Hello3\" java.lang.ArrayIndexOutOfBoundsException: 3 4 4. try-catch-finally 將一定要執行的程式碼放在 finally{}的程式區塊裡 finally{} 是無論發生什麼情況皆會執行的程式區塊，用來釋放有限的資源，如: 關閉(close)資料庫連線、檔案讀取...等 try{ 正常處裡程序的程式碼...; } catch(MyException e){ 錯誤處裡程序的程式碼...; } catch(Exception e){ 錯誤處裡程序的程式碼...; } finally { 一定要執行的程式碼...; } 例外用法 package ch01; public class TestTryCatchFinally { public static void main(String[] args) { int i = 0; String[] strs = { \"Hello1\", \"Hello2\", \"Hello3\" }; while (i Hello3 一定要執行的程式碼 1-已超出陣列的長度 一定要執行的程式碼 --------------------------- 一定要執行的程式碼 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at ch01.TestTryCatchFinally.main(TestTryCatchFinally.java:23) 5. throws 關鍵字 Java 有兩種不同型態的例外(Exceptions) 執行時期的例外 這一類的例外不一定要處裡 也稱為不必檢查的例外(unchecked exceptions) 如 Runtime Exception 及其子類別 非執行時期的例外 這一類的例外一定要處裡 也稱為必須檢查的例外(checked exceptions) 如 IOException 、 SQLException ...等 在方法定義時，可使用 throws 關鍵字將可能發生的例外，丟出給呼叫此方法的程式去處裡(例外可以一直丟，最後會是 JVM 執行，說明錯誤原因並停止程式運行) void method() throws MyExcetion {...} public static int parseInt(String s) throws NumberFormatException {...} public int read() throws IOException {...} public static Connection getConnection() throws SQLException 對於checked exceptions，在呼叫有 throws 關鍵字的方法時，必須將該方法置於下列兩者之一 將該方法至於 try {} 程式區塊中 try...catch 明確處裡(自己抓下來做處裡動作) (或)將該方法置於定義有 throws 關鍵字的方法中 此為在透過 throws 丟出例外，然後再由下一個呼叫者來處裡 throws 消極處裡(再丟改後面的使用者去處裡) 一定要處裡的例外做法 1: 明確處裡 package ch01; public class TestThrows1 { String[] strs = { \"Hello1\", \"Hello2\", \"Hello3\" }; // Exception 是一定要處裡的例外，所以要用 try...catch 處裡 public void printStrs(int i) throws Exception { System.out.println(strs[i]); } public static void main(String[] args) { int i = 0; TestThrows1 t1 = new TestThrows1(); while (i Hello1 Hello2 Hello3 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3 at ch01.TestThrows1.printStrs(TestThrows1.java:7) at ch01.TestThrows1.main(TestThrows1.java:14) 一定要處裡的例外做法 2: 消極處裡 package ch01; public class TestThrows2 { String[] strs = { \"Hello1\", \"Hello2\", \"Hello3\" }; // 2. 不處裡例外 public void printStrs(int i) throws Exception { System.out.println(strs[i]); } // 4. 沒人要處裡例外，拋出由JVM處裡 public static void main(String[] args) throws Exception { int i = 0; TestThrows2 t2 = new TestThrows2(); while (i Hello1 Hello2 Hello3 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3 at ch01.TestThrows2.printStrs(TestThrows2.java:7) at ch01.TestThrows2.main(TestThrows2.java:14) 不一定要處裡的例外作法 package ch01; public class TestThrows1 { String[] strs = { \"Hello1\", \"Hello2\", \"Hello3\" }; // ArrayIndexOutOfBoundsException 是不一定要處裡的例外，所以不用 try...catch 處裡也行 public void printStrs(int i) throws ArrayIndexOutOfBoundsException { System.out.println(strs[i]); } public static void main(String[] args) { int i = 0; TestThrows1 t1 = new TestThrows1(); while (i 6. 常見的 Runtime Exception 例外(Exception)的類別名稱 例外狀況說明 ArithmeticException 分母為 0 時 NullPointerException 呼叫到一個空值 null 變數 IlleggalArgumentException 傳入的參數型態不符 NumberFormateException 傳入的參數型態不符(前者的子類別) IndexOutOfBoundsException 索引值超過物件上限 ArrayIndexOutOfBoundsException 索引值超過陣列上限(前者的子類別) SecurityException 違反安全原則(ex.將 package 命名成 java) 7. 其他 final 修飾關鍵字 變量上面不能修改變量，也不能指向新對象 方法上面不能被修改方法 類別上面不能被繼承 finalize 給垃圾回收呼叫的 filally 是個關鍵字，用在例外執行上 參考鏈接 浅析 Java 中的 final 关键字 Java 关键字 final 使用详解 "},"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-2.throw.html":{"url":"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-2.throw.html","title":"14-2.throw","keywords":"","body":"目錄 1. throw 關鍵字 2. 取得錯誤訊息的方法 3. 自訂例外 4. 例外處裡注意 5. Exception 與 Override 6. 例外處裡範例 7. 例外類型多重捕捉 8. 改良重新拋出例外的類型檢查 1. throw 關鍵字 可使用 throw 關鍵字,將方法內的例外手動丟出 throw 的指令格式: throw 「一個可被丟出的物件」 該物件必須是 java.lang.Throwable 類別的子類別，即表示所有狀態異常的方法都可以用 Throwable 中的功能 throw 使用時機 對方法設計時參數資料的檢查，有問題即可自行產生例外丟出，強制結束該方法的執行 搭配自訂例外的產生丟出 package ch01; public class TestThrowDemo { // ArithmeticException 分母為 0 時的狀態異常 public static double method(double i, double j) throws ArithmeticException { double result; if (j == 0) { /* * 1. 指定發生原因說明 ArithmeticException(自訂錯誤信息) * ArithmeticException ae = new ArithmeticException(\"喂! 除到0 ! 算數錯誤!\"); * 2. 有問題就在這直接拋出異常 * throw ae; * 以上方法就是下述步驟的完整版: */ throw new ArithmeticException(\"喂! 除到0 ! 算數錯誤!\"); } result = i / j; return result; } public static void main(String[] args) { try { System.out.println(method(1, 0)); } catch (ArithmeticException e) { // e 例外物件名 /* * e.getMessage() 可以取得自訂錯誤提示信息，但程式會繼續執行 * e.printStackTrace() 可以得到完整錯誤信息與錯誤方法、錯誤行數，並強制結束該方法的執行(Debuger時推薦) */ e.printStackTrace(); } } } java.lang.ArithmeticException: 喂! 除到0 ! 算數錯誤! at ch01.TestThrowDemo.method(TestThrowDemo.java:8) at ch01.TestThrowDemo.main(TestThrowDemo.java:18) 錯誤信息查看是由下而上查看 main > method 2. 取得錯誤訊息的方法 printStackTrace() 大推，開發階段的神兵利器 p.204 取得錯誤訊息的方法 說明 String getMessage() Returns the detail message string of this throwable void printStackTrace() Prints this throwable and it's backtrace to the standard error stream void printStackTrace (PrintStream s) Prints this throwable and it's backtrace to the specified print stream 至指定的輸出設備 String toString() Returns a short description of this throwable 簡短描述 3. 自訂例外 一定得繼承 Throwable 或以下兩種 一定要處裡的例外就繼承 Exception 不一定要處裡的例外就繼承 RuntimeException 自訂的例外類別通常會包含兩個建構子 public 建構子名稱(){} public 建構子名稱(String message){ super(message); } 4. 例外處裡注意 例外處裡不能為空，否則不會提示相關錯誤信息 try { Cube cu = new Cube(length); System.out.println(cu.getVolume()); } catch (CubeException e) { } 5. Exception 與 Override 子類別覆寫其父類別定義有throws方法時，子類別所 throws 的 Exception 必須與父類別被覆寫方法的 Exception 一樣或更低階(子類別例外) 例外只能越丟越小 (參考分享資料夾 codes > exceptions > SmartPhone.java + IPhone.java + Test.java) public class BaseClass { // try IOException public void method() throws IOException { } } public class OK_A extends BaseClass { // true 例外能跟父類別相同 public void method() throws IOException { } } public class OK_B extends BaseClass { // true 不會有例外產生所以也不需要例外處裡 public void method() { } } public class NG_C extends BaseClass { // error 只能越丟越小 public void method() throws Exception { } } 6. 例外處裡範例 1 2 因為只要執行就拋出 所以會執行異常 package ch01; public class ExceptionFlow2 { public static void main(String[] args) { try { method(); } catch (Exception e) { System.out.println(\"3 - Exception handling in main()\"); } } public static void method() throws Exception { try { System.out.println(\"1 - in method()\"); // 步驟1 throw new Exception(); } catch (Exception e) { System.out.println(\"2 - Exception handling in method()\"); } } } 1 3 拋出的例外可以自己解決 就會自己解決 不行解決就會拋出 package ch01; public class ExceptionFlow2 { public static void main(String[] args) { try { method(); } catch (Exception e) { // 步驟3: Exception 可以解決 Exception 的例外，問題解決 System.out.println(\"3 - Exception handling in main()\"); } } public static void method() throws Exception { try { // 步驟1: 執行結果 System.out.println(\"1 - in method()\"); // 步驟2: 拋出例外 throw new Exception(); } catch (RuntimeException e) { // 步驟3: RuntimeException 無法解決 Exception(爸爸) 的例外，所以不會進入拋出 System.out.println(\"2 - Exception handling in method()\"); } } } 1 2 3 錯誤可以連續拋出 package ch01; public class ExceptionFlow2 { public static void main(String[] args) { try { method(); } catch (Exception e) { // 步驟5: 接住例外並執行結果，例外結束 System.out.println(\"3 - Exception handling in main()\"); } } public static void method() throws Exception { try { // 步驟1: 執行結果 System.out.println(\"1 - in method()\"); // 步驟2: 拋出例外 throw new Exception(); } catch (Exception e) { // 步驟3: 執行結果 System.out.println(\"2 - Exception handling in method()\"); // 步驟4: 拋出例外 throw e; } } } 7. 例外類型多重捕捉 Java7 開始一個 catch()中可以處裡多個例外，例如: catch(Exction a | Excetion b) catch 括號內的例外類型不能有繼承關係 static class ExceptionA extends Exception {} static class ExceptionB extends Exception {} static class ExceptionC extends ExceptionB {} // 編譯失敗，catch括號內的例外類型不可有繼承關係 try { methodA(\"A\"); methodB(\"B\"); methodC(\"C\"); // C 繼承 B，B > C B就會先處理。而且因為這樣的問題所以JAVA7這方法會處理這個問題 } catch (ExceptionA | ExceptionB | ExceptionC e) { e.printStackTrace(); } 適合對各種不同例外(沒繼承關係)作相同處裡的動作 做不同處裡，但這樣撰寫不會增加效率建議正常寫 try catch 就好 try{ methodA(\"A\"); methodB(\"B\"); } catch (ExceptionA | ExceptionB) { if(e instanceof ExceptionA){ ExceptionA 的處裡... } if(e instanceof ExceptionB){ ExceptionB 的處裡... } } 8. 改良重新拋出例外的類型檢查 JAVA7 以前，只能指定一個例外型別 public static void methodA(String name) throws ExceptionA {} JAVA7 後編譯器可以更精確地分析需重新拋出的例外類型,在方法宣告的 throws 子句中 可以 指定更多明確的例外型別(不用另外寫說明書或原碼才能知道例外處裡有哪些) public static void methodA(String name) throws ExceptionA,ExceptionB {} "},"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-3.例外練習.html":{"url":"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-3.例外練習.html","title":"14-3.例外練習","keywords":"","body":"目錄 1. 例外作法 1. 例外作法 自訂例外方法 package section2_Q1; public class CubeException extends Exception { public CubeException() { } public CubeException(String message) { super(message); } } 設定例外處裡 package section2_Q1; public class Cube { private double length; public Cube() { } // 因為呼叫的方法有丟例外，所以建構子也要針對方法可能發生的例外做處理 public Cube(double length) throws CubeException { setLength(length); } public double getLength() { return length; } public void setLength(double length) throws CubeException { if (length > 0) this.length = length; else throw new CubeException(\"不能為0或負數\"); } public double getVolume() { return Math.pow(length, 3); } } 實現功能 package section2_Q1; import java.util.Scanner; public class CubeTest { public static void main(String[] args) throws CubeException { while (true) { Scanner sc = new Scanner(System.in); if (!sc.hasNextDouble()) throw new CubeException(\"不能為文字\"); double length = sc.nextDouble(); // 直接傳建構子 try { Cube cu = new Cube(length); System.out.println(cu.getVolume()); } catch (CubeException e) { e.printStackTrace(); } // 使用方法 try { Cube cu = new Cube(); cu.setLength(length); System.out.println(cu.getVolume()); } catch (CubeException e) { e.printStackTrace(); } } } } 用例外來設定方法的原因是 可能會有利外發生，所以會更小心的處理例外 用 java 提供的例外處裡也會 讓使用時更彈性 "},"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-4.Assertions.html":{"url":"3.JAVA/03.JAVA套件與進階/14.例外處裡/14-4.Assertions.html","title":"14-4.Assertions","keywords":"","body":"目錄 1. Assertions 2. Eclipse 啟動 Assertions 驗證 1. Assertions 什麼是 Assertions (測試階段的工具) 用來維護程式使之更堅固(robust)，0 錯誤 Assertions 通常用來檢查一些關鍵的值，避免這些值有錯誤時讓程式無法繼續執行 Assertion 語法 assert 當bollean_expression(布林判斷)為 false 時會丟出 AssertionError 程式當即中斷 assert : ; (更常用，因為後續能添加運算式) 當 boolean_expression 為 false 時，會執行後面的運算式，最常用為字串，以說明錯誤的原因 如: assert obj != null : \"這物件不得為 null\"; 如: assert k != 0:\"k 值不得為 0\"; 範例程式: JavaEx_Part2 > ch01 > TestAssertion.java 執行(預設 assert 功能是關閉的) 執行時添加 -ea java -ea TestAssertion 這樣例外處裡的程式可以不用刪除，需要時在啟動就好 2. Eclipse 啟動 Assertions 驗證 Run > Run Configurations... > Arguments > VM arguments > -ea "},"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-1.File類別.html":{"url":"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-1.File類別.html","title":"15-1.File 類別","keywords":"","body":"目錄 1. File 類別 2. File 常用方法 3. 路徑示意圖 4. 資料流處裡觀念 5. 資料流類別 6. 輸入父類別 7. 輸出父類別 1. File 類別 java.io.File (io，I/O，Input/Output) 類別: File 這個類別為檔案及目錄(資料夾 directory)提供了對應的 Java 物件 可以用此類別來建立、移除檔案、修改、取得...等 使用 File 建構子時: 並未實際在檔案系統中建立檔案 也未讀寫或修改該檔案內容 該檔案可以已經存在或事後才建立 建構子: public File(String pathname) File myDir = new File(\"C:\\\\myDir\"); File myFile = new File(\"C:\\\\myDir\\\\myFile.txt\"); public File(String parent， String child) File myFile = new File(\"C:\\\\myDir\"， \"myFile.txt\"); public File(File parent， String child) File myDir = new File(\"C:\\\\myDir\"); File myFile = new File(myDir， \"myFile.txt\"); 以上檔案路徑內的 \\\\\\\\ 也可以使用 / 取代，路徑問題主要是為了 windows 路徑做處理 2. File 常用方法 範例程式: JavaEx_Part2 > ch02 > TestDir.java (取得資料夾與檔名) 範例程式: JavaEx_Part2 > ch02 > TestFile.java (取得檔案) 檔案存取受系統權限限制 方法 說明 boolean exists() 如果是檔案或目錄存在就回傳 true，沒有就 false boolean isFile() 如果是檔案就回傳 true，不是就 false boolean isDirectory() 如果是目錄就回傳 true，不是就 false String[] list() 包含 File 所描述的所有檔案與目錄的名稱，回傳字串陣列(對資料夾操作有效) File[] listFiles() 包含 File 所描述的所有檔案與目錄的 File 物件，回傳 File 物件陣列 String getAbsolutePath() 回傳檔案或目錄的絕對路徑 String getPath() 回傳檔案或目錄的相對路徑(獲得建構該 file 物件時的路徑) String getParent() 回傳包含 File 的目錄名稱(取得前置路徑) String getName() 回傳檔案或目錄的名稱，所得名稱是路徑最後一個名稱 (C:\\MyLib\\ test.java 或 C:\\ MyLib) long length() 回傳檔案的長度(檔案的資料大小 Bytes) boolean canRead() 判斷檔案是否可被讀取 boolean canWrite() 判斷檔案是否可以覆寫(修改) boolean setReadOnly() 設定檔案為唯讀 long lastModified() 傳回檔案最後一次的修改時間(時間戳) ，使用 new Date(file.lastModified()) 方式轉換 boolean delete() 刪除 檔案或目錄，並返回 true 或 false (資料直接從檔案系統中移除) (空資料夾才能刪) boolean renameTo(File dest) 更改名稱兼移動到指定的路徑 boolean mkdir() 建立一個新資料夾File file = new File(\"C:\\dir\");file.mkdir(); boolean mkdirs() 建立多層資料夾File file = new File(\"C:\\dir2\\dir1\");file.mkdirs(); boolean createNewFile() throws IOException 建立新(空)檔案(checked exception) 3. 路徑示意圖 絕對路徑: 從根目錄開始 Windows 系統路徑 C:\\ 或 D:\\ Mac 或 Linux 系統路徑 \\ 相對路徑: . 表示當前路徑，.. 表示上一層路徑 4. 資料流處裡觀念 資料流概念 輸入 Input Read 輸出 Output Write 程式透過資料流(Stream)讀取一連串資料，來源可以是檔案、記憶體或是網路 輸出: 讓資料像水流一樣流入(源頭) 程式也可以透過資料流(Stream)將資料寫出到目的地，同樣可以是檔案、記憶體或是網路 輸入: 將資料流出送到(盡頭) 5. 資料流類別 InputStrean / OutputStream 及 Reader / Writer Java 資料流類別內建於四個抽象父類別 循序讀寫(從檔案開頭開始) 為 一次性使用，無法重複使用 InputStrean / OutputStream 行資料流 任何資料都可以處裡，因為對電腦來說所有資料都是位元 存取是以 8 bits 為基礎的 byte，處裡中文有困難 (會有亂碼產生) Reader / Writer 型資料流 存取是以 16 bits 為基礎的 char 來處理 Unicode Unicode 一個字元是用 16 bits (2 bytes) 儲存的 Reader / Writer 有用就要在用完後關閉/釋放資源 *.close() 範例程式: JavaEx_Part2 > ch02 > CopyBytes.java (檔案輸入輸出) 範例程式: JavaEx_Part2 > ch02 > Copy.java (檔案輸入輸出 Unicode，含中文處裡) 6. 輸入父類別 InputStream int read() 回傳值為檔案裡下一個 byte 資料，如回傳 -1 代表已到檔尾(沒資料了) 7. 輸出父類別 OutputStream void write(int b) 將 b 的位元組(byte)資料寫至目的地 void write(byte[] buf) 將陣列 buf 裡所有的位元組(byte)資料寫至目的地 void write(byte[] buf, int offset, int length) 將陣列 buf 中從 offset 位置開始的 length 個位元組(byte)資料寫至目的地 "},"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-2.資料流類別.html":{"url":"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-2.資料流類別.html","title":"15-2.資料流類別","keywords":"","body":"目錄 1. I/O 運用時機 2. InputStream / OutputStream 資料流 3. BufferedInputStream 4. 讀入程式片段 5. 寫出程式片段 6. 高低接管連接方式 7. 使用最頻繁的讀取方式 readLine() 8. Reader / Writer 資料流 9. 爬蟲的開始 10. I/O Stream 與 Reader / Writer 11. Google Map Api 調用方法 12. CSV 讀取方法 13. 輸入文字用法 1. I/O 運用時機 Reader / Writer 專門處理文字 InputStrean / OutputStream 網路資料傳輸(會有各種不同格式)(ex. 影像傳輸...) 2. InputStream / OutputStream 資料流 低階 I/O: 節點資料流(Node Stream) 高階 I/O: 處裡(加工)資料流(Procressing Stream) 負責與媒體資料做存取(跟資料源頭或目的地相接使用) 水管串接的工作 I/O 鍊(I/O Chain) 建立一個 I/O 前要 先 用 低階 I/O 類 來存取資料(如檔案) 之後 再 用高階 I/O 來控制低階 I/O 類別 的動作 此層層架構稱之為 I/O 鍊 (I/O Chain) 高階 I/O 類別可再與其它高階 I/O 類別連結 輸入 類的資料流 只能 與 輸入 類的類別相連接 輸出 類的資料流 只能 與 輸出 類的類別相連接 3. BufferedInputStream 生活化例子 有 10 箱東西要從貨車上運往倉庫，運送方法有兩種 一次運送 1 個，送 10 次 用推車一次運送 5 個，送 2 次 Buffer 緩衝，就像運送的小推車，有了小推車後運送次數可以少很多又快 緩衝(記憶體空間)，為了減少硬體執行次數而做的機制 BufferedInputStream ，Java 提供的具有緩衝區功能的類，8kb 緩衝大小，滿了 8kb 就送資料 (後續能夠自訂緩衝) 4. 讀入程式片段 // 建立一個檔案輸入流 FileInputStream fis = new FileInputStream(\"讀入檔案名\"); // 建立一個高階 I/O 物件 BufferedInputStream bis, 並連結至 fis,將 fis 放到緩衝區 BufferedInputStream bis = new BufferedInputStream(fis); // 從緩衝區讀取資料,以減少 CPU 的 I/O 時間 bis.read(); 資源關閉(close)順序: 越晚建立的資料越早關閉 源頭(FileInputStream) → 程式(BufferedInputStream) 5. 寫出程式片段 // 低接管 FileOutputStream fos = new FileOutputStream(\"寫出檔案名\"); // 高階管 BufferedOutputStream bos = new BufferedOutputStream(fos); // 高階管 PrintStream ps = new PrintStream(bos); // 使用後文字覆寫入檔案中 原檔案資料將被覆寫(覆蓋) ps.println(\"Hello World\"); ps.close(); bos.close(); fos.close(); 程式(PrintStream) → (BufferedOutputStream) → 盡頭(目的地)(FileOutputStream) 範例程式: /JavaEx_Part2/src/ch02/FileInputStreamReadFile.java 6. 高低接管連接方式 // 低階管 建立 FileInputStream fis = new FileInputStream(\"c:\\\\javawork\\\\hello.txt\"); // 高階管 接入 資料放入緩衝區加速 BufferedInputStream bis = new BufferedInputStream(fis); // 使用管道 while ((i = bis.read()) != -1) { System.out.print((char) i); } // bis 先建立，先關閉(資源)。就像衣服穿很多層越晚穿上的衣服越早脫 bis.close(); fis.close(); 範例程式: /JavaEx_Part2/src/ch02/FileReaderReadFile.java 7. 使用最頻繁的讀取方式 readLine() String str; FileReader fr = new FileReader(\"c:\\\\javawork\\\\hello.txt\"); BufferedReader br = new BufferedReader(fr) ; while ((str = br.readLine()) != null) System.out.println(str); br.close(); fr.close(); 8. Reader / Writer 資料流 與 I/O Stream 不同則在於 Reader / Writer 是專門用於 Unicode 的字元處理 其他使用方式相同 // 建立一個檔案輸入流 FileReader fr = new FileReader(\"讀入檔案名\"); // 建立一個高階I/O物件BufferedReader br, 並連結至fr,將fr放到緩衝區 BufferedReader br = new BufferedReader(fr); // 從緩衝區讀取資料,以減少CPU的I/O時間 br.readLine(); // 如果沒有檔案則會直接創建 FileWriter fw = new FileWriter(\"寫出檔案名\"); BufferedWriter bw = new BufferedWriter(fw); PrintWriter pw = new PrintWriter(bw); pw.println(\"Hello World\"); pw.close(); bw.close(); fw.close(); 範例程式: /JavaEx_Part2/src/ch02/PrintWriterWriteFile.java 9. 爬蟲的開始 網址 代表一個資源在網路上所帶表的位置 爬蟲主要針對指定頁面撰寫，因為有指定頁面結構(因為每個頁面結構都不同)[1] package ch02; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class GetNatalieFromInternet { public static void main(String[] args) { File dir = new File(\"C:\\\\Pictures\"); // 資料夾不存在 if (!dir.exists()) { // 創建資料夾 dir.mkdir(); } // 目的: 取得42張圖片 for (int i = 1; i 範例程式: 抓取妮可波曼 GetNatalieFromInternet 10. I/O Stream 與 Reader / Writer 網路 I/O 與 Console I/O 因為網路 I/O 與 Console I/O 是以 byte[]為基礎的 I/O, 所以 Reader / Writer 不能夠直接存取網路 I/O 與 Console I/O System.in、System.out、System.err 三個不同資料流 不需經 new 宣告即可使用(見下一頁) System.in: 標準 輸入 資料流 System.out: 標準 輸出 資料流 (display，輸出至螢幕) System.err: 標準 錯誤輸出 資料流 (display，輸出至螢幕並顯示紅色) InputStreamReader 類別 An InputStreamReader is a bridge from byte streams to character streams 使用此類別後文字能正常顯示，但有時仍須用此方法轉碼 一般用法: InputStreamReader isr = new InputStreamReader(doc); 轉碼 的原因是 Windows 的編碼格式是 MS950(中文編碼為 Big5，windows 系統建立之初還沒有 Unicode 的規範，所以每種語言都有獨自的編碼格式) 轉碼用法: InputStreamReader isr = new InputStreamReader(doc,\"MS950\"); OutputStreamWriter 類別 An OutputStreamWriter is a bridge from character streams to byte InputStreamReader 與 OutputStreamWriter 可以想像為是 轉接頭 11. Google Map Api 調用方法 package xxx; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class GetGooglePlaceTest { private static final String GOOGLE_URL = \"https://maps.googleapis.com/maps/api/place/nearbysearch/json?\" + \"location=24.95375,121.22575&\" + \"radius=500&\" + \"types=food&\" + \"name=吃到飽&\" + \"language=zh-TW&\" + \"key=AIzaSyAYmC8oUYc9DGAZn8hqZKakFeclhAbTRSI\"; public static void main(String[] args) throws IOException { URL url = new URL(GOOGLE_URL); HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.setRequestMethod(\"GET\"); con.setUseCaches(false); int statusCode = con.getResponseCode(); System.out.println(statusCode); InputStream is = con.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String data; while ((data = br.readLine()) != null) { System.out.println(data); } br.close(); isr.close(); is.close(); } } 範例程式: 抓取 googleMapApi 並轉成文字 GetGooglePlaceTest 12. CSV 讀取方法 import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; public class CSVTest { public static void main(String[] args) throws IOException { File file = new File(\"C:\\\\javawork\\\\student.csv\"); // (不建議) // 2. 直接更改Java環境的編碼設定 (windows -> preferences -> General -> Workspace -> Text file encoding) FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); String str; while ((str = br.readLine()) != null) System.out.println(str); br.close(); fr.close(); // (建議用) // 1. 先以位元資料讀取進來, 在程式裡做轉換並指定正確的編碼 FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis, \"MS950\"); BufferedReader br = new BufferedReader(isr); String str; while ((str = br.readLine()) != null) System.out.println(str); br.close(); isr.close(); fis.close(); } } 範例程式: 取得 csv 資料 CSVTest 13. 輸入文字用法 沒用 Scanner 前使用此方法，現在是 Scanner 好用喔 package ch02; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class InputFromKeyboard { public static void main(String args[]) { System.out.println(\"請輸入資料....\"); // 步驟一 InputStreamReader isr = new InputStreamReader(System.in); // 步驟二 BufferedReader br = new BufferedReader(isr); try { // 步驟三 String data = br.readLine(); System.out.println(data); } catch (IOException e) { e.printStackTrace(); } } } 範例程式: /JavaEx_Part2/src/ch02/InputFromKeyboard.java http 與 https 處裡 ↩︎ "},"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-3.其它特殊方法與功能補充.html":{"url":"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-3.其它特殊方法與功能補充.html","title":"15-3.其它特殊方法與功能補充","keywords":"","body":"目錄 1. 源頭資料大小 1. 源頭資料大小 抽象父類別 InputStream 類別提供 int available() 方法，以取得輸入資料流的資料大小(number of bytes) (File 物件使用 length() 得到資料大小與結果) BufferedReader 提供 String readLine() 方法，可一次讀取一行資料 BufferedWriter 提供 void newLine() 方法，可加入新的一個分行 建構子 FileOutputStream(String name， boolean append) 與建構子 FileWriter(String fileName， boolean append) 當 append = false 時，新增的資料將覆蓋/取代原始資料(預設為 false) 用法 FileOutputStream(file,false) 相等於 FileOutputStream(file) 表示輸出時覆蓋檔案 當 append = true 時，新增的資料將附加於原始資料之後 用法 FileOutputStream(file,true) package ch02; import java.io.BufferedOutputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.PrintStream; public class PrintStreamWriteFile { public static void main(String args[]) { try { // 資料附加於原始資料後 FileOutputStream fos = new FileOutputStream(\"c:\\\\javawork\\\\hello.txt\", true); BufferedOutputStream bos = new BufferedOutputStream(fos); PrintStream ps = new PrintStream(bos); ps.println(\"Hello World 世界你好 !\"); ps.close(); bos.close(); fos.close(); } catch (IOException e) { System.err.println(e); } } } 範例程式: /JavaEx_Part2/src/ch02/PrintStreamWriteFile.java "},"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-4.物件的輸入輸出.html":{"url":"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-4.物件的輸入輸出.html","title":"15-4.物件的輸入輸出","keywords":"","body":"目錄 1. 物件的輸入與輸出 2. 將物件寫出與讀入的建構子 3. 序列化實作 1. 物件的輸入與輸出 將物件寫出與讀入 寫出物件: 使用 ObjectOutputStream 類別寫出物件 讀入物件: 使用 ObjectInputStream 類別讀入物件 java.io.Serializable(空介面)[1]: 物件是動態產生的，欲將物件永久儲存[2]時，稱做 persistence 欲將某物件[3]的資料儲存(寫出)到 OutputStream(檔案或 socket[4])時，該物件必須實作 Serializable[5] 空介面 序列化過程: 物件可能很大，這樣資料無法通過傳輸，所以要通過序列化的方式將物件拆解成更小的資料單位，這樣才能通過硬體傳輸上的限制至 序列化與反序列化過程生活化用例: 買了家具後會被拆成一小塊一小塊的小物件(序列化)才能裝進紙箱裡面，到收貨的時候將小物件裝回成家具(反序列化)，反序列化時也要看物件的說明書(設計圖)即看類別 序列化是分散式運算的基礎 (分散式運算主要在大數據班的部分會做到相關操作) 宣告為 transient 與 static 的資料成員不會被序列化 如果某資料成員不想被 serialized，程式設計者可以自行(主動)加上 transient 修飾子 因為宣告為 static 的變數與方法，不是由任何此類別的物件單獨擁有，而是由屬於此類別所有物件共同擁有 2. 將物件寫出與讀入的建構子 將物件寫出與讀入的建構子 寫出: ObjectOutputStream(OutputStream out) throws IOException 讀入: ObjectInputStream(InputStream in) throws IOException 建構子參數要求再放別的水管，其實代表此類別為我們稱的高階 I/O InputStream in 跟 OutputStream out 就是一種放入別的管子的動作 將物件寫出與讀入的方法 寫出: void writeObject(Object obj) throws IOException Object 是為了多型 讀入: Object readObject() throws IOException，ClassNotFoundException 物件結構需存在，即 classpath 可以找到就好 物件讀入注意事項 物件讀入順序必須與物件寫出順序相同 Object readObject() 的回傳型態為 Object，必須自行強迫轉型為原來寫出時的物件型態 3. 序列化實作 序列化了 10 個物件，分別是 Book 中的 兩個 String 物件和 Integer 物件，與添加的兩個 Book 物件 序列化的物件需連物件類別中的資料都可序列化，才可執行成功 static[6] 與 transient 都可以讓物件不被序列化 private static double price; private transient double price; 使用 transient 的話不會被序列化，但仍是實體變數 使用 static 的話變成類別的東西，所以不會被序列化 package ch02; import java.io.EOFException; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; // 要將物件寫入文件中，要序列化 // 有序列化，Java就會在當下class中添加 serialVersionUID(UID) 即說明書版本不對 // 用意是怕資料被竄改，所以需要來源確認 class Book implements Serializable { // 自訂UID且須設定為 final，使值無法被JAVA更動 // 對反序列化的相容性增加，對應版本更動造成[反序列化]不相容的情形 private static final long serialVersionUID = 8315449942815314809L; // 如果加上 transient ，該屬性不會加入序列化 private String name; private double price; private Integer quantity; private String author; // 有定義 serialVersionUID 才可自行增減需序列化的Class的內容 public Book(String name, double price, String author, Integer quantity) { this.name = name; this.price = price; this.author = author; this.quantity = quantity; } public void show() { System.out.println(\"書名: \" + name); System.out.println(\"定價: \" + price); System.out.println(\"作者: \" + author); System.out.println(\"數量: \" + quantity); } } public class TestObjectInOut { public static void main(String[] args) throws Exception { File file = new File(\"bookInfo\"); // 輸出 // ------------------------------------------------------- // 實體化物件陣列 Book[] books = new Book[2]; // 添加書本 books[0] = new Book(\"Java程式設計\", 580.0, \"張搧風\", 10); books[1] = new Book(\"JSP程式設計\", 650.0, \"黃會紅\", 12); FileOutputStream fos = new FileOutputStream(file); ObjectOutputStream oos = new ObjectOutputStream(fos); for (int i = 0; i 範例程式: /JavaEx_Part2/src/ch02/TestObjectInOut.java Java 類別預設是不實作 Serializable 介面的 ↩︎ JAVA 中永久儲存又稱作永續或 persistence ↩︎ 資料匯流排又名 data bus ↩︎ 記憶體本身是一種暫存機制 ↩︎ Java 類別實作 Serializable 介面後，其子類別將會自動實作 Serializable 介面 ↩︎ static 資料都被共享共用 ↩︎ "},"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-5.Java的節點資料流.html":{"url":"3.JAVA/03.JAVA套件與進階/15.資料輸入與輸出/15-5.Java的節點資料流.html","title":"15-5.Java 的節點資料流","keywords":"","body":"目錄 1. Java 的節點資料流 2. 節點資料流總結 1. Java 的節點資料流 負責位元資料的輸入/輸出工作 灰底為Data Sink，即低階 I/O Writer FileInputStream PipedInputStream FilterInputStream LineNumberInputStream DataInputStream BufferedInputStream PushbackInputStream ByteArrayInputStream SequenceInputStream StringBufferInputStream ObjectInputStream OutputStream FileOutputStream PipedOutputStream FilterOutputStream DataOutputStream BufferedOutputStrean PrintStream ByteArrayOutputStream ObjectOutputStream Sink類型 字元資料流Character Streams 位元資料流Byte Streams 記憶體Memory 陣列Array CharArrayReader,CharArrayWriter ByteArrayInputStream,ByteArrayOutputStream  字串String StringReader,StringWriter N/A 管線Pipe PipedReader,PipedWriter PipedInputStream,PipedOutputStream 檔案File FileReader,FileWriter FileInputStream,FileOutputStream 負責字元資料的輸入/輸出工作 灰底為Data Sink，即低階 I/O Reader BufferedReader LineNumberReader CharArrayReader InputStreamReader FileReader FilterReader PushbackReader PiepedReader StringReader Writer BufferedWriter CharArrayWriter OutputStreamOuter FileWriter FilterWriter PipedWriter StringWriter FilterWriter 處理動作Process 字元資料流Character Streams 位元資料流Byte Streams 緩衝 Buffering BufferedReader,BufferedWriter BufferedInputStream, BufferedOutputStream 過濾 Filtering FilterReader, FilterWriter FilterInputStream, FilterOutputStream Converting between Bytes and Characters InputStreamReader, OutputStreamWriter   串接 Concatenation   SequenceInputStream 物件序列化 Object Serialization   ObjectInputStream, ObjectOutputStream 資料轉換 Data Conversion   DataInputStream, DataOutputStream 計數 Counting LineNumberReader LineNumberInputStream 向前窺視 Peeking Ahead PushbackReader PushbackInputStream 列印 Printing PrintWriter PrintStream 2. 節點資料流總結 Java 的資料流支援方式,功能強大又具自定的彈性 事實上,關於 I/O 方面的討論可以寫成一本書 一個無限制的鍊結機制讓你可混合一些類別來達成任何想要的 I/O 功能 可產生一些自己加強的資料類別,以便在一個輸入鍊或輸出鍊其中的任何地方做插入 I/O 奠定將來網路程式設計的基礎 物件永續性與序列化觀念奠定將來 RMI (遠端方法呼叫 – Remote Method Invocation)分散式運算基礎 "},"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-1.集合與陣列.html":{"url":"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-1.集合與陣列.html","title":"16-1.集合與陣列","keywords":"","body":"目錄 1. JDK5 2. 集合與陣列的比較 3. 認識物件 4. 集合架構 5. 集合常用方法 6. 如何取得集合中的元素 7. ArrayList 範例 8. HashSet 範例 9. 課堂作業 1. JDK5 JDK5 開始增加了很多功能，也新增了 foreach 的功能 foreach 也是 JDK5 的 suger 2. 集合與陣列的比較 集合與陣列比較   集合 陣列 空間大小 建立時不必指定集合大小,無論將元素存入或移除,集合都會動態調整空間以符合需求;這是集合最大優點 建立時就必須指定陣列大小,而且之後無法改變。元素存取時,不可超過索引上限,否則會產生ArrayIndexOutOfBoundsException 資料類型 可存放任何物件,但若存放基本類型,會先AutoBoxing(y自動裝箱)成對應的物件後再存放。放入的物件還會自動轉型成Object類型,但若搭配泛型功能就可像陣列般限制元素的資料類型 可存放物件或基本類型,但必須符合陣列所宣告的資料類型 資料存取 要將元素取出,可使用1. for-each2. Iterator(迭代器) 要將元素取出,可使用1. for迴圈搭配索引2. for-each 3. 認識物件 認識集合物件 集合物件是指一群相關聯的資料,集合在一起組成一個物件 集合物件裡面的資料,稱之為元素(element) 從 JDK1.2 開始,Java 的集合物件以 Collection 介面與 Map 介面分作兩大類 Collection 介面 可持有各自獨立的物件 Map 介面 持有成對的 key-value 物件 Collection 介面最重要的兩個子介面(背起來，面試必考這兩項) 子介面 Set 無特定順序,不允許重複(重複時不加入) HashSet 類別實作 Set 介面 子介面 List 有特定順序,允許重複 ArrayList[1] 類別實作 List 介面 4. 集合架構 java.util.Collection 介面是整個集合架構的根介面 有底線的代表類別 沒底線的是介面 Iterable Collection set SortedSet TreeSet HashSet list ArrayList Vector LinkedList Queue LinkedList PriorityQueue LinkedList 同時實作 list 與 Queue 兩個介面 以下兩個特別重要(面試必考) set list queue(佇列，排隊)也重要只是大多數人說不到就沒時間了 5. 集合常用方法 size() 就像一維陣列的 length toArray() 也可轉為 object 陣列(因為已被自動晉升為 Object 型別) 與傳統陣列相比，集合變成用方法來處理各種元素的存取 >Collection boolean add (E obj) 指定物件新增至集合內 void clear() 將集合內所有元素清空 boolean isEmpty() 檢查集合是否為空容器 Iterator iterator() 取得iterator物件走訪集合內所有元素 boolean remove(Object obj) 將指定元素從集合中移除 int size() 回傳集合內的元素總數 boolean contains (Object obj) 檢查集合內是否有指定元素 Object[] toArray() 將集合內元素轉存為陣列 >List void add(int index, E element)boolean add(E element) 指定物件新增至集合指定索引內指定物件新增至集合內 E get(int index) 取得指定索引的元素 E set(int index, E element) 指定物件取代集合指定索引的元素 6. 如何取得集合中的元素 如何取得集合裡的元素 Collection 介面提供 iterator() 方法,回傳 Iterator 介面 public Iterator iterator() 利用此方法,可把位在 collection 裡的所有元素,轉換成可進行迭代的迭代器(Iterator) 迭代器的使用維一次性 關於元素傳回的順序是沒有任何保證的 (除非此 collection 是某個能提供保證順序的類別實體) 所以在此就會用到了 java 本身提供的迭代器，以保證資料的順序姓 Iterator 介面 (稱為迭代器介面,JDK1.2 開始) 此介面被用來擷取 collection 集合裡的所有元素(也包含了其子介面 Set 與 List) public boolean hasNext() public Object next() Iterator(迭代器)介面是為了取代 JDK1.0 的 Enumeration(列舉)介面 hasNext 可以想像摸彩箱抽獎時，喊下一個~ 7. ArrayList 範例 範例程式: \"/JavaEx_Part2/src/ch03/TestArrayList.java\" package ch03; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class TestArrayList { public static void main(String[] args) { List list = new ArrayList(); list.add(new Integer(12)); list.add(new Long(34L)); list.add(new Double(5.6)); list.add(\"Hello\"); list.add(\"Hello\"); // 值重覆仍加入到集合裡 System.out.println(\"toString()=\" + list); // 已經對toString改寫過了 System.out.println(\"元素個數=\" + list.size()); Iterator objs = list.iterator(); while (objs.hasNext()) System.out.println(objs.next()); // List家族可以用Iterator(迭代器)或for迴圈取值 System.out.println(); for (int i = 0; i 8. HashSet 範例 只要用了 set，Java 官方就不保證資料存取時的順序性 package ch03; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class TestHashSet { public static void main(String[] args) { Set set = new HashSet(); set.add(new Integer(12)); set.add(new Long(34L)); set.add(new Double(5.6)); set.add(\"Hello\"); set.add(\"Hello\"); // 值重覆不會加入 System.out.println(\"toString()=\" + set); System.out.println(\"元素個數=\" + set.size()); // Set家族只能用 Iterator 取值 Iterator objs = set.iterator(); while (objs.hasNext()) System.out.println(objs.next()); } } 9. 課堂作業 範例程式: \"/JavaEx_Part2/src/ch03/TestHashSet.java\" import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class class1 { public static void main(String[] args) { Set set = new HashSet(); while (set.size() it = set.iterator(); while (it.hasNext()) { System.out.print(it.next() + \"\\t\"); } } } ArrayList，又稱作動態陣列 ↩︎ "},"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-2.Map介面.html":{"url":"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-2.Map介面.html","title":"16-2.Map 介面","keywords":"","body":"目錄 1. Map 介面 2. Map 常用方法 3. HashMap 類別範例 4. Vector 與 Hashtable 類別 5. Vector 範例 6. Hashtable 範例 7. Enumeration 範例 8. Enumeration 介面 9. 必須熟練使用 1. Map 介面 Map(Dictionary) 是一種key/value的集合,每一筆資料皆有一對(對應(映))主鍵值(key)和內含值(value) Hashtable table = new Hashtable(); table.put(\"key\", \"value\"); 若使用相同的主鍵值,則新的資料會取代舊的資料 使用主鍵值尋找內含值,若主鍵值不存在,則會回傳 null HashMap 類別實作 Map 介面 取得 Map 集合中所有的 key,可以使用 keySet(),它會將 Map 裡所包含的所有 key 以 Set 介面的型態回傳 Set keySet() 取得 Map 集合中所有的 value,可以使用 values(),它會將 Map 裡所包含的所有 value 以 Collection 介面的型態回傳 Collection values() Map 是一種key/value的集合,每一筆資料皆有一對主鍵值(key)和內含值(value) Hashtable table = new Hashtable(); table.put(\"key\", \"value\"); 若使用相同的主鍵值,則新的資料會取代舊的資料 使用主鍵值尋找內含值,若主鍵值不存在,則會回傳 null HashMap 類別實作 Map 介面 取得 Map 集合中所有的 key,可以使用 keySet(),它會將 Map 裡所包含的所有 key 以 Set 介面的型態回傳 Set keySet() 取得 Map 集合中所有的 value,可以使用 values(),它會將 Map 裡所包含的所有 value 以 Collection 介面的型態回傳 Collection values() 2. Map 常用方法 因為資料型態是 Object ，所以可以將任何資料做 key 或 value 重複的 key 會將既有 key 值取代 >Map  Object put(Object key, Object value) 將指定的鍵與值放到Map裡 Object get(Object key) 依指定的鍵取得對應的值 Object remove(Object key) 依指定的鍵移除對應的鍵值組 void clear() 清空Map內所有的鍵值組 boolean containsKey(Object key) 檢查Map內是否有指定的鍵 boolean containsValue(Object value) 檢查Map內是否有指定的值 boolean isEmpty() 檢查Map是否為空容器 int size() 回傳Map內的鍵值組總數 Set keySet() 將Map內的所有鍵轉存成Set物件 Collection values() 將Map內的所有值轉存成Collection集合 3. HashMap 類別範例 範例 1 package ch03; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class TestHashMap { public static void main(String[] args) { Map map = new HashMap(); map.put(\"one\", new Integer(1)); map.put(\"two\", \"2\"); map.put(\"three\", new Float(3.0)); System.out.println(map.get(\"one\")); System.out.println(map.get(\"two\")); System.out.println(map.get(\"three\")); // 取出所有的key,包裝為Set的型態 Set set = map.keySet(); Iterator it = set.iterator(); while (it.hasNext()) { Object myKey = it.next(); System.out.println(myKey + \"=\" + map.get(myKey)); } //keySet() 方法來自Map介面, 所以所有Map家族成員都適用此方式取值 } } 範例程式: /JavaEx_Part2/src/ch03/TestHashMap.java 範例 2 package idv.david.additional.iocollection; import static java.lang.System.out; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.HashMap; import java.util.Map; import java.util.Set; import java.util.StringTokenizer; public class DataInputExample { public static void main(String[] args) throws IOException { // Variables declare 宣告變數 int totalAge = 0; double totalHeight = 0.0; double totalWeight = 0.0; int totalPerson = 0; // 設定map Map cities = new HashMap(); // Read data from file 讀取檔案 BufferedReader br = new BufferedReader(new FileReader(\"files/data.txt\")); // Parsing data 設定字串，讀取檔案內容 String data; // 將每行值指定到字串中 while ((data = br.readLine()) != null) { totalPerson++; // 文字切割工具(要處裡的字串,分割符) // Token 字符(處理過的字串) StringTokenizer st = new StringTokenizer(data, \",\"); // hasMoreTokens 返回是否還有分割符 if (st.hasMoreTokens()) { int no = Integer.parseInt(st.nextToken()); String name = st.nextToken(); // 總年齡 totalAge += Integer.parseInt(st.nextToken()); // 總身高 totalHeight += Double.parseDouble(st.nextToken()); // 總重量 totalWeight += Double.parseDouble(st.nextToken()); // 用於返回下一個匹配的字串 String tel = st.nextToken(); // 顯示各個地方有幾個人 String city = st.nextToken(); if (cities.containsKey(city)) { int count = cities.get(city) + 1; cities.put(city, count); } else cities.put(city, 1); } } // Output result out.printf(\"平均 年齡: %d歲%n\", totalAge / totalPerson); out.printf(\"平均 身高: %.2f公分%n\", totalHeight / totalPerson); out.printf(\"平均 體重: %.2f公斤%n\", totalWeight / totalPerson); Set keys = cities.keySet(); for (String city : keys) out.printf(\"住址 %S: %d人%n\", city, cities.get(city)); System.out.println(\"\\n---------測試toString()-----------\"); System.out.println(\"toString()=\" + cities); // 測試toString() } } 範例程式: /JavaEx_Part2/src/idv/david/additional/iocollection/DataInputExample.java 4. Vector 與 Hashtable 類別 Vector 為一可置入「任意物件」的「動態陣列」(可隨內含物自動增減長度) Hashtable 內部是一個「類似表格」的資料結構來儲存資料 Vector 從 JDK1.0 時代就已存在,在 JDK1.2 時,新的 List 介面出現後,Vector 才加入 List 家族,並實作新的方法 Vector 實作了 List Hashtable 從 JDK1.0 時代就已存在,在 JDK1.2 時,新的 Map 介面出現後,Hashtable 才加入 Map 家族,並實作新的方法 Vector 類別等同於 ArrayList 類別,但是 Vector 提供同步化的優點(與負擔),這對多執行緒的存取是很重要的 使用 Vector，裡頭自動包含鎖定(synchronized)的功能，但這會造成效率變低，所以如果不用同步資料並且要快的話，還是使用 ArrayList 就好 Hashtable 類別等同於 HashMap 類別,但是 Hashtable 提供同步化的優點(與負擔),這對多執行緒的存取是很重要的 5. Vector 範例 package ch03; import java.util.*; //Vector 為一可置入\"任意物件\"的\"動態陣列\"(可隨內含物多寡增減其長度) public class TestVector1 { public static void main(String args[]) { // 方法1: 使用舊方法必須用 Vector 宣告 Vector v = new Vector(); v.addElement(new Integer(12)); v.addElement(new Long(34L)); v.addElement(new Float(5.6f)); v.addElement(new Double(7.8)); v.addElement(new String(\"Hello\")); for (int i = 0; i 範例程式: /JavaEx_Part2/src/ch03/TestVector2.java 範例程式: /JavaEx_Part2/src/ch03/TestVector1.java 6. Hashtable 範例 /* 1.Hashtable 內部是一個\"類似表格\"的資料結構來儲存資料, 每一筆資料都有 對應的索引鍵(key) , 這索引鍵是物件的型態 , 但是通常為方便起見, 大 部份的情況都是利用\"字串\"值當做索引鍵(key). 反之當欲取出這筆資料時, 也是利用剛剛所設定的索引鍵值來取出資料 2.欲儲存不同的資料時必需用不同的索引鍵, 否則其索引鍵所對應資料值為最 後儲存的那筆資料 3.Hashtable 的資料也是物件的型態, 所以可以儲存任何形式的資料, 使用者 取出資料的同時, 必須注意該資料的型態而自行作物件資料轉換(casting)的動作. */ package ch03; import java.util.*; public class TestHashtable { public static void main(String args[]) { Hashtable hash = new Hashtable(); hash.put(\"one\", new Integer(1)); hash.put(\"two\", \"2\"); hash.put(\"three\", new Float(3.0)); // 必須型別轉換 Integer oneValue = (Integer) hash.get(\"one\"); String twoValue = (String) hash.get(\"two\"); Float threeValue = (Float) hash.get(\"three\"); System.out.println(oneValue); System.out.println(twoValue); System.out.println(threeValue); } } 範例程式: /JavaEx_Part2/src/ch03/TestHashtable.java 7. Enumeration 範例 JDK1.0 的 Enumeration 介面類似 JDK1.2 的迭代器 Iterator 介面 介面方法 public boolean hasMoreElements() public Object nextElement() 物件實作此介面目的是產生一序列的元素,透過呼叫 nextElement() 方法來取得一個一個接續的元素 nextElement() 所回傳的資料是 Object 的型態,使用者需要做 Casting Hashtable 與 Vector 都有提供方法將其資料置於 Enumeration 物件中,並透過 Enumeration 物件來存取所有的資料 8. Enumeration 介面 System 可有標準輸入/輸出 System.getProperties() 可獲得系統當前屬性 package ch03; import java.util.Enumeration; import java.util.Properties; // Property(屬性) // TestProperties 獲得系統屬性 public class TestProperties { public static void main(String args[]) { Properties props = System.getProperties(); Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String val = props.getProperty(name); System.out.println(\"property of \" + name + \" = \" + val); } } } 9. 必須熟練使用 hashMap hashSet ArrayList 集合比陣列使用更頻繁 參考鏈接: java 字符串分解 StringTokenizer 用法（比 split()方法效率高） java 中 System.getProperty 的用法。 Java 关于 Properties 用法的总结(一) "},"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-3.泛型.html":{"url":"3.JAVA/03.JAVA套件與進階/16.集合與泛型/16-3.泛型.html","title":"16-3.泛型","keywords":"","body":"目錄 1. 泛型(Generic Type) 2. 泛型生活化解釋 3. 泛型(Generic Type)舉例 4. 泛型的延伸，自訂泛型 5. 泛型的進階設定 6. 基本泛型總結 7. Iterable 介面 8. 增強型 for 迴圈 (for – each) 9. Iterable 與 for - each 範例 10. 傳統 for 與 for-each 11. Collection 進一步探討(重點) 12. Collection 延伸範例 13. ArrayList 與 LinkedList 差異 14. 自訂比較器的三種方法 15. 堆疊 1. 泛型(Generic Type) JDK1.5 的泛型設計有以下優點 可預先指定 Collection 中所含的物件類別 泛型的使用 <>，ex. 用來限制集合的使用，限定輸入陣列型別 因此只要不小心加入其它類別的物件,在編譯階段就會出現錯誤,使得原本放在執行階段才會檢查出來的問題,提昇到了編譯時期 避免 runtime 時期的 java.lang.ClassCastException 的錯誤,也因為類別已知,取出資料時可省略型別轉換(Cast)的麻煩(也省去了instanceof檢查的麻煩) 另 Java 使用動態連結技術,並且有共同的 Object 祖先做為最根本的多型 在 JDK1.4 之前,實作 Collection 介面時,我們能夠處理 Object 物件,如 add(Object o)或 remove(Object o)方法 如此雖可讓 Collection 介面變得一般化,但是因為在大部份的實際狀況下,我們放在 Collection 中的物件通常都屬同一個類別,取出時型別為 Object 還得作型別轉換(Cast),較為麻煩也容易出錯 2. 泛型生活化解釋 沒泛型 準備超大行李箱，在搬家時隨便放進去。但要開始整理，一個個拿出來時需要拿出來，是衣服就在走到衣櫃放，是什麼就要來回的走一個個放到對應的地方(前期開心後期麻煩) 泛型 準備好多行李箱，日用品放一起、衣服放一起...，雖然一開始整理會麻煩，但之後整理時會方便很多(前期麻煩後期開心) 3. 泛型(Generic Type)舉例 範例程式: \"/JavaEx_Part2/src/ch03/BeforeGenericList.java\" package ch03; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class BeforeGenericList { public static void main(String[] args) { // 使用ArrayList方法取得的資料都是Object List data = new ArrayList(); data.add(\"Hello\"); data.add(\"World\"); data.add(10); Iterator it = data.iterator(); while (it.hasNext()) { /* * 以下做法會失敗，因為Object中沒有isEmpty()的方法，所以要將資料轉型 * 不轉資料就不會有相應物件的特性，也會轉型失敗 * Object str1 = it.next(); * str1.isEmpty(); */ String str2 = (String) it.next(); // 強制轉型 System.out.println(str2); // 舊寫法: 資料相應轉型 Object obj = it.next(); if (obj instanceof String) { String s = (String) obj; System.out.println(s.isEmpty()); } else if (obj instanceof Integer) { Integer i1 = (Integer) obj; System.out.println(i1.intValue()); } } } } 範例程式: \"/JavaEx_Part2/src/ch03/GenericList.java\" package ch03; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class GenericList { public static void main(String[] args) { // 泛型是String List data = new ArrayList(); data.add(\"Hello\"); data.add(\"World\"); // 迭代器也要同泛型，String Iterator it = data.iterator(); while (it.hasNext()) { // next回傳的也是String // 強制轉型,不再需要使用instanceof判斷後再依序強制轉型 String str = it.next(); System.out.println(str); } } } 範例程式: \"/JavaEx_Part2/src/ch03/GenericMap.java\" package ch03; import java.util.HashMap; import java.util.Map; public class GenericMap { public static void main(String[] args) { Map map = new HashMap(); for (int i = 0; i 4. 泛型的延伸，自訂泛型 package ch03; import java.util.*; // 自訂泛型 class MyGenericType { private List list; public MyGenericType() { list = new Vector(); } public void add(Type t) { list.add(t); } public Type get(int i) { return list.get(i); } } public class MyGeneric { public static void main(String[] args) { // 真正決定泛型 MyGenericType myGeneric = new MyGenericType(); for (int i = 0; i 5. 泛型的進階設定 泛型的設定可使用「?」搭配「extends」或「super」來增加泛型的彈性(泛型上下邊界設定) ?: Any Type 如: : 代表可以是 Number 或 Number 的子類別 : 代表可以是 Number 的父類別 範例程式: \"/JavaEx_Part2/src/ch03/GenericAdv.java\" package ch03; class Book{ T price; // 限制自訂泛型的範圍，需在數字有關的類型 public static void show(Book b){ System.out.println(\"書籍定價為：\" + b.price); } } public class GenericAdv { public static void main(String[] args){ Book book = new Book(); book.price = 580; Book.show(book); } } 6. 基本泛型總結 請養成在使用 ArrayList 等集合時，都要加上泛型的好習慣 List/Set 只能放單一物件，所以不能放兩種資料型態 // 正確 List data = new ArrayList // 錯誤 List data = new ArrayList Map 可以放兩種型態，因為裏頭包含 key、val // 正確 Map map = new HashMap(); [1] T type K key E element V value 7. Iterable 介面 從 JDK1-5 開始,Collection 介面增加了新的泛型(Generic Type)功能 設計,並繼承 JDK1-5 的新介面 Iterable 介面 Iterable(JDK1-5): 此介面只有一個 iterator()方法,回傳 iterable 介面 Iterable iterator() 實作 Iterable 介面,其目的是為了允許物件可以使用 JDK1-5 的「增強 型 for 迴圈(for-each)」語法 Implementing this interface allows an object to be the target of the \"foreach\" statement 當使用 JDK1-5 的 for-each 來走訪集合的元素內容時,一切將顯得格外輕鬆! 8. 增強型 for 迴圈 (for – each) 增強型的 for 迴圈 (Enhanced for Loop) – for each: 在 JDK1-5 中,針對 for 迴圈作了一些加強,讓我們無需知道陣列 (array) 或集合(collection)的長度,甚至也不用迭代器(iterator),便 可以將其中的元素一一取出 使用 for – each 來走訪集合的元素會格外輕鬆 語法: for ( : ) for (Type varName : listName) 即可將 listName 裡的元素依順序,由型別為 Type 的變數 varName 存取 陣列或集合中元素的型別必須是可以轉型為 Type 的型別 9. Iterable 與 for - each 範例 範例程式: \"/JavaEx_Part2/src/ch03/EnhanceForCollection.java\" package ch03; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class EnhanceForCollection { public static void main(String[] args) { List data = new ArrayList(); // Set data = new HashSet(); data.add(\"Hello\"); data.add(\"World\"); System.out.println(\"傳統的for 迴圈\"); for (int i = 0; i 範例程式: \"/JavaEx_Part2/src/ch03/EnhanceForMap.java\" package ch03; import java.util.HashMap; import java.util.Map; public class EnhanceForMap { public static void main(String[] args) { Map map = new HashMap(); for (int i = 0; i 10. 傳統 for 與 for-each 傳統 for 迴圈效率比 for-each 快，所以 for-each 也是個 suger 用法 11. Collection 進一步探討(重點) HashSet: 自訂物件要實現不重複，需要主動去 override Object 類別的兩個方法 equals() 與 hashCode() hashCode 可以當作物件編號，但會因為不同的屬性而不相同 TreeSet: 自訂物件要實現不重複，需要在實作 compareTo() 方法裡加上回傳 0(zero) 的設計，也就是一樣大的意思 以上兩點須記下，並背起來。不然實際操作中容易出錯且找不到問題發生的原因 ArrayList、HashSet、HashMap 為此章節重點 Collection 在官方被稱作是 Framework。Framewor，也稱作框架，也可當作工具 12. Collection 延伸範例 基礎的依大小排序,見範例: 範例程式: \"/JavaEx_Part2/src/ch03/TestCollectionsForList.java\" package ch03; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class TestCollectionsForList { public static void main(String args[]) { List list = new ArrayList(); list.add(\"5\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); list.add(\"1\"); // 排序後放入 Collections.sort(list);// 排序 Collections.reverse(list); // 倒序 Object obj; for (int i = 0; i 範例程式: \"TestArraysForArray.java\" package ch03; import java.util.*; public class TestArraysForArray { public static void main(String args[]) { String strArray[] = { \"5\", \"2\", \"3\", \"4\", \"1\" }; Arrays.sort(strArray); for (int i = 0; i Map 以 key 的資料進行大小排序，所以 key 的資料得是相同型別的資料 範例程式: \"/JavaEx_Part2/src/ch03/TestTreeSet.java\" package ch03; import java.util.Iterator; import java.util.Set; import java.util.TreeSet; public class TestTreeSet { public static void main(String args[]) { Set set = new TreeSet(); set.add(new Integer(56)); set.add(new Integer(34)); set.add(new Integer(12)); set.add(\"Hello\"); // TreeSet 只能將相同類型的資料來比較 Iterator objs = set.iterator(); while (objs.hasNext()) System.out.println(objs.next()); } } 範例程式: \"/JavaEx_Part2/src/ch03/TestTreeMap.java\" package ch03; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; public class TestTreeMap { public static void main(String[] args) { // HashMap 不保證key的順序性，有排序只是剛好，沒排序只是正常 Map map1 = new HashMap(); // TreeMap 會保證key的順序性 Map map2 = new TreeMap(); // TreeMap的Key值要同一種資料型別 for (int i = 0; i 物件大小排序(實作 Comparable 介面)見範例: 範例程式: \"Employee.java\" package ch03; // Comparable要比較的物件類型 public class Employee implements Comparable { private int empno; private String ename; public void setEmpno(int empno) { this.empno = empno; } public int getEmpno() { return empno; } public void setEname(String ename) { this.ename = ename; } public String getEname() { return ename; } public Employee(int empno, String ename) { this.empno = empno; this.ename = ename; } public Employee(int empno) { this(empno, \"-\"); } public Employee(String ename) { this(0, ename); } public Employee() { this(0, \"-\"); // 或 empno = 0; ename = \"-\" } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } public int compareTo(Employee aEmployee) { // 用這樣可能有溢位問題，所以不建議使用 return this.empno - aEmployee.empno; // 建議作法，此做法也安全、謹慎 if (this.empno > aEmployee.empno) { return 1; } else { return -1; } } } 範例程式: \"TestCollectionsForListEmp.java\" package ch03; import java.util.*; public class TestCollectionsForListEmp { public static void main(String args[]) { List list = new ArrayList(); Employee e1 = new Employee(7001, \"king1\"); Employee e2 = new Employee(7002, \"king2\"); Employee e3 = new Employee(7003, \"king3\"); Employee e4 = new Employee(7004, \"king4\"); Employee e5 = new Employee(7005, \"king5\"); list.add(e5); list.add(e2); list.add(e3); list.add(e4); list.add(e1); Collections.sort(list); // Collections.reverse(list); for (Employee aEmp : list) { System.out.println(aEmp.getEmpno() + \"-\" + aEmp.getEname()); } } } 範例程式: \"Employee.java\" package ch03; // Comparable要比較的物件類型 public class Employee implements Comparable { private int empno; private String ename; public void setEmpno(int empno) { this.empno = empno; } public int getEmpno() { return empno; } public void setEname(String ename) { this.ename = ename; } public String getEname() { return ename; } public Employee(int empno, String ename) { this.empno = empno; this.ename = ename; } public Employee(int empno) { this(empno, \"-\"); } public Employee(String ename) { this(0, ename); } public Employee() { this(0, \"-\"); // 或 empno = 0; ename = \"-\" } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } public int compareTo(Employee aEmployee) { // 實作員工怎麼比大小 // 物件本身與 aEmployee 相比較，如果 retrun 正值，就表示比 aEmployee 大 // 正負值代表的是\"左右\"的意思 // 很多時候在取資料庫資料時已排序(Order by)完畢，所以目前作法是做更複雜的自訂排序 if (this.empno > aEmployee.empno) { return 1; } else { return -1; } } } 範例程式: \"TestArraysForArrayEmp.java\" package ch03; import java.util.Arrays; public class TestArraysForArrayEmp { public static void main(String args[]) { Employee e[] = new Employee[5]; Employee e1 = new Employee(7001, \"king1\"); Employee e2 = new Employee(7002, \"king2\"); Employee e3 = new Employee(7003, \"king3\"); Employee e4 = new Employee(7004, \"king4\"); Employee e5 = new Employee(7005, \"king5\"); e[0] = e5; e[1] = e2; e[2] = e3; e[3] = e4; e[4] = e1; // sort方法會自己去呼叫Employee的compareTo方法，取得排序結果 Arrays.sort(e); for (int i = 0; i Employee.java + TestTreeSetEmp.java, TestTreeMapEmp.java package ch03; // Comparable要比較的物件類型 public class Employee implements Comparable { private int empno; private String ename; public void setEmpno(int empno) { this.empno = empno; } public int getEmpno() { return empno; } public void setEname(String ename) { this.ename = ename; } public String getEname() { return ename; } public Employee(int empno, String ename) { this.empno = empno; this.ename = ename; } public Employee(int empno) { this(empno, \"-\"); } public Employee(String ename) { this(0, ename); } public Employee() { this(0, \"-\"); // 或 empno = 0; ename = \"-\" } public void display() { System.out.println(\"empno=\" + empno); System.out.println(\"ename=\" + ename); } public int compareTo(Employee aEmployee) { // 實作員工怎麼比大小 // 物件本身與 aEmployee 相比較，如果 retrun 正值，就表示比 aEmployee 大 // 正負值代表的是\"左右\"的意思 // 很多時候在取資料庫資料時已排序(Order by)完畢，所以目前作法是做更複雜的自訂排序 if (this.empno > aEmployee.empno) { return 1; } else { return -1; } } public boolean equals(Object obj) { if (this == obj) return true; if (obj != null && getClass() == obj.getClass()) { Employee e = (Employee) obj; if (this.empno == e.empno && this.ename.equals(e.ename)) { return true; } } return false; } public int hashCode() { // 依照屬性作比對 final int prime = 31; int sum = 1; sum = prime * empno; sum = prime * ename.hashCode(); return sum; } } /* TreeMap的Key值要同一種資料型別 */ package ch03; import java.util.*; public class TestTreeMapEmp { public static void main(String[] args) { // Map map = new HashMap(); Map map = new TreeMap(); // TreeMap的Key值要同一種資料型別 Employee e1 = new Employee(7001, \"king1\"); Employee e2 = new Employee(7002, \"king2\"); Employee e3 = new Employee(7003, \"king3\"); Employee e4 = new Employee(7004, \"king4\"); Employee e5 = new Employee(7005, \"king5\"); map.put(e5, e5.getEname()); map.put(e2, e2.getEname()); map.put(e3, e3.getEname()); map.put(e4, e4.getEname()); map.put(e1, e1.getEname()); for (String ename : map.values()) { System.out.println(ename); } System.out.println(); for (Employee aEmployee : map.keySet()) { System.out.println(aEmployee.getEmpno()); } } } 13. ArrayList 與 LinkedList 差異 ArrayList: 連續線性方式存放元素 搭配索引值存取元素，效率好。 常對元素插入移除的操作效率差 ① ② ③ ④ ⑤ ⑥ LinkedList: 優缺點跟 ArrayList 相反 ② ④ / \\ / ① ③ 更進階的排序,如 FIFO,LIFO...等,請參考範例補充分享 依加入順序: TestLinkedList.java, TestLinkedHashSet.java, TestLinkedHashMap.java 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedList.java\" /* * * LinkedList 也是一可置入\"任意物件\"的\"動態陣列\"(可隨內含物多寡增減其長度) * 如果你需要經常將元素插入和刪除的話 , 那麼 LinkedList 可以有更佳的效率 * LinkedList 多了 * void addFirst(Object o); * void addLast(Object o); * Object getFirst(); * Object getLast(); * 等方法 */ package idv.david.additional.sort; import java.util.*; public class TestLinkedList { public static void main(String args[]) { LinkedList list = new LinkedList(); list.add(new Integer(12)); list.add(new Long(34L)); list.add(new Double(5.6)); list.add(\"Hello\"); list.add(\"Hello\"); // duplicate, is added System.out.println(\"toString()=\" + list); System.out.println(\"元素個數=\" + list.size()); Iterator objs = list.iterator(); while (objs.hasNext()) System.out.println(objs.next()); // List家族可以用Iterator或for迴圈取值 System.out.println(); for (int i = 0; i toArray() System.out.println(); Object a[] = list.toArray(); for (int i = 0; i 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedHashSet.java\" package idv.david.additional.sort; import java.util.*; public class TestLinkedHashSet { public static void main(String args[]) { Set set = new LinkedHashSet(); set.add(new Integer(56)); set.add(new Integer(34)); set.add(new Integer(12)); Iterator objs = set.iterator(); while (objs.hasNext()) System.out.println(objs.next()); System.out.println(\"===========\"); Set set2 = new HashSet(); set2.add(new Integer(56)); set2.add(new Integer(34)); set2.add(new Integer(12)); Iterator objs2 = set2.iterator(); while(objs2.hasNext()) System.out.println(objs2.next()); } } 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestLinkedHashMap.java\" package idv.david.additional.sort; import java.util.*; public class TestLinkedHashMap { public static void main(String[] args) { // Map map = new HashMap(); // Map map = new TreeMap(); // TreeMap的Key值要同一種資料型別 Map map = new LinkedHashMap(); for (int i = 6 ; i > 0 ; i--) { map.put(i, \"David\" + i); } for (String val : map.values()) { System.out.println(val); } } } 依大小順序: TestQueue.java, TestPriorityQueue1.java, TestPriorityQueue2.java 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestQueue.java\" package idv.david.additional.sort; import java.util.*; public class TestQueue { public static void main(String[] args) { // 駐列: // 行事曆代辦事項的概念，做完了就不用在裡面存在 // 餐廳的排隊系統，使用駐列的排隊方式(頭尾處理) Queue q = new LinkedList(); q.offer(\"First\"); q.offer(\"Second\"); q.offer(\"Third\"); Object o; System.out.println(q.toString()); while ((o = q.poll()) != null) { String s = (String) o; System.out.println(s); } System.out.println(q.toString()); } } 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestPriorityQueue1.java\" package idv.david.additional.sort; import java.util.PriorityQueue; public class TestPriorityQueue1 { public static void main(String[] args) { // 保證資料是用大小順序取出，取完後資料也會為空 PriorityQueue pq = new PriorityQueue(); pq.offer(\"c\"); pq.offer(\"a\"); pq.offer(\"b\"); String s; while ((s = pq.poll()) != null) { System.out.print(s + \", \"); } System.out.print(pq); // a, b, c, [] } } 14. 自訂比較器的三種方法 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/TestPriorityQueue2.java\" 方法 1 package idv.david.additional.sort; import java.util.Comparator; import java.util.PriorityQueue; class MyComparator implements Comparator { @Override public int compare(String s1, String s2) { // 使用java本身提供的字串順序比較，用乘(-1)的方式將資料排序規則倒過來(反轉) return s1.compareTo(s2) * -1; } } public class TestPriorityQueue2 { public static void main(String[] args) { MyComparator c = new MyComparator(); // 3 集合初始大小，如果超過後續會動態擴增 // c 使用自訂的排序規則 PriorityQueue pq = new PriorityQueue(3, c); pq.offer(\"c\"); pq.offer(\"a\"); pq.offer(\"b\"); String s; while ((s = pq.poll()) != null) { System.out.print(s + \", \"); } } } 方法 2 package idv.david.additional.sort; import java.util.Comparator; import java.util.PriorityQueue; public class TestPriorityQueue2 { public static void main(String[] args) { // 比較器(匿名類別語法) Comparator c = new Comparator() { public int compare(String a, String b) { return a.compareTo(b) * -1; } }; MyComparator c = new MyComparator(); // 3 集合初始大小，如果超過後續會動態擴增 // c 使用自訂的排序規則 PriorityQueue pq = new PriorityQueue(3, c); pq.offer(\"c\"); pq.offer(\"a\"); pq.offer(\"b\"); String s; while ((s = pq.poll()) != null) { System.out.print(s + \", \"); } } } 方法 3: Java8 簡化 package idv.david.additional.sort; import java.util.Comparator; import java.util.PriorityQueue; public class TestPriorityQueue2 { public static void main(String[] args) { PriorityQueue pq = new PriorityQueue(3, (a, b) -> a.compareTo(b) * -1); pq.offer(\"c\"); pq.offer(\"a\"); pq.offer(\"b\"); String s; while ((s = pq.poll()) != null) { System.out.print(s + \", \"); } } } 15. 堆疊 依加入順序(FIFO, LIFO): Test_FIFO_List.java, Test_LIFO_Stack.java FIFO 先進先出 LIFO 後進先出(堆疊)，出表示移除 電梯: 先進去的被擠在裏頭，最後進來的先出門 自助餐: 上面的盤子最後放上，但拿盤子時也是由上面先拿走 衣服穿多層: 越晚穿的越早脫 FilSterm: 最後接的水管最早 close() 範例程式: \"/JavaEx_Part2/src/idv/david/additional/sort/Test_LIFO_Stack.java\" package idv.david.additional.sort; import java.util.Stack; public class Test_LIFO_Stack { public static void main(String[] args) { Stack list = new Stack(); list.add(\"c\"); list.add(\"a\"); list.add(\"b\"); list.add(\"a\"); System.out.println(list.toString()); // stack 是使用後進先出的方式拿，那就不應該依照index(索引值)方式取值 // for (int i = 0; i Java 泛型通配符 T E K V 的区别，以及 class 与 class 的区别 ↩︎ "},"3.JAVA/03.JAVA套件與進階/17.多執行緒/17-1.執行緒.html":{"url":"3.JAVA/03.JAVA套件與進階/17.多執行緒/17-1.執行緒.html","title":"17-1.執行緒","keywords":"","body":"目錄 1. 執行緒 2. Thread 類別 3. Runnable 介面 4. 執行緒生命週期 5. 執行緒常用方法 6. 執行續的特性 7. 控制執行續與優先安排 8. 執行續總結 9. 同步 (Synchronization) (1/2) 10. 資源鎖定的理解 11. 同步 (Synchronization) 總結 12. 執行緒間通訊 13. 死結 (DeadLock) 14. Daemon 執行緒 15. 執行續留意總結 1. 執行緒 什麼是執行緒(Thread) 執行緒是程式中的執行區段,這個區段中的指令能夠不被其它區段影響而獨立執行,並可以在我們需要時啟動,不需要時關閉,以節省系統資源 Multithreading(多執行緒) Java 支援多執行緒: 看似電腦可同時執行許多工作,實質為 CPU 在各個程式中切換 不是每個程式都必須使用執行緒,但使用多緒多工,可使系統的效率 得以充分發揮 已知的執行緒: Java 的 Garbage Collector 即是一個執行緒 (daemon thread) daemon thread 意思就是背景執行續 舉例: 音樂播放 Java 垃圾執行續 Java 程式啟動時,即自動建立一個執行緒,稱為主執行緒(main thread) main thread 任務就是把 main 方法執行完畢 應用程式(Application) 作業系統 硬體 經常被誤會的詞 Process(程序，行程) Thread(執行續) 2. Thread 類別 教科書說法 繼承 java.lang.Thread 類別 建立 Thread 類別的衍生類別,並覆寫(Override)其 run() 方法 run() 方法為執行緒執行的地方(用了 run 表示使用單執行續，只有start()裁示啟動多執行續) 簡說 繼承 Thread 類別 覆寫 run() 實體化物件後，呼叫 start() 啟用 多執行續 package ch04; // 多執行續 public class CounterThread extends Thread { int counter = 10; public CounterThread() { } // 建構者函數 public void run() { // 執行緒執行的地方 while (counter > 0) { System.out.println(counter); counter--; try { Thread.sleep(1000); // 暫停一秒 } catch (Exception e) { } } } public static void main(String arg[]) { CounterThread t1 = new CounterThread(); // 產生執行緒物件 CounterThread t2 = new CounterThread(); t1.start(); // 呼叫執行緒物件的start()方法(即啟動執行緒) , 隨即執行物件中的run方法 t2.start(); } } 3. Runnable 介面 教科書說法 在不能多重繼承時,可實作 java.lang.Runnable 介面 建立實作 Runnable 介面的類別,並實作(implements)其 run() 方法,再將上述衍生類別的參考,透過 Thread 類別的建構子以建立一個 Thread 類別的實體 簡說 實作 Runnable 介面 覆寫 run() 實體化物件CounterRunnable r = new CounterRunnable; (物件名自訂) 用 Thread 物件包裝 Thread t = new Thread(r); 呼叫 t.start() 啟用 package ch04; public class CounterRunnable implements Runnable { int counter = 10; public CounterRunnable() { } // 建構者函數 public void run() { // 執行緒執行的地方 while (counter > 0) { System.out.println(counter); counter--; try { Thread.sleep(1000); // 暫停一秒 } catch (Exception e) { } } } public static void main(String arg[]) { CounterRunnable r1 = new CounterRunnable();// 產生Runnable物件 Thread t1 = new Thread(r1); // 再由Runnable物件, 產生執行緒Thread物件 CounterRunnable r2 = new CounterRunnable(); Thread t2 = new Thread(r2); t1.start(); // 呼叫執行緒物件的start()方法(即啟動執行緒) , 隨即執行物件中的run方法 t2.start(); } } 4. 執行緒生命週期 預備狀態(Ready) 執行 start()方法即進入排程器中等候 CPU 處理(不一定啟動就執行) 執行狀態(Running) run()方法被呼叫時 死亡狀態(Dead) run()方法執行完畢時,或 stop()方法被呼叫時 註: stop() 不再使用，官方也不建議用 這種方法被稱為被列為 Deprecated (淘汰) 的方法 對於官方淘汰的方法開發工具會顯示 stop() 等待狀態(Waiting)(用在執行續之間的溝通設計) 執行 wait()方法即移出執行狀態,透過 notify()或 notifyAll()方法回到預備狀態 睡眠狀態(Sleeping) 停止一段時間後回到預備狀態 阻塞狀態(Blocked) 需等待一段不確定的 I/O 時間(硬體的執行時間),移出執行狀態 暫停狀態(Suspended) 透過 resume() 方法回到預備狀態 註: 不再使用，因為有sleep所以這個官方也不建議在使用，若要用相關功能則使用sleep即可 start() > Runnable(Ready)(作業系統排程區) > Running(run()方法執行) > Dead(run()執行完畢) wait()、notify() 是 Object 類別的方法 I/O blocked 硬體執行的延遲時間 5. 執行緒常用方法 因為 run 方法本身是沒有丟出例外的，所以如果要 override 這樣一定要用 try catch Interrupted 干擾/打斷，而 InterruptedException 在下列常用方法中是一種 check exception ，即一定要處裡的意外，這種意外跟作業系統執行因素影響有關 milliseconds 是毫秒的意思 方法 說明 void run() 執行緒執行的地方 void start() 啟動執行緒 void setName(String name) 設定執行緒的名字 String getName() 回傳執行緒的名字 void setPriority(int newPriority) 設定執行緒的優先權為newPriority int getPriority() 取得執行緒的優先權值 boolean isAlive() 判斷目前執行緒狀態是否為存在(還活著嗎) void setDaemon(boolean on) 設定為背景執行緒 boolean isDaemon() 判斷是否為背景執行緒 static Thread currentThread() 回傳目前正在執行的執行緒物件 void join() throws InterruptedException 等待此執行緒執行終止 static void yield() 使目前的執行緒讓出執行權 static void sleep (long milliseconds)Throws InterruptedException 使執行緒休眠多少毫秒 ThreadGroup getThreadGroup() 回傳目前執行緒的執行緒群組 6. 執行續的特性 行為難以掌握 順序難以預測 (依照 cpu 自訂的排程運行，所以每次順序都會不同) 執行時隨時會切換 範例程式: \"/JavaEx_Part2/src/ch04/MyThread.java\" 範例程式: \"/JavaEx_Part2/src/ch04/TestMyThread.java\" package ch04; public class MyThread extends Thread { public static boolean ready = false; // 「開跑」變數 // 以四種不同的建構者函數來建立物件 (function overloading) public MyThread() { super(\"NT1\"); } public MyThread(String name) { super(name); } public MyThread(String name, int priority) { super(name); setPriority(priority); // 設定執行緒的優先權為newPriority } public MyThread(String name, int priority, boolean isDaemon) { super(name); setPriority(priority); // 設定執行緒的優先權為newPriority setDaemon(isDaemon); // 設定為背景執行緒 } public void run() { while (!ready) { } // 只要沒開跑，就不執行下一行。 System.out.println(\"My name is \" + getName() + \"..... My priority is \" + getPriority() + \"..... Am I alive? \" + isAlive() + \"..... Am I daemon? \" + isDaemon()); String nameOfcurrentThread = Thread.currentThread().getName(); System.out.println(\"目前正在執行的執行緒的名字=\" + nameOfcurrentThread); } } package ch04; public class TestMyThread { // main也是種執行續，所以目前共啟動6組執行續 public static void main(String[] args) { MyThread nt[] = new MyThread[] { new MyThread(), new MyThread(\"NT2\", 2), new MyThread(\"NT3\", 3), new MyThread(\"NT6\", 6, true), new MyThread(\"NT9\", 9, true) }; for (int i = 0; i 7. 控制執行續與優先安排 執行緒 join 其它執行緒:等它所呼叫的執行緒終止後再繼續執行(控制執行續的\"先後\"順序) join() join(long milliseconds) 優先權(Priority)可確保重要或急迫性執行緒可被立即或經常執行 流程安排(Scheduling)是決定多個執行緒的執行順序 優先權的值為 1 至 10 的整數,由 Thread 類別定義三種常數: Thread.MIN_PRIORITY : 最小值 = 1 (增加程式碼的閱讀性) Thread(類別直接取 static 的資料) Thread.NORM_PRIORITY : 預設值 = 5 Thread.MAX_PRIORITY : 最大值 = 10 可使用 setPriority() 和 getPriority()方法重新設定和取得優先權值 優先權較高者先執行,但優先權相等時,並非是等待最久者先執行,而是任選其一執行 執行續切換發生於: 有較高優先權的執行續進入排程時 執行續被中止執行或 run() method 執行完畢 Time-Slice 系統: 系統分配時間用完了(作業系統的機制) 註: 一般情況下擁有最高優先權的執行續先執行，不過有時候會有例外，因此有時排程器會挑選優先權較低者來執行，以避免餓死(starvation)的情形，因此優先權的使用紙是為了讓排程更有效率而已，物在程是中完全使用優先權的關係來控制程式的進行 簡言: 比重安排 時間分割(Time-slicing): 如 windows 系統會將 CPU 的時間分成一段段的時間槽(time slot)，特性為: 具 time-slicing 特性作業系統將 time slot 分給「Priority 最高且香等的數個執行續」，直到執行完畢或是被更高優先權的執行續搶走 無法保證 time slot 的平均分配，也不保證執行的先後順序 自私的執行續(Selfish thread): 自私的執行續實踐了「socially-impaired」，其特性為: 擁有「密實迴圈(tight loop)」，將一直獨佔 CPU 執行權 如果系統不支援 Time-Slice 則易完全獨佔，直到: 該迴圈執行完畢 或被更高 Priority 之其他執行續被搶走 CPU 執行權 windows 系統本身就具有 Time-Slice 的功能，所以測試實不容易有效果 禮讓的執行緒 用 yield() 改進,自願移出執行(Running)狀態至預備(Ready)狀態 對 Priority 相等 的數個執行緒有效 8. 執行續總結 多執行緒程式的特性(結論一): 多執行緒是難以預測其行為的 執行緒的執行順序無法完全保證 Task Switches 可能在任何時刻任何位置發生 執行緒對於小改變有高度的敏感性 (類似於一用 yield 就立刻在執行續尚有改變) 執行緒並不總是立刻啟動執行(需被排程) 多執行緒程式的特性(結論二): 在時間分割(Time-Slicing)系統中優先權相同的執行緒會以一種幾乎相同機會的循環方式來執行,甚至優先權較低的執行緒也能取得時間糟(time slot)的一小部份,其比例大約正比於他們的優先權值,因此在長時間的執行中不會有執行緒完全都沒有被顧及到 可應用在 server 運行機制 在非時間分割(Time-Slicing)系統中則易發生完全獨佔的情況 對於有大量運算的執行緒應適度的呼叫 yield()來讓其它執行緒有執行的機會,尤其可增加圖形使用者介面(GUI)的良好互動 9. 同步 (Synchronization) (1/2) 為什麼使用 synchronized 關鍵字 原因: 在程式的某 Critical Section(危險區域)裡,不同執行緒可能同時存取同一份資源因而產生衝突或重覆修改的問題 目的: 控制每次只能有一個執行緒在使用同一份資源,此時另外的執行緒無法同時使用此同一份資源 舉例: 銀行領錢問題 使用同步的概念 Monitor: 所有物件共有一個 Monitor (監控),用來當每次只能有一個執行緒進入獨佔的鎖(Lock)(或稱作旗標 Flag) 進入 Monitor: 在 Java 裡,由呼叫已經 synchronized 關鍵字修正過的 method 即進入 Monitor 並得到鎖(Lock)。此時其它所有嘗試進入 Monitor 的執行緒將會暫停(Blocked 狀態)直到該執行緒離開 什麼資源要鎖定是靠工程師設定 10. 資源鎖定的理解 步驟 1: 初始資料 package ch04; import java.io.PrintWriter; public class TestSync0 { static int balance = 1000; // simulate balance kept remotely public static void main(String args[]) { PrintWriter out = new PrintWriter(System.out, true); Account account = new Account(out); DepositThread first, second; first = new DepositThread(account, 1000, \"#1\"); // Step1 second = new DepositThread(account, 1000, \"\\t\\t\\t\\t#2\"); // Step2 // start the transactions first.start(); second.start(); // wait for both transactions to finish try { first.join(); second.join(); } catch (InterruptedException e) { } // print the final balance out.println(\"*** Final balance is \" + balance); } } class Account { PrintWriter out; Account(PrintWriter out) { this.out = out; } // 因為在這個區域，開始執行價格跟計算，所以必須在此就切斷影響 // 主要是在這片區域當中，執行的部分是先在這邊計算好後才set金錢 // 危險區: 執行區都是在這邊執行。多個執行續都呼叫同個方法 void deposit(int amount, String name) { int balance; out.println(name + \" trying to deposit \" + amount); out.println(name + \" getting balance...\"); balance = getBalance(); out.println(name + \" balance got is \" + balance); balance += amount; out.println(name + \" setting balance...\"); setBalance(balance); out.println(name + \" new balance set to \" + TestSync0.balance); } int getBalance() { // simulate the delay in getting balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } return TestSync0.balance; } void setBalance(int balance) { // simulate the delay in setting new balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } TestSync0.balance = balance; } } class DepositThread extends Thread { Account account; int depositAmount; String message; DepositThread(Account account, int amount, String message) { this.message = message; this.account = account; this.depositAmount = amount; } public void run() { account.deposit(depositAmount, message); } } 步驟 2: 鎖 deposit() package ch04; import java.io.PrintWriter; public class TestSync1 { static int balance = 1000; // simulate balance kept remotely public static void main(String args[]) { PrintWriter out = new PrintWriter(System.out, true); Account1 account = new Account1(out); DepositThread1 first, second; first = new DepositThread1(account, 1000, \"#1\"); // 因為在這共用同一個account所以才會出現搶資源的情形 second = new DepositThread1(account, 1000, \"\\t\\t\\t\\t#2\"); // start the transactions first.start(); second.start(); // wait for both transactions to finish try { first.join(); second.join(); } catch (InterruptedException e) { } // print the final balance out.println(\"*** Final balance is \" + balance); } } // 因為Account物件是被共用的，所以是要在這拿鎖 class Account1 { PrintWriter out; Account1(PrintWriter out) { this.out = out; } synchronized void deposit(int amount, String name) { // synchronized 整個存款method int balance; out.println(name + \" trying to deposit \" + amount); out.println(name + \" getting balance...\"); balance = getBalance(); out.println(name + \" balance got is \" + balance); balance += amount; out.println(name + \" setting balance...\"); setBalance(balance); out.println(name + \" new balance set to \" + TestSync1.balance); } int getBalance() { // simulate the delay in getting balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } return TestSync1.balance; } void setBalance(int balance) { // simulate the delay in setting new balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } TestSync1.balance = balance; } } class DepositThread1 extends Thread { Account1 account; int depositAmount; String message; DepositThread1(Account1 account, int amount, String message) { this.message = message; this.account = account; this.depositAmount = amount; } public void run() { account.deposit(depositAmount, message); } } 步驟 3: 鎖區域 package ch04; import java.io.PrintWriter; public class TestSync2 { static int balance = 1000; // simulate balance kept remotely public static void main(String args[]) { PrintWriter out = new PrintWriter(System.out, true); Account2 account = new Account2(out); DepositThread2 first, second; first = new DepositThread2(account, 1000, \"#1\"); second = new DepositThread2(account, 1000, \"\\t\\t\\t\\t#2\"); // start the transactions first.start(); second.start(); // wait for both transactions to finish try { first.join(); second.join(); } catch (InterruptedException e) { } // print the final balance out.println(\"*** Final balance is \" + balance); } } class Account2 { PrintWriter out; Account2(PrintWriter out) { this.out = out; } void deposit(int amount, String name) { int balance; out.println(name + \" trying to deposit \" + amount); out.println(name + \" getting balance...\"); // method 內必需synchronized的片段程式碼，須設定鎖哪個物件 // this = 現在這個物件 => Account2 synchronized (this) { balance = getBalance(); // out.println(name + \" balance got is \" + balance); // balance += amount; // out.println(name + \" setting balance...\"); // setBalance(balance); // } // out.println(name + \" new balance set to \" + TestSync2.balance); } int getBalance() { // simulate the delay in getting balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } return TestSync2.balance; } void setBalance(int balance) { // simulate the delay in setting new balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } TestSync2.balance = balance; } } class DepositThread2 extends Thread { Account2 account; int depositAmount; String message; DepositThread2(Account2 account, int amount, String message) { this.message = message; this.account = account; this.depositAmount = amount; } public void run() { account.deposit(depositAmount, message); } } 步驟 4: 鎖 Account package ch04; import java.io.PrintWriter; public class TestSync3 { static int balance = 1000; // simulate balance kept remotely public static void main(String args[]) { PrintWriter out = new PrintWriter(System.out, true); Account3 account = new Account3(out); DepositThread3 first, second; first = new DepositThread3(account, 1000, \"#1\"); second = new DepositThread3(account, 1000, \"\\t\\t\\t\\t#2\"); // start the transactions first.start(); second.start(); // wait for both transactions to finish try { first.join(); second.join(); } catch (InterruptedException e) { } // print the final balance out.println(\"*** Final balance is \" + balance); } } class Account3 { PrintWriter out; Account3(PrintWriter out) { this.out = out; } void deposit(int amount, String name) { int balance; out.println(name + \" trying to deposit \" + amount); out.println(name + \" getting balance...\"); balance = getBalance(); out.println(name + \" balance got is \" + balance); balance += amount; out.println(name + \" setting balance...\"); setBalance(balance); out.println(name + \" new balance set to \" + TestSync3.balance); } int getBalance() { // simulate the delay in getting balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } return TestSync3.balance; } void setBalance(int balance) { // simulate the delay in setting new balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } TestSync3.balance = balance; } } class DepositThread3 extends Thread { Account3 account; int depositAmount; String message; DepositThread3(Account3 account, int amount, String message) { this.message = message; this.account = account; this.depositAmount = amount; } public void run() { synchronized (account) { // synchronized 於執行緒 run() method 內 account.deposit(depositAmount, message); } } } 步驟 5: 類別資料 package ch04; import java.io.PrintWriter; public class TestSync2 { static int balance = 1000; // simulate balance kept remotely public static void main(String args[]) { PrintWriter out = new PrintWriter(System.out, true); Account2 account = new Account2(out); DepositThread2 first, second; first = new DepositThread2(account, 1000, \"#1\"); second = new DepositThread2(account, 1000, \"\\t\\t\\t\\t#2\"); // start the transactions first.start(); second.start(); // wait for both transactions to finish try { first.join(); second.join(); } catch (InterruptedException e) { } // print the final balance out.println(\"*** Final balance is \" + balance); } } class Account2 { PrintWriter out; Account2(PrintWriter out) { this.out = out; } void deposit(int amount, String name) { int balance; out.println(name + \" trying to deposit \" + amount); out.println(name + \" getting balance...\"); // 鎖定類別資料 synchronized (TestSync2.class) { balance = getBalance(); out.println(name + \" balance got is \" + balance); balance += amount; out.println(name + \" setting balance...\"); setBalance(balance); } out.println(name + \" new balance set to \" + TestSync2.balance); } int getBalance() { // simulate the delay in getting balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } return TestSync2.balance; } void setBalance(int balance) { // simulate the delay in setting new balance remotely try { Thread.sleep(5000); } catch (InterruptedException e) { } TestSync2.balance = balance; } } class DepositThread2 extends Thread { Account2 account; int depositAmount; String message; DepositThread2(Account2 account, int amount, String message) { this.message = message; this.account = account; this.depositAmount = amount; } public void run() { account.deposit(depositAmount, message); } } 最終鎖的地方都是 Account 物件 步驟 4 跟步驟 2 效率相同 步驟 3 效率較優 11. 同步 (Synchronization) 總結 使用同步的方法 先找出 Critical Section(危險區域)後: 在方法宣告中加入 synchronized 關鍵字 synchronized method(){...} 或程式區塊以 synchronized 標示 synchronized(物件){...} 或類別資料以 synchronized 標示 synchronized(類別名稱.class){...} 鎖定類別資料 再執行已經用 synchronized 修正過的方法(method)或程式區塊 執行效率與程式的穩定度 同步化是一個相當耗時的運算,除非必要,否則應減少使用,尤其是經常執行的方法(method)或程式區段 然而妥善的運用對程式的穩定度和強健度有極大幫助 可以不用的地方，訪客人數; 需要用的地方，錢 12. 執行緒間通訊 執行緒間的通訊(interthread communication) 目的: 讓執行緒之間可互相交談,彼此等待 方式: 可透過共同使用的資料交談 或使用執行緒控制的方法(method),如 join() 或於 synchronized 的方法內使用 wait(), notify(), notifyAll()等更細微溝通機制,彼此等待,以避免「生產過剩、不足」或是「消費過剩、不足」的問題,並使 CPU 使用更有效率 wait(), notify(), notifyAll() 這些方法在 Object 類別裡實作成 final 的方法,所有 Java 類別都可以使用這些方法 wait():當一執行緒呼叫 wait()方法時,會放棄 monitor,將 lock 釋放出給另一個正等待進入 monitor 的執行緒,並且進入等待執行緒群(pool)開始等待,直到等待時間終了,或是被另一個進入相同 monitor 的執行緒呼叫 notify()或 notifyAll()方法所叫醒,而再進入 ready 狀態 notify(): 隨機叫醒在相同物件上某一個正在 waiting 的執行緒 notifyAll(): 叫醒在相同物件上所有正在 waiting 的執行緒,priority 最高者將第一個執行 範例程式: \"/JavaEx_Part2/src/ch04/TestWaitNotify.java\" package ch04; class Depot { private int stock = 0; // 庫存量 synchronized public void produce(int qty) { while (stock > 20) { System.out.println(\"庫存量超過20，暫停生產\"); try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } stock += qty; System.out.println(\"產量：\" + qty + \"；庫存量：\" + stock); notify(); } synchronized public void consume(int qty) { while (stock 13. 死結 (DeadLock) 死結(DeadLock) 原因:多執行緒的同步化鎖定(synchronized)可能造成執行緒間相互等待的死結。而 Java 無法偵測或預防死結的發生,須由程式設計師自行控制與掌握 哲學家用餐問題 避免死結: 最好方法是預防而非偵測它 預防死結: 最簡單方式是將一群物件的鎖定動作,依據相同的順序為之 範例程式: \"/JavaEx_Part2/src/ch04/DeadLock.java\" package ch04; public class DeadLock { public static void main(String args[]) { T1 t1 = new T1(3, \"T1\"); // 3 secs T2 t2 = new T2(0, \"T2\"); // 0 secs t1.start(); t2.start(); try { // 睡了一秒 Thread.sleep(1000); // 1 secs } catch (Exception e) { } t1.stop(); // Deprecated (淘汰) } } class T1 extends Thread { private int sleepTime = 0; public static boolean finished = false; public T1(int second, String name) { super(name); sleepTime = second; } public void run() { System.out.println(\"T1 running...\"); try { // 睡三秒在起來 Thread.sleep(sleepTime * 1000); // 3 secs } catch (Exception e) { } System.out.println(\"T1 finished.\"); T1.finished = true; } } class T2 extends Thread { private int sleepTime = 0; public T2(int second, String name) { super(name); sleepTime = second; } public void run() { while (!T1.finished) { yield(); } System.out.println(\"T2 running...\"); System.out.println(\"T2 finished.\"); } } 範例程式: \"/JavaEx_Part2/src/ch04/NoDeadLock.java\" package ch04; public class NoDeadLock { public static void main(String args[]) { T1_1 t1 = new T1_1(3, \"T1_1\"); // 3 secs T2_1 t2 = new T2_1(0, \"T2_1\"); // 0 secs t1.start(); t2.start(); try { Thread.sleep(5000); // 原1 sec 比 3 secs 小 , 使得t1仍在sleep時被 stop } catch (Exception e) { } // 因此無法執行T1_1.finished = true; t1.stop(); // 造成t2之迴圈 while(!T1_1.finished){yield();} 為真,無法離開 } } class T1_1 extends Thread { private int sleepTime = 0; public static boolean finished = false; public T1_1(int second, String name) { super(name); sleepTime = second; } public void run() { System.out.println(\"T1_1 running...\"); try { Thread.sleep(sleepTime * 1000); // 3 secs } catch (Exception e) { } System.out.println(\"T1_1 finished.\"); T1_1.finished = true; } } class T2_1 extends Thread { private int sleepTime = 0; public T2_1(int second, String name) { super(name); sleepTime = second; } public void run() { while (!T1_1.finished) { yield(); } System.out.println(\"T2_1 running...\"); System.out.println(\"T2_1 finished.\"); } } 14. Daemon 執行緒 Daemon 執行緒 Daemon 執行緒的工作是等待別人要求服務,其 run 方法通常是一個無窮迴圈 當其它所有執行緒都結束執行,只剩 Daemon 執行緒時,JVM 便會結束 Daemon 執行緒的執行 Daemon 執行緒通常為系統程式,而非 Daemon 執行緒通常為應用程式,建議前者的優先權應比後者為低 Java 的 Garbage collector 即是一種 Daemon 執行緒 單核多續/多核多續 15. 執行續留意總結 thread runnable 執行續特性 剩下兩個小節沒有要繼續說了，主要是手機會出現的問題 "},"3.JAVA/03.JAVA套件與進階/18.常用資料類型與相關/18-1.常用資料類型與相關.html":{"url":"3.JAVA/03.JAVA套件與進階/18.常用資料類型與相關/18-1.常用資料類型與相關.html","title":"18-1.常用資料類型與相關","keywords":"","body":"目錄 1. Math 類別 2. Math 類別常用方法 3. Math 使用範例 4. String 類別與 StringBuffer 類別 5. StringBuilder 類別 6. Regular Expression 正規表示法 7. Regex 範例與練習 8. 取得日期與時間 9. Calendar 類別常數 10. java.util.Date 類別 11. Calendar 時間用法 12. 時間之 Calendar 與 GregorianCalendar 13. 簡易格式化輸出 14. 簡易格式化輸入 15. 系統屬性 16. 資源回收機制 (Garbage Collection) 17. 列舉類型 18. 排程跟實作 1. Math 類別 java.lang.Math 類別提供許多數學上實用的方法如亂數、絕值、平方根、立方根與三角函數等,讓程式設計師在設計時,省去許多數學運算程式碼的撰寫 因為 java.lang.Math 類別所提供的屬性與方法都是類別等級(都是 static 修飾子),因此我們只要透過 Math 類別名稱,即可呼叫所需的屬性或方法,非常方便 2. Math 類別常用方法 方法 說明 double abs(double a)float abs(float a)int abs(int a)long abs(long a) 回傳a的絕對值 double max(double a, double b)float max(float a, float b)int max(int a, int b)long max(long a, long b) 比較a, b大小後,回傳較大者 double min(double a, double b)float min(float a, float b)int min(int a, int b)long min(long a, long b) 比較a, b大小後,回傳較小者 double pow(double a, double b) 回傳a的b次方運算結果 random() 回傳一個double類型的亂數,值介於0.0(含)~1.0(不含) double sqrt(double a) 回傳a的正平方根 double cbrt(double a) 回傳a的立方根 3. Math 使用範例 範例程式: \"/JavaEx_Part2/src/ch05/TestMath.java\" package ch05; public class TestMath { public static void main(String[] args) { System.out.println(\"Math.PI = \" + Math.PI); System.out.println(\"Math.abs(-1.1) = \" + Math.abs(-1.1)); System.out.println(\"Math.random = \" + Math.random()); System.out.println(\"Math.max(1.1, 2.1) = \" + Math.max(1.1, 2.1)); System.out.println(\"Math.min(1.1, 2.1) = \" + Math.min(1.1, 2.1)); System.out.println(\"Math.pow(3, 3) = \" + Math.pow(3, 3)); System.out.println(\"Math.sqrt(9) = \" + Math.sqrt(9)); System.out.println(\"Math.cbrt(27) = \" + Math.cbrt(27)); } } 4. String 類別與 StringBuffer 類別 String 類別不可在原字串所在記憶體位置改變字串內容 StringBuffer 類別則在原字串所在記憶體位置改變字串內容(append, insert, delete, replace) 使用 StringBuffer 類別中的任何方法時,回傳的字串會使用原有的記憶體空間 StringBuffer 字串與 String 字串不可以比較 SreintBuffer 未 Override equals 方法 如: String s1 = new String(“test”); String s2 = new StringBuffer(“test”); if (s1 == s2) {...} //false if (s1.equals(s2)) {...} //false 範例程式: \"/JavaEx_Part2/src/ch05/TestStringBuffer.java\" package ch05; public class TestStringBuffer { public static void main(String args[]) { StringBuffer sb = new StringBuffer(\"Hello Java \"); sb.append(\"StringBuffer!\"); System.out.println(sb); // Hello Java StringBuffer! StringBuffer sb2 = new StringBuffer(); sb2.append(\"現在是上午\").append(11).append(\"點\"); // 現在是上午11點 StringBuffer sb3 = new StringBuffer(\"Hello StringBuffer!\"); sb3.insert(6, \"Java\"); System.out.println(sb3); // Hello Java StringBuffer! StringBuffer sb4 = new StringBuffer(\"Hello Java StringBuffer!\"); sb4.replace(7, 10, \"AVA\"); System.out.println(sb4); // Hello JAVA StringBuffer! StringBuffer sb5 = new StringBuffer(\"Hello Java StringBuffer!\"); sb5.delete(6, 10); System.out.println(sb5); // Hello StringBuffer! StringBuffer sb1 = new StringBuffer(\"AB\"); System.out.println(\"sb1= \" + sb1); // sb1= AB StringBuffer sb2 = sb1.append(\"CD\"); System.out.println(\"sb1= \" + sb1); // sb1= ABCD System.out.println(\"sb2= \" + sb2); // sb2= ABCD System.out.println(sb1 == sb2); // true 比較址 System.out.println(sb2.equals(sb1)); // true StringBuffer sb = new StringBuffer(\"AB\"); // 需轉成string才能比較 String s = \"AB\"; System.out.println(s3.equals(sb1.toString())); // true } } 5. StringBuilder 類別 StringBuilder 類別是 JDK 5 的新類別,其用法與 StringBuffer 類別完全一樣(append, insert, delete, replace) 老類別 StringBuffer 是 thread-safe(同步) ,新類別 StringBuilder 則是 non-thread-safe 跟 vector , Hashtable 一樣有同步化的優點 使用上,如果不考慮多執行緒的問題可以使用 StringBuilder 來提升執行的效率 6. Regular Expression 正規表示法 正規表示法(Regular Expression)就是由許多樣式的符號組成的樣式句, 主要功能就是用來比對文字是否符合該規則的要求 正規表示法並非 Java 語法,但為了通過編譯,都是以字串型式存在, 等到要執行時,再由特定的編譯器進行處理 正規表示法在本課程會簡略說明,如有興趣的同學可以在網路上搜尋 到更多規則與說明 符號 說明 [ABC] A、B、C任一個字元都符合要求例:[ABC]ook,可以是Aook, Book或Cook [^ABC] 不可以含有A、B、C任一個字元例:[^ABC]ook,就不可以是Aook, Book或Cook [A-C] 可以是A到C連續字元的任何一個例:[A-C]ook,可以是Aook, Book或Cook [^A-C] 不可以含有A到C連續字元的任何一個例:[^A-C]ook,就不可以是Aook, Book或Cook {n,m} 代表指定字元出現次數最少n次,最多m次逗號之間不得有空白,n與m都要是大於等於0的整數n 例:Book{1,2}代表k最少要出現1次,最多2次,即Book或Bookk {n} 代表指定字元正好出現n次例:Book{1}代表k要出現正好1次,所以只能是Book {n,} 代表指定字元至少出現n次 例:Book{1,}代表k要出現至少1次以上,可以是Book, Bookk... \\d 可以是0~9任何一個數字,相當於[0-9] \\D 不可以是0~9任何一個數字,相當於[^0-9] \\s 可以是空白的字元 \\S 不可以是空白的字元 \\w 可以是一個英文字母或數字 \\W 不可以是任何英文字母或數字 ? 指定字元最多出現1次,也可以不出現,相當於{0,1}例:S?PP就可以是PP或SPP。?在S後面,則是S受到?限制 + 指定字元至少要出現1次以上,相當於{1,} * 指定字元出現0次以上,相當於{0,} . 任一字元 ( ) 括弧內,代表同一個群組例:(SPP){2}代表SPP是一體,必須同時出現2次:SPPSPP \\ 取消原運算符號的功能,使其成為單純文字例:2014\\-06\\-13代表取消「-」符號功能,這與Java的跳脫符號「\\」相同,所以結果一定要是2014-06-13 可搭配 String 類別提供的 boolean matches(String regex),回傳是否符 合正規表示法的文字格式 另介紹 String 類別的 String[] split(String regex),符合運算式的部份會 被當做分隔符號移除掉,剩下部份回傳到字串陣列裡 7. Regex 範例與練習 手機號驗證 package ch05; import java.util.Scanner; public class RegTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"請輸入手機號碼\"); String tel = sc.next(); sc.close(); String regex = \"09[0-9]{2}-\\\\d{6}\"; if (tel.matches(regex)) { System.out.println(\"OK\"); } else { System.out.println(\"No good...\"); } } } 身分證字號驗證 官方文件的 java.util.regex 中有詳細使用說明 package ch05; import java.util.Scanner; public class RegTest { public static void main(String[] args) { Scanner sc2 = new Scanner(System.in); System.out.println(\"請輸入身分證\"); String IDcard = sc2.next(); String regex2 = \"[A-Za-z]{1}[12]{1}[0-9]{8}\"; if (IDcard.matches(regex2)) { System.out.println(\"OK\"); } else { System.out.println(\"No good...\"); } // /p{Alpha} 忽略大小寫 String regex3 = \"^\\\\p{Alpha}[12]\\\\d{8}$\"; if (IDcard.matches(regex3)) { System.out.println(\"OK\"); } else { System.out.println(\"No good...\"); } sc2.close(); } } 特殊處裡 範例程式: \"/JavaEx_Part2/src/ch05/TestSplit2.java\" package ch05; public class TestSplit2 { public static void main(String args[]) { String str1 = \"boo:and:foo\"; // 因為不是最後一個字所以中間的O會變成空字串保留 String[] tokens1 = str1.split(\":\"); // { \"boo\", \"and\", \"foo\" } for (int i = 0; i 8. 取得日期與時間 取得今天的日期與現在時間 Calendar rightNow = Calendar.getInstance(); Calendar為抽象類別(因為有設為 static，所以可以用類別直接呼叫方法) java.util.Date rightNow = new java.util.Date(); java.util.Date表示某一時間點(一般是使用 util 中的方法) 其它與日期有關的常用類別還有 GregorianCalendar 此為Calendar 的子類別,適合用來設定某一特定的日期 GregorianCalendar 建構子提供的時間點 java.sql.Date 此為 java.util.Date 的子類別,用在資料庫的日期格式 DateFormat 用來格式化 java.util.Date,可設定國別格式與時區,用在國際化 國際化: i18N (InternationalizatioN) i 中間 18 字母，最後 N SimpleDateFormat 用來格式化 java.util.Date,簡單的日期格式化 註: 利用 Calendar 物件的 getTime()方法,可產生 java.util.Date 物件 java.util.Date du = cal.getTime(); cal 是 Calendar 物件 利用 java.util.Date 物件的 getTime() 方法,可得到自 1970 年 1 月 1 日 0 時 0 分 0 秒起的總毫秒數 long len = du.getTime(); du 是 java.util.Date 物件 1970 年 1 月 1 日 0 時 0 分 0 秒 (這是系統的起始時間，用來紀念 UNIX) 9. Calendar 類別常數 周末是周六，周日是一天的開始 常數名稱 值 注意 Calendar.YEAR 年   Calendar.MONTH 月 得到的值須+1 Calendar.DATE 日   Calendar.HOUR_OF_DAY 24時制的時   Calendar.MINUTE 分   Calendar.SECOND 秒   Calendar.DAY_OF_WEEK 星期幾 得到的值須-1，當索引值操作[\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"] 10. java.util.Date 類別 在 Java 1.0.2 版中 java.util.Date 有數種功能,但在 Java 1.1 開始,其中大部份的方法都已被淘汰(Deprecated),所以 java.util.Date 目前功能就是表示某一時間點 11. Calendar 時間用法 範例程式: \"/JavaEx_Part2/src/ch05/TestCalendar.java\" package ch05; import java.util.Calendar; public class TestCalendar { static String[] week = { \"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\" }; public static void main(String args[]) { // 取得「執行環境」的系統時間 Calendar cal = Calendar.getInstance(); int y = cal.get(Calendar.YEAR); int m = cal.get(Calendar.MONTH) + 1; int d = cal.get(Calendar.DATE); int h = cal.get(Calendar.HOUR); int min = cal.get(Calendar.MINUTE); int sec = cal.get(Calendar.SECOND); System.out.print(\"今天是: \"); System.out.println(y + \"年\" + m + \"月\" + d + \"日\"); System.out.print(\"現在是: \" + (cal.get(Calendar.AM_PM) == 0 ? \"上午\" : \"下午\")); System.out.println(h + \"點\" + min + \"分\" + sec + \"秒\"); int w = cal.get(Calendar.DAY_OF_WEEK) - 1; System.out.println(\"星期\" + week[w]); System.out.println(); } } 12. 時間之 Calendar 與 GregorianCalendar 範例程式: \"/JavaEx_Part2/src/ch05/TestGregorianCalendar.java\" package ch05; import java.util.Calendar; import java.util.GregorianCalendar; public class TestGregorianCalendar { static String[] week = { \"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\" }; public static void main(String args[]) { Calendar cal[] = new Calendar[6]; cal[0] = new GregorianCalendar(2015, Calendar.JANUARY, 15, 0, 0, 0); // 到秒 second cal[1] = new GregorianCalendar(2014, Calendar.JANUARY, 1, 0, 0); // 到分 minute cal[2] = new GregorianCalendar(2014, Calendar.JUNE, 1); // 到日 month cal[3] = new GregorianCalendar(); // 現在 cal[4] = new GregorianCalendar(); cal[5] = new GregorianCalendar(1991, (5 - 1), 29); for (int i = 0; i 13. 簡易格式化輸出 Simple Formatter Output(簡易的格式化輸出:printf) JDK 5 新增 System.out.printf()方法 printf() 方法源自於 java.util.Formatter 類別 比如只需寫出: \"%tY/% 沿用前面使用的參數資料 即可輸出:2014/06/13 17:38:20 之結果 java.util.Date d = new java.util.Date(); System.out.printf(\"%tY/% 範例 TestFormatter.java (printf()對照 DecimalFormat 與 SimpleDateFormat 類別) TestDateFormat.java (熟悉 java.text.DateFormat 類別之應用) SimpleDateFormat 可以直接對日期做簡易格式化 Format sfm = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\"); 範例程式: \"/JavaEx_Part2/src/ch05/TestFormatter.java\" package ch05; import static java.lang.System.out; import java.text.DecimalFormat; import java.text.Format; import java.text.SimpleDateFormat; import java.util.Date; public class TestFormatter { public static void main(String[] args) { out.println(\"------------------數字格式化-------------------\"); double num1 = 12345.678; out.println(num1 + \"【格式化之前】\\n\"); // 使用DecimalFormat類別 Format dfm1 = new DecimalFormat(\"#,###.00\"); out.println(dfm1.format(num1) + \"【使用DecimalFormat類別格式化】\"); // 使用printf out.printf(\"%,.2f【使用printf格式化】%n\", num1); out.println(\"\\n------------------日期格式化-------------------\"); Date d1 = new Date(); out.println(d1 + \"【格式化之前的java.util.Date】\\n\"); Format sfm1 = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\"); out.println(sfm1.format(d1) + \"【使用SimpleDateFormat類別格式化】\"); Format sfm2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); out.println(sfm2.format(d1) + \"【使用SimpleDateFormat類別格式化】\\n\"); out.printf(\"%tY/% 範例程式: \"/JavaEx_Part2/src/ch05/TestDateFormat.java\" package ch05; import java.text.DateFormat; import java.util.Locale; import java.util.TimeZone; public class TestDateFormat { public static void main(String[] args) { // 隨地區語言而變, 如 Locale[] locale = new Locale[5]; locale[0] = Locale.TAIWAN; // new Locale(\"zh\",\"TW\"); locale[1] = Locale.US; // new Locale(\"en\",\"US\"); locale[2] = Locale.JAPAN; // new Locale(\"ja\",\"JP\"); locale[3] = Locale.KOREA; // new Locale(\"ko\",\"KR\"); locale[4] = Locale.GERMANY; // new Locale(\"de\",\"DE\")等不同地區語言 for (int i = 0; i 14. 簡易格式化輸入 Simple Formatter Input(簡易的格式化輸入:Scanner) 如 JDK 5 之前的版本要從鍵盤讀入整數值的作法 InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); int n = Integer.parseInt(s); JDK 5 以後的版本可改寫成? int n = sc.nextInt(); Scanner sc = new Scanner(System.in); String s = sc.next(); int n = sc.nextInt(); 15. 系統屬性 系統屬性(System Properties)可以顯示系統的環境資訊 public static Properties getProperties(): 取得所有的系統屬性 回傳 Properties 類別的物件 public static String getProperty(String key): 回傳特定系統屬性名稱的值 public static String setProperty(String key, String value): 設定特定的系統屬性 要設定系統屬性,也可在程式執行時設定 java –DmyProperty=myValue HelloWorld -D 與屬性之間不得有任何空白字元 16. 資源回收機制 (Garbage Collection) 通常 Java 會在記憶體不足時,自動執行垃圾收集的動作 如果想要自己強制 Java 進行垃圾收集時,可透過使用 System.gc();的方法 JVM 將記憶體空間最佳化後,就會將控制權還給原來進行中的程式 嚴格來講 System.gc();只是建議系統應啟動 GC,它不一定會完全執行,我們也不知道 GC 的正確啟動時間 17. 列舉類型 列舉類型(enum) 列舉 enum 適合使用在某些狀況的表現(如:一年有四季、一週有七天) enum 除了常數設置功能外,還給了您許多編譯時期的檢查功能 enum 的特性 enum 本質上還是一個類別,編譯器會將 enum 轉成類別,其內部除可定義本身的 enum types(列舉子)外,仍可以有 fields、methods 跟 constructors,但與一般類別不同的是: enum 本身不具備類別的某些功能,如繼承 constructors 不能為 public 和 protected,因 enum 型別不能產生物件 必需使用關鍵字 enum 定義列舉型態 enum 型態預設繼承自 java.lang.Enum 類別 enum types(列舉子)預設為 public static final 列舉子的值其實是它本身的名稱 它可以和泛型以及增強型 for 迴圈(for-each)很好地搭配 它也可以使用在 switch 控制中 範例程式: \"/JavaEx_Part2/src/ch05/EnumeratedTypes1.java\" package ch05; /* 將數個參考值或名稱集合在一起。 這種集合的方法，並不是陣列，也不屬於容器。通常我們之它為列舉： enum Month 是一個類別，姑且可稱之為列舉類別。 - 列舉本身就是一種型別 - 從 getClass() 中即可看出來是個類別。 */ enum Month { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } public class EnumeratedTypes1 { public static void main(String[] args) { for(Month xx : Month.values()) { // 增強式的 for 迴圈 System.out.print(xx + \" \"); } System.out.println(); Month yy = Month.JAN; System.out.println(yy); // JAN , 列舉子的值其實是它本身的名稱 System.out.println(yy.getClass()); // class Month } } 範例程式: \"/JavaEx_Part2/src/ch05/EnumeratedTypes2_1.java\" package ch05; /*更複雜的列舉定義 底下示範了一個比較複雜的例子，由這個例子中可以看出， 列舉其實只是一種比較特殊的類別， 所以我們也才一直稱呼 enum 為列舉「型別」。 它可以擁有自訂建構式、欄位以及方法， */ enum SuitA { club(1), diamond(2), heart(3), spade(4); private int value; // 欄位 SuitA(int value) { // 因為設定 club(1), ..，所以必須要撰寫此一建構式 this.value = value; } public int getValue() { // 方法 return value; } public void setValue(int value) { this.value = value; } } public class EnumeratedTypes2_1 { public static void main(String[] args) { for (SuitA suit : SuitA.values()) { System.out.println(suit + \"=\" + suit.getValue()); } SuitA suit = SuitA.diamond; System.out.println(suit.getValue()); suit.setValue(10); System.out.println(suit.getValue()); } } 範例程式: \"/JavaEx_Part2/src/ch05/EnumeratedTypes2_2.java\" package ch05; /*更複雜的列舉定義 底下示範了一個比較複雜的例子，由這個例子中可以看出， 列舉其實只是一種比較特殊的類別， 所以我們也才一直稱呼 enum 為列舉「型別」。 它可以擁有自訂建構式、欄位以及方法， */ enum SuitB { spade(\"黑桃\"), heart(\"紅心\"), diamond(\"方塊\"), club(\"梅花\"), ; private String type; // 欄位 SuitB(String type) { // 因為設定 club(\"梅花\"), ..，所以必須要撰寫此一建構式 this.type = type; } public String getType() { // 方法 return type; } public void setType(String type) { this.type = type; } } public class EnumeratedTypes2_2 { public static void main(String[] args) { for (SuitB suit : SuitB.values()) { System.out.println(suit + \"=\" + suit.getType()); } // spade=黑桃 heart=紅心 diamond=方塊 club=梅花 SuitB suit = SuitB.spade; System.out.println(suit.getType()); // 黑桃 suit.setType(\"※我是黑桃\"); System.out.println(suit.getType()); // ※我是黑桃 } } 列舉的更多應用 範例程式: \"idv.david.additional.enumevo\" 18. 排程跟實作 範例程式: \"/JavaEx_Additional/src/schedule/MyTask.java\" package schedule; import java.util.Date; import java.util.TimerTask; public class MyTask extends TimerTask { @Override public void run() { System.out.println(\"執行時間為： \" + new Date()); } } 範例程式: \"/JavaEx_Additional/src/schedule/TestSchedule.java\" package schedule; import java.util.Calendar; import java.util.Date; import java.util.Timer; public class TestSchedule { public static void main(String[] args) { TestSchedule ts[] = new TestSchedule[3]; for (int i = 0; i 補足之前所有排程，與忽略之前所有排程 範例程式: \"/JavaEx_Additional/src/schedule/Scheduler.java\" package schedule; import java.util.Calendar; import java.util.GregorianCalendar; import java.util.Timer; public class Scheduler { public static void main(String[] args) { Timer timer = new Timer(); Calendar cal = new GregorianCalendar(2017, Calendar.FEBRUARY, 1, 0, 0, 0); // 補足所有未執行排程，補足後由設定時間每一分鐘值行一次 timer.scheduleAtFixedRate(new MyAnotherTask(), cal.getTime(), 1 * 60 * 1000); // 當下每分鐘值行 timer.schedule(new MyAnotherTask(), cal.getTime(), 1 * 60 * 1000); } } "},"3.JAVA/04.JDBC與資料庫的連接/01.JDBC之初/01.JDBC新手村.html":{"url":"3.JAVA/04.JDBC與資料庫的連接/01.JDBC之初/01.JDBC新手村.html","title":"01.JDBC 新手村","keywords":"","body":"JDBC 簡介 關聯式資料庫(Relational DataBase Management System) 以表格方式儲存與呈現資料,再用數學集合論為基礎,將表格與表格之間建立關聯以處理複雜的資料關係 如 Oracle Database, MySQL, 微軟 SQL Server, IBM 的 DB2 等 非關聯式資料庫(又稱 NoSQL) 分散式進行資料儲存,可區分三大類:文檔儲存、圖形關係儲存與鍵值儲存(key – value) 如 Google 的 BigTable, MongoDB, Cassandra 等 資料庫本身是一個獨立運行的應用程式,所以我們設計的應用程式得利用網路通訊協定對資料庫進行指令交換,以便進行資料的 CRUD (Create Update delete Review，增刪改查) 但實作上我們會使用一組專門與資料庫進行通訊協定的類別庫來簡化與資料庫溝通的程式撰寫 應用程式 類別庫 ← 通訊協定 → 資料庫 問題 不同廠商資料庫的通訊協定都不一樣,需使用不同類別庫撰寫程式 遇到更換資料庫,程式碼也幾乎跟著要重寫 應用程式被類別庫綁死,跨平台議題考量(?) 解決 使用 JDBC 解決 Java 提供一組資料庫存取 API,名為JDBC(Java DataBase Connectivity) JDBC 是用於執行 SQL(搭配關聯式資料庫)的解決方案,Java 應用程式開發人員使用 JDBC的標準介面,而資料庫廠商則對介面進行實作。因此應用程式開發人員就不需接觸到底層資料庫的驅動程式 JDBC API 使得應用系統開發者能使用相同的介面名稱與方法來存取資料庫的資料,讓程式設計師能專心於應用系統的開發,無需顧慮到不同廠商所提供的不同資料庫系統 JDBC API 已包含在 JDK 裡 ★ 會考 java.sql: JDBC 的核心 API,用來存取資料庫資料,基本功能 ★ 會考 javax.sql: JDBC Extension API,支援進階資料庫存取功能 JDBC 標準 API 分為兩個部份 JDBC 應用程式開發者介面 (Application Developer Interface) JDBC 驅動程式開發者介面 (Driver Developer Interface) 本課程使用 JDBC 應用程式介面與關聯式資料庫進行說明與範例測試 註: 驅動程式為資料庫廠商實作,一般開發者無須瞭解 JDBC API Interface Statement 相關對應到 SQL 指令的執行 PreparedStatement ResultSet 對應到資料庫查詢結果 Driver Connection Class DriverManager Exception SQLException 一定要處裡的例外 JDBC Driver 目的 分層目的就是降低對資料庫的相依性 應用程式 JDBC API MySQL JDBC Driver ← MySQL 通訊協定 → MySQL 資料庫 應用程式 JDBC API Oracle JDBC Driver ← Oracle 通訊協定 → Oracle 資料庫 依廠商實作 JDBC 方式,可以分成以下四種類型: Type 1: JDBC-ODBC Bridge Driver 為 JDK 安裝即附,將 JDBC 的運作轉成 ODBC 的機制來連接資料庫,存取速度與功能均有受限,彈性不足,建議在無其它 driver 可以使用時才用 Type1 的 driver (註: JDK 8 已將 ODBC 相關類別庫移除) Type 2: Native API Driver 此類型 driver 會以原生(Native)方式呼叫資料庫提供的原生程式庫(通常是 C/C++ 實作),因為採用原生方式,故存取速度為四種類型最快但沒有達到跨平台的目標,需要在各平台先行安裝資料庫所屬的原生程式庫 Type 3: JDBC-Net Driver 此類型 driver 會將 JDBC 呼叫轉換為特定的網路協定(Protocol),由中介伺服器或元件跟資料庫進行操作,使用此類型 driver 好處是軟體架構可獲得彈性,但速度會較慢 Type 4: Native Protocol Driver 此類型 driver 通常由資料庫廠商直接提供,會將 JDBC 呼叫轉換為與資料庫特定的網路協定,driver 可以完全用 Java 技術實現,因此達到跨平台功能,效能也有不錯表現,為業界最常見的driver類型 JDBC Driver 載入 載入 JDBC Driver 有三種方式: Class Loader 方式 register 方式 System Property 方式 採用 Class Loader 方式產生 Driver 實體,並註冊到 DriverManager 的驅動程式註冊表單中 參數就是提供 class 的完整名稱(含套件名稱) Class.forName(\"com.mysql.jdbc.Driver\"); ★ 常用 Class.forName(\"oracle.jdbc.driver.OracleDriver\"); Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); Class.forName(\"com.ibm.db2.jdbc.app.DB2Driver\"); 採用 register 方式產生 Driver 實體,並將自己註冊到 Driver Manager 驅動程式註冊表單中 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver()); 採用 System Property 方式 System.setProperty(\"jdbc.drivers\", \"com.mysql.jdbc.Driver\"); 可以包含數個 drivers,彼此之間以冒號(:)隔開 Connection 介面 Connection 代表資料庫的一個連線通路,傳遞一系列的 SQL 指令給資料庫,並管理這些指令的認可與中止 Connection con = DriverManager.getConnection(String url, String userID, String password); 以資料庫 URL 做為引數產生 Connection 物件來連接資料庫 DriverManager 在驅動程式註冊表單搜尋 driver,一旦 driver 認得此 url,便會依據 url 的資訊連接資料庫 Connection 非常珍貴,使用完畢後務必完成歸還的動作! 資料庫 URL 為一字串,用以說明連接某一特定資料庫所需要的資訊,包含資料庫位址、埠號、名稱等 埠號: Port Number 埠號 ，有 65536 個(0~65535)，只要有網路通訊就會用到埠號 0-1024 間的埠號世界默認不使用 資料庫 URL 格式: jdbc:: 「jdbc」: 引用 jdbc 必出現 \"jdbc:mysql://\" + serverName + \":3306/\" + DBName jdbc:mysql://localhost:3306/HR \"jdbc:oracle:thin:@\" + serverName + \":1521\" + SID jdbc:oracle:thin:@localhost:1521:xe SID: 依照資料庫連線設定修改 \"jdbc:sqlserver://\" + serverName + \":1433:databaseName=\" + DBName jdbc:sqlserver://localhost:1433:databaseName=HR close(): 歸還資源 Connection 是極為重要的資源,建議寫在finally{}裡 finally { if (con != null) { try { con.close(); } catch (SQLException e) {...} } 自 JDK 7 開始,若將有實作 AutoCloseable 介面的物件置於 try{}裡,try{} 結束時,Java 會自動將該物件 close JDK 7 裡,Connection 介面 extends AutoCloseable 介面 由於仍有可能使用 JDK 7 以前的版本,故還是寫在 finally{}較保險 Statement 介面 Statement createStatement(): 建立可陳述 SQL 指令的 statement 物件 PreparedStatement prepareStatement(String sql): 資料庫可預先編譯 SQL 指令,執行效能較快,常用於需變數傳遞且重覆執行的 SQL CallableStatement prepareCall(String sql): 使用預存程序(stored procedure),預存程序已事先內建在資料庫中,通常比預先編譯的效能佳 藉由 Statement 相關物件,才能使用 SQL 指令與資料庫交談 用來陳述 SQL 指令,執行靜態的 SQL 指令 執行 SQL 指令的主要兩個方法 ResultSet executeQuery(String sql): 查詢資料庫,傳回資料列 用於 SQL 的 SELECT 指令 int executeUpdate(String sql): 更新資料庫,傳回成功更新的筆數 用於 SQL 的 INSERT、UPDATE 與 DELETE 指令 close(): 歸還資源 ResultSet 介面 查詢資料庫後傳回的資料列 移動資料列游標的相關方法 next()、previous()、first()、last()、beforeFirst()、afterLast() next()傳回 boolean 值 測試目前資料列指標位置的方法 isFirst()、isLast()、isBeforeFirst()、isAfterLast() 註:部份移動游標方法為 JDBC 2.0 時新增,需在建立 Statement 時設定! 游標起始位置(第一列資料上面) → 有值，next() = true deptno dname loc → 有值，next() = true 10 財務部 台北 → 有值，next() = true 20 研發部 新竹 → 沒值，next() = false 30 業務部 紐約 因為此位置沒有資料列，next() 會回傳 false 取出查詢結果資料欄的方法 有 type getType(int columnIndex)或 type getType(String columnName) index從1開始,一般來說使用 index 較有效率 (必須注意查詢結果的欄位順序) getBoolean()、getByte()、getShort()、getInt()、getLong()、getFloat()、getDouble()、getString()、getDate()、getTime()、getTimestamp()、getBinaryStream()... 配合欄位資料類型，呼叫對應的 getxxx() 方法 其它方法 int getRow():取得目前的列編號,若傳回 0,表示游標不在任一列上,可能在第一列前或最後一列後 開始寫程式 開啟資料庫權限 創造 User 並設定連線 Granted Roles > Grant All System Privileges > Grant All 跳出錯誤 > OK > Close Close 後即建立成功，錯誤題式的意思是表示內含系統權限 項目引入 JAR 操作參考: \"02.JAVA 開發環境建立/2-3.Eclipse 各種操作/16. Eclipse 引入類別函式庫(第三方或自己的)\" 引入檔案: \"ojdbc6.jar\" 內容撰寫 package jdbctest; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class HelloJDBC { private static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private static final String USER = \"DAVID\"; private static final String PASSWORD = \"123456\"; private static final String INSERT_STMT = \"INSERT INTO DEPARTMENT (DEPTNO, DNAME, LOC) VALUES (50, '衛服部', '桃園中壢')\"; private static final String GET_ALL = \"SELECT * FROM DEPARTMENT\"; public static void main(String[] args) { // 為了搭配資源關閉，故需自行設定 try-catch Connection con = null; Statement stmt = null; ResultSet rs = null; try { // step 1: 載入驅動 Class.forName(DRIVER); System.out.println(\"載入成功\"); // step 2: 建立連線 con = DriverManager.getConnection(URL, USER, PASSWORD); System.out.println(\"連線成功\"); // step 3: 執行SQL指令 stmt = con.createStatement(); // 資料更新 int count = stmt.executeUpdate(INSERT_STMT); System.out.println(\"更新\" + count + \"筆資料\"); // 資料查詢 rs = stmt.executeQuery(GET_ALL); // 查詢方法1 while (rs.next()) { // 讀下一列(有值: true，沒值:false) int deptno = rs.getInt(\"DEPTNO\"); // getInt(欄位名); 欄位名大小寫不影響 String dname = rs.getString(\"DNAME\"); // getString(欄位名) String loc = rs.getString(\"LOC\"); System.out.println(\"DEPTNO = \" + deptno); System.out.println(\"DNAME = \" + dname); System.out.println(\"LOC = \" + loc); System.out.println(\"------------------\"); } // 查詢方法2 while (rs.next()) { // 讀下一列(有值: true，沒值:false) int deptno = rs.getInt(1); // getInt(欄位名); 欄位名大小寫不影響 String dname = rs.getString(2); // getString(欄位名) String loc = rs.getString(3); System.out.println(\"DEPTNO = \" + deptno); System.out.println(\"DNAME = \" + dname); System.out.println(\"LOC = \" + loc); System.out.println(\"------------------\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { // 越晚建立的越早關閉 if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt != null) { try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } // 連線不為空 關閉連線 if (con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } "},"4.Oracle/0.Oracle淺談/0-1.淺入Oracle.html":{"url":"4.Oracle/0.Oracle淺談/0-1.淺入Oracle.html","title":"0-1.淺入 Oracle","keywords":"","body":"目錄 1. client server 架构 1. client server 架构 client 端 > server 端 server 端: server > db client 端: PC "},"4.Oracle/1.Oracle安裝/1-1.Oracle安裝與各種設定.html":{"url":"4.Oracle/1.Oracle安裝/1-1.Oracle安裝與各種設定.html","title":"1-1.Oracle 安裝與各種設定","keywords":"","body":"目錄 1. Oracle 安裝 2. 刪除雲資料庫快捷 3. 開啟/停用 Database 4. cmd 指令測試是否安裝成功 5. 啟用 Oracle SQL Developer 6. Oracle 修改語系 7. Oracle 建立本機連線 8. Oracle 建立外部連線 9. Oracle 修改編碼格式 UTF-8 10. Oracle 修改可還原次數 11. Oracle 建立使用者 12. Oracle 刪除使用者 13. Oracle 自訂快捷 14. Oracle 匯入檔案 15. Oracle 修改預設字體大小 16. Oracle 修改預設字體 17. Oracle 顯示行號 1. Oracle 安裝 下載 OracleXE 版，並解壓 點擊 setup.exe 安裝 進入安裝步驟 選擇安裝目錄 輸入帳號密碼 (此為系統帳號，且帳密區分大小寫) 若後續帳號丟失則須重新安裝資料庫 安裝完成 進行安裝時可能會在進度 99%時卡很久，只要等待即可 2. 刪除雲資料庫快捷 因為連結是錯誤的，所以直接刪除此快捷就好 3. 開啟/停用 Database Start Database 開啟 Stop Database 停用 4. cmd 指令測試是否安裝成功 輸入指令 sqlplus / as sysdba 5. 啟用 Oracle SQL Developer 下載 sqldeveloper-19.2.1.247.2212-no-jre.zip 並解壓縮 此版本有解決 1.7 版的輸入中文即會造成編輯器崩潰的情形 選擇 jdk 安裝目錄 開始安裝 安裝完成 後續開啟位置 6. Oracle 修改語系 修改 sqldeveloper.conf D:\\sqldeveloper\\sqldeveloper\\bin\\sqldeveloper.conf 添加 AddVMOption -Duser.language=en 重新運行後介面即是英文版 7. Oracle 建立本機連線 Connections > New Connections... 設定新連線名稱 Name:system > 輸入帳號密碼 > save > Connect 連線成功 連線成功後完整畫面 8. Oracle 建立外部連線 設定防火牆 右鍵輸入規則 > 新增規則 > 連接埠 特定本機連接埠為 1521 下一步 下一步 自訂名稱 > 完成 9. Oracle 修改編碼格式 UTF-8 Tools > Preferences... 選擇 UTF-8 10. Oracle 修改可還原次數 Tools > Preferences... > Code Editor > Undo Behavior 可將文字編輯器還原次數調高 11. Oracle 建立使用者 system > Other Users 右鍵 Other Users > Create User User > 設定 User Name... Granted Roles > 勾選 CONNECT、DBA、RESOURCE 設定完成 (建立好帳號並不會同時關聯資料庫，若須建立連線請參照: 建立本機連線 12. Oracle 刪除使用者 13. Oracle 自訂快捷 Tools > Preferences... > Shortcut Keys 14. Oracle 匯入檔案 Open... 選擇檔案 > open 15. Oracle 修改預設字體大小 Tools > Preferences... > Code Editor > Fonts > Font Size 16. Oracle 修改預設字體 Tools > Preferences... > Code Editor > Fonts > Font Name 17. Oracle 顯示行號 Tools > Preferences... > Code Editor > Line Gutter > 勾選 Show Line Numbers "},"4.Oracle/2.資料庫介紹/2-01.資料庫介紹.html":{"url":"4.Oracle/2.資料庫介紹/2-01.資料庫介紹.html","title":"2-01.資料庫介紹","keywords":"","body":"目錄 1. Oracle 建立資料庫 2. 資料庫管理系統 3. 程式產線 4. 接案 5. 面試問題 1. Oracle 建立資料庫 Oracle 沒有指令建立資料庫，因為創建好帳號即有資料庫 2. 資料庫管理系統 資料庫管理系統(DBM) 使用者 人工智慧/大數據 資料庫設計師(Database Designer，SA) 設計整個資料庫 資料庫管理師(Database Administrator，DBA) 資料管理與分析 應用程式設計師(Application Designer，APP) 使用程式連接到資料庫(Java、C#、C++...) JAVA 通常撰寫 JAVA WEB APP (程式設計師) 一般使用者(End User) 3. 程式產線 產品競標 商品規格 價格 ... 專案小組 專案經理 (Project Manger，PM) 以事管人 系統分析師 (System Analyst，SA) 3 年升 PM 程式設計師 (Programmer，PG) 2 年升 SA 歸類在 RD(Research and Development engineer 研發設計工程師) 部門 無經驗: 35~45k 4. 接案 會不會做 做多久 多少錢 5. 面試問題 未來的職稱是 PG 嗎? 未來是否歸屬在 RD 部門? 是否有專案經理對外? 需要經常與客戶溝通嗎? 薪水福利? 每周會議的時間大約多久? 加班的部分怎樣可以報? 上下班的彈性時間是? 有沒有產假、經期假那些? "},"4.Oracle/2.資料庫介紹/2-02.ACID規則.html":{"url":"4.Oracle/2.資料庫介紹/2-02.ACID規則.html","title":"2-02.ACID 規則","keywords":"","body":"目錄 1. 交易管理 (Transaction Management) 2. 單元性 (Atomicity) 3. 一致性 (Consistency) 4. 隔離性 (Isolation) 5. 永久性 (Durability) 6. 關聯式資料庫 (Relational Database) ACID 規則 1. 交易管理 (Transaction Management) 對資料庫執行一個交易可能包含一連串的新增、修改或刪除 指令。為了保證交易的正確與可靠,必須符合 ACID (Atomicity, Consistency, Isolation, Durability) 2. 單元性 (Atomicity) 交易中所含有的所有運算，不是完全做完就是完全不做 A 從自己帳戶匯款 1000 至 B， A 帳戶-1000，B 帳戶+100 都需做完。 執行中發生錯誤必須回復 (roll back) 到尚未匯款前的狀態 3. 一致性 (Consistency) 交易前後都沒破壞資料庫的完整性，完全符合資料庫定的規則。 帳戶扣的金額與 B 增加的金額一致 4. 隔離性 (Isolation) 同一筆資料在一個交易尚未完成前不可以讓其他交易執行更改， 也就是預防同時性(synchronization)可能造成的錯誤 A、B 同時匯款 1000 給 C。當 A 給 C 時必須鎖定 C 帳戶， 直到匯款結束才能讓 B 匯款至 C 5. 永久性 (Durability) 交易一旦成功，對資料的變更即永久有效，即使系統故障也不影響 需仰賴資料庫輩分與交易日至(log) 系統告訴 A 提款成功，但其實這筆交易紀錄還在磁碟暫存區等待確定， 交易資料會遺失 6. 關聯式資料庫 (Relational Database) Edgar Frank Codd 資料庫之父 由關聯式設計出來的系統，叫關聯式資料庫管理系統(Relational Database Management System，RDBMS) 億兆筆數以下的最佳選擇(但被 google 拋棄，因為執行效能太差) "},"4.Oracle/2.資料庫介紹/2-03.為什麼要採用關聯式資料庫.html":{"url":"4.Oracle/2.資料庫介紹/2-03.為什麼要採用關聯式資料庫.html","title":"2-03.為什麼要採用關聯式資料庫","keywords":"","body":"目錄 1. 為什麼要採用關聯式資料庫 2. 關聯式資料庫與大數據資料庫 1. 為什麼要採用關聯式資料庫 將所有資料都存在一個表格內會有資料重複問題，如果資料量大會造成 浪費儲存空間 資料錯誤率提高 增加修改上困難 2. 關聯式資料庫與大數據資料庫 關聯式資料庫會將表格正規化，並去重，優化資料庫空間，增加搜尋時間 大數據資料庫不將表格正規化，不去重，表格無限大，加快資料搜尋速度 關聯式資料庫只能處理億筆以下的數據 大數據資料庫處理兆筆以上的數據，故硬體需要非常雄厚 非關聯式資料庫就是大數據資料庫 參考鏈接 資料庫年佔比例 程式語言年佔比 OpenJDK 換成免費且合法的 JDK/JRE "},"4.Oracle/2.資料庫介紹/2-07.主鍵與外來鍵.html":{"url":"4.Oracle/2.資料庫介紹/2-07.主鍵與外來鍵.html","title":"2-07.主鍵與外來鍵","keywords":"","body":"目錄 1. 主鍵(Primary Key,PK) 2. 外來鍵 (Foreign Key,FK) 3. PK 與 FK 都是 constraint? 4. 其他鍵介紹 1. 主鍵(Primary Key,PK) 主鍵欄位內的值唯一且不可重複 主鍵欄位是個重要的辨識欄位 所以會設定為 NOT NULL 2. 外來鍵 (Foreign Key,FK) 必須為了關聯而存在 必須參照到另個表格的主鍵 主鍵需有值才能關聯 FK 必須參照到 PK 如果 PK 當中沒值但 FK 又創建好了，則此欄位會變成斷頭資料 有 FK 資料的 PK，不可以隨意刪除 FK 是為了防止斷頭資料 3. PK 與 FK 都是 constraint? 簡而言之，兩個都是為了防呆而出現的 4. 其他鍵介紹 複合主鍵 (Composite primary key) 2~3 個 key 合併起來後，組成一個具有唯一性的鍵 超鍵 (Super Key) 符合唯一性 候選鍵 (Candidate Key) 唯一且最小 主鍵由候選鍵挑出 次要鍵 (Alternate Key) 沒被選為主鍵的其他 "},"4.Oracle/2.資料庫介紹/2-10.資料庫正規化.html":{"url":"4.Oracle/2.資料庫介紹/2-10.資料庫正規化.html","title":"2-10.資料庫正規化","keywords":"","body":"目錄 1. 第一正規化(1NF) 2. 第二正規化(2NF) 3. 第三正規化(3NF) 4. 總結 5. 簡單的形容 1. 第一正規化(1NF) 欄位內都是存單一值 原始表格 PUBLISHER PUBLISHER_ID PUBLISHER_NAME PHONE P001 O'Reily 02-23456789,02-23789456 P002 Jhon Wiley,Sons Inc 02-78543621,02-54679841 P003 Manning Publications 04-46578312 開始拆分成單一值 PUBLISHER PUBLISHER_ID PUBLISHER_NAME P001 O'Reily P002 Jhon Wiley,Sons Inc P003 Manning Publications PUBLISHER PUBLISHER_ID PHONE P001 02-23456789 P001 02-23789456 P002 02-78543621 P002 02-54679841 P003 04-46578312 2. 第二正規化(2NF) 它符合第一正規化 所有非鍵欄位都不能是候選鍵非全體欄位的函式 每個資料必須各自相依於鍵欄位 3. 第三正規化(3NF) 符合第二正規化 非鍵欄位堅不應有相依性，否則應予移除 SUB_TOTAL 欄位相依於 2 個非鍵欄位，PRICE、QUANTITY，所以 SUB_TOTAL 應移除 有欄位需要依照其他欄位的值更動而更動，需移除 ORDER_DETAIL ORDER_ID ISBN PRICE QUANTITY SUB_TOTAL ord001 123456 500 10 5000 ord001 456132 400 5 2000 ord002 123456 600 5 3000 ORDER_DETAIL ORDER_ID ISBN PRICE QUANTITY ord001 123456 500 10 ord001 456132 400 5 ord002 123456 600 5 4. 總結 檢查有存複數資料的欄位並拆開，並依照 PK 值拆表格 在依照候選 PK 拆表格 繼續檢查非 PK 值間，是否有關係，沒關係就移除。 如果這時還有關係的話，應該能由其他欄位計算出來，那樣此欄位應該不要出現，避免浪費空間 5. 簡單的形容 資料庫就跟硬碟中保存資料一樣，使用正規化就是為了不要太容易把磁碟塞滿 如果需要開拓出空間就需要做磁碟清理 資料分得清楚的化，以後蒐資料就得一層一層的進入指定資料夾並查看，因為得一個個打開所以速度慢，但整理的時候就可以將非必要資料避免存在 如果資料都全放在一個資料夾則要查資料就在一個資料夾內看就好，但是可能會有很多重複的細節，這會造成你需要存這麼多有用跟無用的資料就要硬碟夠大 "},"4.Oracle/2.資料庫介紹/2-13.違反正規化.html":{"url":"4.Oracle/2.資料庫介紹/2-13.違反正規化.html","title":"2-13.違反正規化","keywords":"","body":"目錄 1. 違反正規化 2. 違反正規化案例 1. 違反正規化 為了避免資料重複性而導致日後資料過多而降低執行效能，要盡量遵守正規化 除非要計算的資料非常花時間，才會建立欄位加以儲存，以避免要用到該資料時，都得再次浪費時間去計算 STATION 1 台北車站 台北市中正區北平西路 3 號 25.048054 121.517020 2 台中車站 台北市中區台灣大道一段 1 號 24.137340 120.686783 3 高雄車站 高雄市三民區建國二路 320 號 22.639766 120.302121 2. 違反正規化案例 地圖座標 修改次數少，所以座標可以保留然後跟實際座標做比對 推薦文章、商品(SignalR 可以同步更新讚數) 至頂推薦文章 應該每日更新，或是每次點擊後觸發更新資料庫 會在文章主檔增加欄位，總按讚數。明細表也增加 "},"4.Oracle/3.建立資料庫/3-01.視覺化建立表格.html":{"url":"4.Oracle/3.建立資料庫/3-01.視覺化建立表格.html","title":"3-01.視覺化建立表格","keywords":"","body":"目錄 1. 建立表格 2. 刪除表格 3. 介面化創建檢查效果 4. 新增表單值 1. 建立表格 Tables 右鍵 > New Table 添加欄位等細項 NUMBER 自訂精準數 NUMBER(總位數,小數位數) CHAR VARCHAR2 不確定字元長度就選這個 DATE 儲存日期 TIMESTAMP 自動創建當日時間: Default > CURRENT_TIMESTAMP 2. 刪除表格 表格右鍵 > Table > Drop... 3. 介面化創建檢查效果 Constrains > Check > Check Condition > 寫入條件 4. 新增表單值 打開表單 > Data > + > 新增數據 > √ "},"4.Oracle/3.建立資料庫/3-02.建立表格.html":{"url":"4.Oracle/3.建立資料庫/3-02.建立表格.html","title":"3-02.建立表格","keywords":"","body":"目錄 1. 設計流程 2. 常用資料類型 3. 指令法建立表格 4. 表格創建 5. 查看創建結果 6. 查看表格 7. 創建並加上檢查效果 8. 建立外來鍵 1. 設計流程 制定欄位 蒐集資料 查閱紙本表單或紀錄 與相關人員訪談 觀摩實際狀況 正規化 以資料結構的角度分析欄位的歸屬與表格的關聯 減少重複過冗，增進資料的一致性 2. 常用資料類型 數字 文字 VARCHAR 沒固定長度時用此資料類型建立 1~4000 字元 日期時間 大型物件 3. 指令法建立表格 滑鼠點擊過的地方，Oracle 會自動抓取上個結束點到下個結束點範圍的程式碼去執行 選擇連線的資料庫 (確定在哪邊創建此表單，有相同名稱的表格不可重複建立) 4. 表格創建 SQL > 將指令寫在文件中 輸入 Oracle[1]指令[2] CREATE TABLE CUSTOMER( CUSTOMER_ID VARCHAR2(40) PRIMARY KEY NOT NULL, CUSTOMER_NAME VARCHAR2(40) NOT NULL, PHONE VARCHAR2(40) NOT NULL, ADDRESS VARCHAR2(200) NOT NULL ); Start > 建立完成 建立完成結果 Table CUSTOMER created. 5. 查看創建結果 點擊指定表格 > Constraints 6. 查看表格 使用 DESCRIBE 表單名稱 DESCRIBE PUBLISH Name Null? Type ------------- -------- ------------- CUSTOMER_ID NOT NULL VARCHAR2(40) CUSTOMER_NAME NOT NULL VARCHAR2(40) PHONE NOT NULL VARCHAR2(40) ADDRESS NOT NULL VARCHAR2(200) 7. 創建並加上檢查效果 鍵名 資料型別 Constrains PRICE NUMBER(8,2) CHECK (PRICE >= 0) 8. 建立外來鍵 KEY 名(PUBLISHER_ID)可不相同，但資料類型與資料大小需相同 FOREIGN KEY (鍵名) REFERENCES 表名(鍵名) 程式語言(指具有流程控制的語言) ; Sql 本身不算程式語言，但 Oracle 有新增 PLC ↩︎ Oracle 入值區別大小寫，其他不區分大小寫 ↩︎ 參考鏈接 oracle 流程控制 oracle char 与 varchar2 的比较与使用 oracle 的資料型別及 number 型別詳解 "},"4.Oracle/3.建立資料庫/3-03.建立表格練習.html":{"url":"4.Oracle/3.建立資料庫/3-03.建立表格練習.html","title":"3-03.建立表格練習","keywords":"","body":"目錄 1. 題目 2. 解答 1. 題目 建立 CUSTOMER 並設定 BOOK 中的內容 建立 BOOK 並關聯 PUBLISHER_ID 至 PUBLISHER 建立 ORDER_MASTER 並關聯 CUSTOMER_ID 至 CUSTOMER 建立 ORDER_DETAIL 並關聯 ORDER_ID 至 ORDER_MASTER、並關聯 ISBN 至 BOOK 2. 解答 建立 CUSTOMER 並設定 BOOK 中的內容 CREATE TABLE CUSTOMER( CUSTOMER_ID VARCHAR2(40) PRIMARY KEY NOT NULL, CUSTOMER_NAME VARCHAR2(40) NOT NULL, PHONE VARCHAR2(40) NOT NULL, ADDRESS VARCHAR2(200) NOT NULL ); 建立 BOOK 並關聯 PUBLISHER_ID 至 PUBLISHER CREATE TABLE BOOK( ISBN CHAR(13) PRIMARY KEY NOT NULL, BOOK_NAME VARCHAR2(200) NOT NULL, PRICE NUMBER(8,2) CHECK (PRICE >= 0), AUTHOR VARCHAR2(200), PUBLICATION_DATE DATE, PUBLISHER_ID VARCHAR2(40), FOREIGN KEY (PUBLISHER_ID) REFERENCES PUBLISHER(PUBLISHER_ID) ); 建立 ORDER_MASTER 並關聯 CUSTOMER_ID 至 CUSTOMER CREATE TABLE ORDER_MASTER ( ORDER_ID NUMBER(10) PRIMARY KEY NOT NULL, CUSTOMER_ID VARCHAR2(40), ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMER(CUSTOMER_ID) ); 建立 ORDER_DETAIL 並關聯 ORDER_ID 至 ORDER_MASTER、並關聯 ISBN 至 BOOK TABLE 中含 REFERENCES 則 ORDER_DETAIL(父) 、BOOK(子)、ORDER_MASTER(子) ORDER_DETAIL(父) 的 ORDER_ID、ISBN 資料要先建立，才可順利創建 BOOK(子) 與 ORDER_MASTER(子) CREATE TABLE ORDER_DETAIL ( ORDER_ID NUMBER(10) PRIMARY KEY NOT NULL, ISBN CHAR(13) NOT NULL, QUANTITY NUMBER(8) NOT NULL, FOREIGN KEY (ORDER_ID) REFERENCES ORDER_MASTER(ORDER_ID), FOREIGN KEY (ISBN) REFERENCES BOOK(ISBN) ); 參考鏈接 Oracle| Oracle 大小写敏感问题 "},"4.Oracle/3.建立資料庫/3-04.SQL種類.html":{"url":"4.Oracle/3.建立資料庫/3-04.SQL種類.html","title":"3-04.SQL 種類","keywords":"","body":"目錄 1. SQL 種類 1. SQL 種類 資料定義語言(Data Definition Language，DDL) 建表格 資料處裡語言(Data Manipulation Language，DML) 新增改查 資料控制語言(Data Control Language，DCL) 授權 以後所見的文件都會使用 DDL、DML、DCL 來說明相應 SQL 所代表的種類，很重要所以需要記住，這樣後續查詢文件才能看懂 "},"4.Oracle/3.建立資料庫/3-10.Browser設定.html":{"url":"4.Oracle/3.建立資料庫/3-10.Browser設定.html","title":"3-10.Browser 設定","keywords":"","body":"目錄 1. 開啟 Browser 1. 開啟 Browser view > Data Modeler > Browser Browser 頁籤 > Relational Models 右鍵 > New Relational Model Relational_1(Untitled_1) > 將 table 表格點著並拖拉至圖表中(多拉幾次)[1] Relational Model 中虛線箭頭指向的是爸爸，一定要先建立資料。實線是兒子後來在建立↩︎ "},"4.Oracle/3.建立資料庫/3-11.常用指令.html":{"url":"4.Oracle/3.建立資料庫/3-11.常用指令.html","title":"3-11.常用指令","keywords":"","body":"目錄 1. 建立表格並設定欄位 2. 顯示指定表格定義 3. 列出當前用戶所有表格 4. 建立表格 5.修改表格名稱 6. 新增表格欄位 7. 修改/刪除預設值 8. 修改/刪除預設值 9. 修改欄位類型 10. 刪除欄位 11. 建立 FOREIGN KEY(外鍵) 12. 移除 FOREIGN KEY(外鍵) 13. 欄位改為不可/可為空值 14. 刪除表格 常用指令 1. 建立表格並設定欄位 -- CREATE TABLE - PK (不想自訂PK constraint名稱，可以直接在欄位後面加PK設定) CREATE TABLE PUBLISHER ( PUBLISHER_ID VARCHAR2(40) PRIMARY KEY NOT NULL, PUBLISHER_NAME VARCHAR2(40) NOT NULL, CONTACT VARCHAR2(40), PHONE VARCHAR2(40) NOT NULL, CREATE_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); -- 要建立複合PK(以逗號區隔)或自訂PK constraint名稱必須列在後面 CREATE TABLE PUBLISHER ( PUBLISHER_ID VARCHAR2(40) NOT NULL, PUBLISHER_NAME VARCHAR2(40) NOT NULL, CONTACT VARCHAR2(40), PHONE VARCHAR2(40) NOT NULL, CREATE_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP, CONSTRAINT PK_PUBLISHER PRIMARY KEY (PUBLISHER_ID) ); 2. 顯示指定表格定義 -- 顯示指定表格定義 DESCRIBE PUBLISHER; 3. 列出當前用戶所有表格 -- 列出當前用戶所有表格 SELECT table_name FROM user_tables; 4. 建立表格 -- CREATE TABLE - FK (要自訂FK constraint名稱必須列在後面) CREATE TABLE BOOK ( ISBN CHAR(13) PRIMARY KEY NOT NULL, BOOK_NAME VARCHAR2(200) NOT NULL, PRICE NUMBER(8,2) CHECK (PRICE >= 0), AUTHOR VARCHAR2(200), PUBLICATION_DATE DATE, PUBLISHER_ID VARCHAR2(40), CONSTRAINT FK_BOOK_PUBLISHER FOREIGN KEY (PUBLISHER_ID) REFERENCES PUBLISHER(PUBLISHER_ID) ); -- 不想自訂FK constraint名稱，可以直接在欄位後面加REFERENCES設定 CREATE TABLE BOOK ( ISBN CHAR(13) PRIMARY KEY NOT NULL, BOOK_NAME VARCHAR2(200) NOT NULL, PRICE NUMBER(8,2) CHECK (PRICE >= 0), AUTHOR VARCHAR2(200), PUBLICATION_DATE DATE, PUBLISHER_ID VARCHAR2(40) REFERENCES PUBLISHER(PUBLISHER_ID) ); 5. 修改表格名稱 -- 表格更名 ALTER TABLE BOOK RENAME TO BOOKS; 6. 新增表格欄位 -- 新增欄位 ALTER TABLE BOOK ADD LANGUAGE VARCHAR2(40); 7. 修改表格欄位名稱 -- 欄位更名 ALTER TABLE BOOK RENAME COLUMN LANGUAGE TO LANGUAGES; 8. 修改/刪除預設值 資料若要設定為空，則要設置成 NULL 不可設定為 '' -- 修改/刪除欄位預設值 ALTER TABLE BOOK MODIFY LANGUAGES DEFAULT 'Chinese'; ALTER TABLE BOOK MODIFY LANGUAGES DEFAULT NULL; 9. 修改欄位類型 -- 修改欄位類型 ALTER TABLE BOOK MODIFY LANGUAGES VARCHAR2(20); 10. 刪除欄位 -- 刪除欄位 ALTER TABLE BOOK DROP COLUMN LANGUAGES; 11. 建立 FOREIGN KEY(外鍵) -- 建立FK ALTER TABLE BOOK ADD CONSTRAINT FK_BOOK_PUBLISHER FOREIGN KEY (PUBLISHER_ID) REFERENCES PUBLISHER(PUBLISHER_ID); 12. 移除 FOREIGN KEY(外鍵) -- 移除FK ALTER TABLE BOOK DROP CONSTRAINT FK_BOOK_PUBLISHER; 13. 欄位改為不可/可為空值 -- 欄位改為不可/可為空值 ALTER TABLE BOOK MODIFY AUTHOR NOT NULL; ALTER TABLE BOOK MODIFY AUTHOR NULL; 14. 刪除表格 若刪除表有被參照，則不可刪除 -- DROP TABLE DROP TABLE BOOK; DROP TABLE PUBLISHER; "},"4.Oracle/3.建立資料庫/3-12.新增修改刪除練習.html":{"url":"4.Oracle/3.建立資料庫/3-12.新增修改刪除練習.html","title":"3-12.新增修改刪除練習","keywords":"","body":"目錄 1. 新增修改刪除練習 1. 新增修改刪除練習 對 ORDER_DETAIL 做欄位的增刪改，與表格刪除 -- 新增欄位 ALTER TABLE ORDER_DETAIL ADD LANGUAGE VARCHAR2(40); -- 修改欄位名稱 ALTER TABLE ORDER_DETAIL RENAME COLUMN LANGUAGE TO LANGUAGES; -- 修改欄位類型 ALTER TABLE ORDER_DETAIL MODIFY LANGUAGES VARCHAR2(20); -- 刪除欄位 ALTER TABLE ORDER_DETAIL DROP COLUMN LANGUAGES; -- 刪除表格 DROP TABLE ORDER_DETAIL; "},"4.Oracle/4.資料交易處理/4-01.新增資料.html":{"url":"4.Oracle/4.資料交易處理/4-01.新增資料.html","title":"4-01.新增資料","keywords":"","body":"目錄 1. 插入資料(無日期) 2. 插入資料(含日期格式) 3. 設定統一日期格式 4. 自動編號 5. COMMIT 與 ROLLBACK 6. 自動序號格式 7. 資料鎖定 1. 插入資料(無日期) 插入資料 INSERT INTO [TableName]([TableCol],[TableCol],...) 值若是 'O''Reilly' 則建立後變成 O'Reilly -- INSERT INTO PUBLISHER INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P001', 'O''Reilly', 'Ocean' , '02-23456789'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P002', 'John Wiley, Sons Inc', 'Don' , '03-36962869'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P003', 'Manning Publications', 'Mary' , '04-43456789'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P004', 'Apress', 'Allen' , '05-59876543'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P005', 'McGraw-Hill', 'Mike' , '06-69876543'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P006', 'Pearson', 'Paul' , '09-98767867'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P00X', 'Publisher X', 'X-Man' , '07-75698765'); INSERT INTO PUBLISHER (PUBLISHER_ID, PUBLISHER_NAME, CONTACT, PHONE) VALUES ('P00Y', 'Publisher Y', 'Yale' , '08-83698765'); PUBLISHER_ID PUBLISHER_NAME CONTACT PHONE P001 O'Reilly Ocean 02-23456789 P002 John Wiley, Sons Inc Sons Inc Don P003 Manning Publications Mary 04-43456789 P004 Apress Allen 05-59876543 P005 McGraw-Hill Mike 06-69876543 P006 Pearson Paul 09-98767867 P00X Publisher X X-Man 07-75698765 P00Y Publisher Y Yale 08-83698765 2. 插入資料(含日期格式) 填日期時需用 to_date() 做日期轉換，例: to_date('2005-02-19 21:02:44', 'yyyy-mm-dd hh24:mi:ss')[1] yyyy-mm-dd 表示年-月-日轉換 hh24:mi:ss 表示時:分:秒轉換 -- INSERT INTO BOOK -- to_date(): 將指定格式日期/時間字串轉成DATE格式 -- DATE：to_date('2005-02-19', 'yyyy-mm-dd') -- TIMESTAMP：to_date('2005-02-19 21:02:44', 'yyyy-mm-dd hh24:mi:ss') INSERT INTO BOOK (ISBN, BOOK_NAME, PRICE, AUTHOR, PUBLICATION_DATE, PUBLISHER_ID) VALUES('9780596009205', 'Head First Java', 1186 , 'Kathy Sierra and Bert Bates', to_date('2005-02-19', 'yyyy-mm-dd'), 'P001'); 3. 設定統一日期格式 設定後連線期間(SESSION)就不用單獨套用格式，用法: ALTER SESSION SET (以下格式則一套用) -- 更改NLS_DATE_FORMATNLS_DATE_FORMAT, NLS_TIMESTAMP_FORMAT格式有2個好處 -- 1. 在資料庫連線期間新增時無需使用to_date()轉換 -- 2. 查詢結果顯示的日期/時間格式也同時確定 ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm-dd'; ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'yyyy-mm-dd hh24:mi:ss'; 4. 自動編號 常用在 PK[2] 上，多用在訂單編號 建立序號格式 CREATE SEQUENCE SEQ_EMPLOYEE_ID; Name Value CREATED 2020-04-29 LAST_DDL_TIME 2020-04-29 SEQUENCE_OWNER BOOKSHOP SEQUENCE_NAME SEQ_EMPLOYEE_ID MIN_VALUE 1 MAX_VALUE 9999999999999999999999999999 INCREMENT_BY 1 CYCLE_FLAG N ORDER_FLAG N CACHE_SIZE 20 LAST_NUMBER 21 套用序號格式並新增資料 -- 即使新增失敗，sequence仍會自動跳號，避免多人新增時無法順利取號的問題 -- 新增失敗的話照樣會新增失敗，直到新的執行可以執行成功就會將資料加入 INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME) VALUES (SEQ_EMPLOYEE_ID.nextval, 'John'); 查詢目前編到的號碼 -- 查詢目前自動編號(sequence)的值 SELECT SEQ_EMPLOYEE_ID.currval FROM dual; 6. COMMIT 與 ROLLBACK COMMIT[3] 在 Oracle 提交此次修改信息，沒下 commit 則指令後的效果沒有真正被保存(相當於 excel 編輯後沒有 ctrl + s 檔案)commitdata，這時就可以使用 ROLLBACK 回退資料 使用方法 COMMIT; ROLLBACK[5] 撤回未提交(保存)的資料 使用方法 ROLLBACK; 7. 自動序號格式 介面化建立 指令自動建立 8. 資料鎖定 資料表在有人編輯時此筆資料會被鎖定[6]，此時其他人員不可修改(但此表的其他資料仍可被修改) to_date('2005-02-19', 'yyyy-mm-dd')中的 2005-02-19 指的就是值 ↩︎ Primary Key(主鍵) ↩︎ 使用 COMMIT 语句在 Oracle 中发出提交 ↩︎ 資料 commit 後才能準確地保存此次修改，並讓其他共用資料庫的人一同使用 ↩︎ Oracle PL/SQL 中, Savepoint 與 Rollback 的用法 ↩︎ 即應用到 ACID 中的隔離性(I，Isolation)規則 ↩︎ "},"4.Oracle/4.資料交易處理/4-02.新增資料練習.html":{"url":"4.Oracle/4.資料交易處理/4-02.新增資料練習.html","title":"4-02.新增資料練習","keywords":"","body":"目錄 1. 題目 2. 解答 1. 題目 新增 1 筆資料至 CUSTOMER 表格內 新增 1 筆資料至 ORDER_MASTER 表格內 ORDER_ID 採用自動編號 新增 1 筆資料至 ORDER_DETAIL 表格內 2. 解答 -- 定義時間格式 ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm-dd'; -- 新增1筆資料至CUSTOMER表格內 INSERT INTO customer (CUSTOMER_ID,CUSTOMER_NAME,PHONE,ADDRESS) VALUES ('C02', 'C002', '0989989989' , 'add2'); -- 建立序號格式 CREATE SEQUENCE SEQ_ORDER_DETAIL_ID; -- 新增1筆資料至ORDER_MASTER表格內 INSERT INTO order_master (ORDER_ID,CUSTOMER_ID) VALUES (SEQ_ORDER_DETAIL_ID.nextval, 'C02'); -- 新增1筆資料至ORDER_DETAIL表格內 INSERT INTO order_detail (ORDER_ID,ISBN,QUANTITY) VALUES (5,'9780596009205', 500); "},"4.Oracle/4.資料交易處理/4-03.修改資料.html":{"url":"4.Oracle/4.資料交易處理/4-03.修改資料.html","title":"4-03.修改資料","keywords":"","body":"目錄 1. 修改表單所有資料 2. 修改表單所有資料 1. 修改表單所有資料 一般不會這麼做，會造成資料完全相同 -- UPDATE UPDATE PUBLISHER SET CONTACT = 'John', PHONE = '07-1234567765' 2. 修改表單所有資料 更新 PUBLISHER_ID = 'P00X' 或 PUBLISHER_ID = 'P00Y' UPDATE [TableName] SET [KeyName] = '[KeyValue]' 修改方式 WHERE [KeyName] = '[KeyValue]' 判斷條件[1] -- UPDATE UPDATE PUBLISHER SET CONTACT = 'John', PHONE = '07-1234567765' WHERE PUBLISHER_ID = 'P00X' OR PUBLISHER_ID = 'P00Y'; WHERE: 功能似 while 逐筆做比較 ↩︎ "},"4.Oracle/4.資料交易處理/4-04.修改資料練習.html":{"url":"4.Oracle/4.資料交易處理/4-04.修改資料練習.html","title":"4-04.修改資料練習","keywords":"","body":"目錄 1. 題目 2. 解答 1. 題目 修改 CUSTOMER 表格內的 1 筆資料 除了 CUSTOMER_ID 外,其他欄位值都要修改 例如將客戶 ID 為 C001 的客戶名改為 Ken,電話改為 03- 3456789,地址改為 Taoyuan 修改 ORDER_DETAIL 表格內的 1 筆資料 將指定 ORDER_ID 與 ISBN 的 QUANTITY 值加以修改 2. 解答 -- 修改 CUSTOMER 表格內的 1 筆資料 UPDATE customer SET address = 'ads1',phone = '0998898888',customer_name = 'C003' WHERE customer_id = 'C01'; -- 改 ORDER_DETAIL -- 將指定 ORDER_ID 與 ISBN 的 QUANTITY 值加以修改 -- ORDER_ID (ORDER_DETAIL,ORDER_MASTER) : ORDER_ID = '5' -- ISBN (BOOK, ORDER_DETAIL) : ISBN = '9780596009205' UPDATE ORDER_DETAIL SET QUANTITY = '1000' WHERE ORDER_ID = '5' and ISBN = '9780596009205'; "},"4.Oracle/4.資料交易處理/4-05.刪除資料.html":{"url":"4.Oracle/4.資料交易處理/4-05.刪除資料.html","title":"4-05.刪除資料","keywords":"","body":"目錄 1. 刪除表單所有資料 2. 刪除特定條件資料 1. 刪除表單所有資料 一般很少直接刪除資料，具體都是改變顯示狀態而已 DELETE FROM PUBLISHER; 2. 刪除特定條件資料 具體用法 DELETE FROM [TableName] WHERE [DeleteCondition] -- DELETE -- 被外來鍵參照到的資料無法刪除 DELETE FROM PUBLISHER WHERE PUBLISHER_ID = 'P00X' OR PUBLISHER_ID = 'P00Y'; "},"4.Oracle/4.資料交易處理/4-06.指定回退資料的時間點.html":{"url":"4.Oracle/4.資料交易處理/4-06.指定回退資料的時間點.html","title":"4-06.指定回退資料的時間點","keywords":"","body":"目錄 1. 交易(transaction) 2. 查詢是否設定自動 COMMIT 1. 交易(transaction) 交易 (transaction) 可將多個異動視為一體,通常會搭配 ROLLBACK 還原執行過的異動 COMMIT 確定交易 (無法還原執行過的異動) 使用 SAVEPOINT 可以設定 ROLLBACK 欲回復的時間點 2. 查詢是否設定自動 COMMIT -- 要使用 ROLLBACK ,確定 Preferences > Database > Advanced > Autocommit 沒有勾選，或執行下列指令檢查 AUTOCOMMIT 狀態 SHOW AUTOCOMMIT ; 3. 設定儲存點 設定執行時間點 : SAVEPOINT [pointName][1] -- SAVEPOINT SAVEPOINT point01; DELETE FROM PUBLISHER WHERE PUBLISHER_ID = 'P00X'; SAVEPOINT point02; DELETE FROM PUBLISHER WHERE PUBLISHER_ID = 'P00Y'; 回退指定時間點 : ROLLBACK TO SAVEPOINT [pointName] 退回 [pointName] 沒修改之前的資料 -- 回復到指定SAVEPOINT ROLLBACK TO SAVEPOINT point01; SAVEPOINT: 日後 ADDC 課程可能會學到 ↩︎ "},"4.Oracle/4.資料交易處理/4-07.回退資料練習.html":{"url":"4.Oracle/4.資料交易處理/4-07.回退資料練習.html","title":"4-07.回退資料練習","keywords":"","body":"目錄 1. 題目 2. 解答 1. 題目 新增一筆資料至 CUSTOMER 表格,修改客戶名稱後再還原 做以下動作 建立 SAVEPOINT 新增一筆資料至 CUSTOMER 表格 再建立 SAVEPOINT 修改客戶名稱 還原至第 2 個 SAVEPOINT 2. 解答 -- 新增 SAVEPOINT point01; INSERT INTO customer (customer_id,customer_name,phone,address) VALUES ('C03','C003', '0955575575', 'ads3'); -- 修改 SAVEPOINT point02; UPDATE customer SET customer_name = 'C001' WHERE customer_id = 'C01'; -- 還原 ROLLBACK TO SAVEPOINT point02; "},"4.Oracle/4.資料交易處理/4-08.匯入匯出資料.html":{"url":"4.Oracle/4.資料交易處理/4-08.匯入匯出資料.html","title":"4-08.匯入匯出資料","keywords":"","body":"目錄 1. 匯出資料 1.匯出資料 SQL Developer > Tools > Database Export > Connection 選好資料庫 > 勾選 Dependents (勾選後才會依照關聯建立表格) > File 欄位指定匯出檔案路徑 可視情況勾選 Drops 選項,會生成移除 Table 指令 (DROPTABLE) 自動產生的 Drops 很可能會有問題，順序不對(不建議)。執行失敗請手動刪除使用者並重新建立(也可手動撰寫 drop 檔案，但容易出錯) 刪除帳號後記得勾選 CasCade，才會將舊資料完全清除 "},"4.Oracle/5.資料查詢/5-01.資料查詢的各種方法.html":{"url":"4.Oracle/5.資料查詢/5-01.資料查詢的各種方法.html","title":"5-01.資料查詢的各種方法","keywords":"","body":"SELECT 欄位別名 欄位 新名稱 或 欄位 AS 新名稱 -- SELECT SELECT ISBN, BOOK_NAME NAME, PRICE * 0.9 AS SALE_PRICE FROM BOOK; 表格內指定值，並設定指定名稱(還能計算) -- SELECT SELECT ISBN, BOOK_NAME NAME, PRICE * 0.9 AS SALE_PRICE, AUTHOR, PUBLICATION_DATE FROM BOOK; 表格內所有資料 SELECT * FROM BOOK; 查詢後結果依照 BOOK_NAME 進行降序 欄位 DESC (大 → 小，降冪) 或 欄位 ASC (小 → 大，升冪) -- ORDER BY兩個以上欄位，可分別指定升冪或降冪 SELECT * FROM BOOK ORDER BY PRICE ASC, BOOK_NAME DESC; 依照空值排序 欄位 NULLS FIRST (排在前) 或 欄位 NULLS LAST (排在後) -- 先將任一price改為null，NULLS FIRST會將null值排在前 SELECT * FROM BOOK ORDER BY PRICE NULLS FIRST; SELECT 練習 將 CUSTOMER 表格的 CUSTOMER_NAME (別名為 NAME), PHONE, ADDRESS 欄位資料列出 select customer_name NAME,phone,address from customer; 將 CUSTOMER 表格的所有欄位資料列出 select * from customer; WHERE 判斷文字 -- 查詢出版社名稱為Pearson的資料 SELECT * FROM PUBLISHER WHERE PUBLISHER_NAME = 'Pearson'; 判斷範圍 -- 查詢書價在1000元以內的書籍 SELECT * FROM BOOK WHERE PRICE 判斷空值 -- 將沒有出版社資訊的書籍列出 (先將一本書的PUBLISHER_ID值清空) SELECT * FROM BOOK WHERE PUBLISHER_ID IS NULL; 搜尋時指定開頭並模糊查詢 LIKE '_搜尋值%' -- 查詢書名開頭為任一字元再加上「ava」的資料 SELECT * FROM BOOK WHERE BOOK_NAME LIKE '_ava%'; 搜尋所有 -- 查詢書名開頭為任一字元再加上「ava」的資料 SELECT * FROM BOOK WHERE BOOK_NAME LIKE '%%'; 搜尋時資料轉大寫 upper(\"欄位\") 欄位轉大寫 upper('%搜尋值%') 搜尋的值轉大寫 -- 查詢書名含有「Java」的資料 (不區別大小寫) SELECT * FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%'; 搜尋時不分大小寫 -- 查詢書名含有「Java」的資料 (不區別大小寫) SELECT * FROM BOOK WHERE upper(BOOK_NAME) LIKE upper('%JAVA%'); WHERE 練習 查詢客戶 ID 為 C001 的資料 select * from customer where customer_id = 'C001'; 查詢出版日期為 2016/01/01 以後的書籍(方法 1) -- 設訂當下統一日期格式 ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm-dd'; -- 搜尋 select * from book where PUBLICATION_DATE >'2016-01-01'; 查詢出版日期為 2016/01/01 以後的書籍(方法 2) select * from book where to_char(PUBLICATION_DATE,'yyyy-mm-dd') > '2016-01-01'; 查詢出版日期為 2016/01/01 以後的書籍(方法 3)常用 select * from book where PUBLICATION_DATE > to_date('2016-01-01','yyyy-mm-dd'); 查詢居住在 Taipei 的客戶 select * from customer where upper(address) like upper('%Taipei%'); AND|OR|NOT|BETWEEN AND -- AND: 查詢書名有「Java」且書價在1000元以內的資料 (不區別大小寫)，而且依照書價升冪排序 SELECT * FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%' AND PRICE OR -- OR: 查詢書名有「Java」或是「Oracle」的資料 SELECT * FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%' OR upper(BOOK_NAME) LIKE '%ORACLE%'; NOT -- NOT: 查詢書價沒有大於1000元的書 SELECT * FROM BOOK WHERE NOT PRICE > 1000; BETWEEN -- BETWEEN: 查詢書價介於550(含)~935(含)元的書籍 SELECT * FROM BOOK WHERE PRICE BETWEEN 550 AND 935; AND|OR|NOT|BETWEEN 練習 查詢出版日期介於 2016/01/01~2016/12/31 之間的書籍,而且依照書價降冪排序 select * from book where PUBLICATION_DATE between to_date('2016-01-01','yyyy-mm-dd') and to_date('2016-12-31','yyyy-mm-dd') Order by price desc; 查詢居住在 Taipei 或 Taoyuan 的客戶 select * from customer where upper(address) like upper('%Taipei%') or upper(address) like upper('%Taoyuan%'); IN|ANY|ALL IN 搜尋的資料轉大寫 不可搭配運算符(>、=、 ...)使用 -- IN: 查詢出版社聯絡人為'PAUL'或'MARY'或'OCEAN'的資料 (不區別大小寫) SELECT * FROM PUBLISHER WHERE upper(CONTACT) IN ('PAUL', 'MARY', 'OCEAN'); IN 不區分大小寫: 搜尋的資料轉大寫且多重搜尋的值也轉 -- IN: 查詢出版社聯絡人為'PAUL'或'MARY'或'OCEAN'的資料 (不區別大小寫) SELECT * FROM PUBLISHER WHERE upper(CONTACT) IN (upper('paul'), upper('mary'), upper('ocean')); NOT NOT 欄位 IN (搜尋值,...) -- 查詢出版社聯絡人不為'PAUL'或'MARY'或'OCEAN'的資料 (不區別大小寫) SELECT * FROM PUBLISHER WHERE NOT upper(CONTACT) IN ('PAUL', 'MARY', 'OCEAN'); NOT 欄位 NOT IN (搜尋值,...) -- 查詢出版社聯絡人不為'PAUL'或'MARY'或'OCEAN'的資料 (不區別大小寫) SELECT * FROM PUBLISHER WHERE upper(CONTACT) NOT IN ('PAUL', 'MARY', 'OCEAN'); ANY ANY 可視為 A or B or C ... 可搭配運算符(>、=、 ...)使用 ANY 比 IN 更常用 ANY 比 IN 來得彈性，搭配不同運算符號會有不同功能 ANY 配 = -- ANY搭配「=」相當於IN SELECT * FROM PUBLISHER WHERE upper(CONTACT) = ANY ('PAUL', 'MARY', 'OCEAN'); ANY 配 NOT -- 加上NOT變成相反的條件 SELECT * FROM PUBLISHER WHERE NOT upper(CONTACT) = ANY ('PAUL', 'MARY', 'OCEAN'); ANY 配 > -- 查詢書價大於500或1000的資料 SELECT * FROM BOOK WHERE PRICE > ANY (500, 1000); ALL ALL 可視為 A and B and C ... -- 查詢書價既大於500，也大於1000的資料 SELECT * FROM BOOK WHERE PRICE > ALL (500, 1000); SUM|AVG|COUNT|MAX|MIN 聚集函式 SUM 計算加總 如果 SUM(ISBN) 且 ISBN 中的文字為純數字，Oracle 也會自動轉成數字並加總 -- Aggregate Functions -- 加總書名有Java的書價 SELECT SUM(PRICE) AS BOOKS_SUM FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%'; AVG 計算平均 -- 計算平均書價 SELECT AVG(PRICE) AS BOOKS_AVERAGE FROM BOOK; COUNT 資料筆數 -- 計算書價在1000元以上的總數量 SELECT COUNT(ISBN) FROM BOOK WHERE PRICE >= 1000; COUNT 若設定 SELECT COUNT(1) 則顯示的還是資料筆數 -- 計算書價在1000元以上的總數量 SELECT COUNT(1) FROM BOOK WHERE PRICE >= 1000; MAX -- 取得最高書與最低書價 SELECT MAX(PRICE) AS BOOK_MAX_PRICE, MIN(PRICE) AS BOOK_MIN_PRICE FROM BOOK; 聚集函式也可以一起用 -- 取得最高書與最低書價 SELECT SUM(PRICE), MAX(PRICE) AS BOOK_MAX_PRICE, MIN(PRICE) AS BOOK_MIN_PRICE FROM BOOK; 聚集函式練習 統計居住在台北的客戶總數量 -- 統計居住在台北的客戶總數量 select count(customer_id) 客戶總數量 from customer where upper(address) like upper('%Taipei%'); 統計訂單 1、2 的訂購總量 -- 統計訂單1、2的訂購總量 select count(quantity) 訂單筆數, sum(quantity) 訂購總量 from order_detail where order_id in (1,2); 統計 2016 年的平均書價 -- 統計2016年的平均書價 select avg(price) 平均書價 from book where PUBLICATION_DATE BETWEEN to_date('2016-01-01','yyyy-mm-dd') and to_date('2016-12-31','yyyy-mm-dd'); "},"4.Oracle/6.進階查詢/6-01.進階查詢.html":{"url":"4.Oracle/6.進階查詢/6-01.進階查詢.html","title":"6-01.進階查詢","keywords":"","body":"JOIN 概論 INNER JOIN 顯示雙方表格都有的 FROM 左表格 JOIN 右表格 ON 共同欄位 BOOK B 表示定義 BOOK 表格的別名為 B，這樣以就不用用別名 兩個表格的資料都要有 -- INNER JOIN -- 2個表格都有相同的PUBLISHER_ID才會呈現該筆資料 SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; LEFT JOIN 只顯示左表有的值，右表無此值會顯示 NULL FROM 左表格 LEFT JOIN 右表格 ON 共同欄位 左表格資料當重點 -- LEFT JOIN -- 只顯示左邊表格有的值，右邊表格無此值者會顯示NULL SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME FROM BOOK B LEFT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; RIGHT JOIN 只顯示右表有的值，左表無此值會顯示 NULL 右表格當重點 -- RIGHT JOIN -- 只顯示右邊表格有的值，左邊表格無此值者會顯示NULL SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME FROM BOOK B RIGHT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; FULL JOIN 顯示雙方表格都有的值，無此值會顯示 NULL 兩個表格的資料都有 -- FULL OUTER JOIN -- 顯示雙方表格都有的值，無值者會顯示NULL SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME FROM BOOK B FULL JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; JOIN 自己 -- SELF JOIN -- MANAGER_ID與EMPLOYEE_ID有相同意義 -- 步驟1: 創建表格並添加表格資料 CREATE TABLE EMPLOYEE ( EMPLOYEE_ID INT PRIMARY KEY NOT NULL, NAME VARCHAR(40), MANAGER_ID INT, FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEE (EMPLOYEE_ID) ); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (1, 'Mary', NULL); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (2, 'John', 1); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (3, 'Ben', 1); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (4, 'Joe', 2); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (5, 'James', 2); INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID) VALUES (6, 'Betty', 3); -- 步驟2: 員工資料對應自己，這樣能查到員工，與員工對應的老闆(因為老闆也是公司的員工) SELECT E.EMPLOYEE_ID, E.NAME, E.MANAGER_ID, M.NAME AS MANAGER_NAME FROM EMPLOYEE E LEFT JOIN EMPLOYEE M ON E.MANAGER_ID = M.EMPLOYEE_ID ORDER BY EMPLOYEE_ID; JOIN 練習 INNER JOIN 下列表格 ORDER_MASTER, CUSTOMER, ORDER_DETAIL, BOOK 顯示 ORDER_ID, CUSTOMER_NAME, ORDER_DATE, BOOK_NAME, PRICE, QUANTITY 欄位 依照 ORDER_ID 排序 -- INNER JOIN下列表格 -- ORDER_MASTER, CUSTOMER, ORDER_DETAIL, BOOK -- 顯示 ORDER_ID, CUSTOMER_NAME, ORDER_DATE, -- BOOK_NAME, PRICE, QUANTITY 欄位 -- 依照ORDER_ID排序 -- 因為 ORDER_ID 在多張表都有出現，所以 ORACLE 規定需要 SELECT od.ORDER_ID, CUSTOMER_NAME, ORDER_DATE, BOOK_NAME, PRICE, QUANTITY FROM ORDER_MASTER om inner join ORDER_DETAIL od ON om.ORDER_ID = od.ORDER_ID inner join CUSTOMER cu ON om.customer_id = cu.customer_id inner join BOOK b ON b.isbn = od.isbn Order by PRICE; ORA-00918: column ambiguously defined select 查询的字段在 from 的两张表中都存在，导致数据库无法区别需要查询的字段来自于哪张表 GROUP BY 函式 沒有放在聚集函式中的欄位，一定要放在 GROUP BY 否則會報錯 SELECT 出版社名稱, COUNT(書本) AS 刊登的書本數量 FROM 書本表 GROUP BY 出版社名稱 ORDER BY 出版社名稱 DESC; 表格要顯示出版社名稱與該出版社有的書本並且排序方式需要使用出版社名稱做排序 出版社名稱 刊登的書本數量 手民 4 白卷 2 教育 8 辛裡 2 -- GROUP BY -- 列出每個出版社出版了幾本書 SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT FROM BOOK GROUP BY PUBLISHER_ID ORDER BY BOOK_COUNT DESC; GROUP BY 與 HAVING WHERE 針對未分組的原始資料做查詢 HAVING 不能使用別名，因為在 ORACLE 當中執行到 HAVING 時 BOOK_COUNT 名稱還未生成，所以不能使用 -- GROUP BY -- 列出每個出版社出版了幾本書 SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT FROM BOOK -- WHERE 原始資料(WHERE 針對未分組的原始資料做查詢) WHERE PRICE = 2 -- 需要使用 BOOK_COUNT 做排序 ORDER BY BOOK_COUNT DESC; 別名尚未產生的第二個範例 -- 列出平均書價超過1000元的出版社 -- HAVING不能使用AVERAGE_PRICE別名是因為GROUP BY時別名尚未產生 SELECT B.PUBLISHER_ID, PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME HAVING AVG(PRICE) > 1000; 每多加一個欄位，就等於多了個次分組 -- SELECT列出來的欄位，除了聚集函數的欄位外，其餘都要列在GROUP BY條件中，否則會不符合閱讀邏輯 SELECT PUBLISHER_ID, AUTHOR, COUNT(BOOK_NAME) AS BOOK_COUNT FROM BOOK GROUP BY PUBLISHER_ID, AUTHOR ORDER BY BOOK_COUNT DESC; GROUP BY 中有值但 SELECT 沒有值，這樣不會出錯但是不是個好方法，容易造成資訊混淆 最好不要偷偷在 GROUP BY 中分組，但不給人看，否則容易在顯示的有相同資料時以為錯了 -- 列出每個出版社的平均書價，顯示欄位包含出版社名稱與平均書價 -- 若不將出版社ID列在GROUP BY，當出版社名稱相同時，會將不同出版社ID但相同出版社名稱的資料合併 SELECT PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME; 沒有用 SUM|AVG|COUNT|MAX|MIN 的欄位才一定要放在 GROUP BY 中分組 -- 列出每個出版社最貴/最便宜的書價 SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE), MIN(PRICE) FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME; 特別的是在 ORDER BY 中使用別名不會有錯 而且也能用 SUM|AVG|COUNT ... 排序 -- 列出每個出版社最貴的書價，並降冪排序 SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE) AS MAX_PRICE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME ORDER BY MAX_PRICE DESC; 為什麼要 JOIN (合併) 因為列出來的欄位數超過單一表格，所以要 join 因為要列出很多不同的表格欄位，所以要把表格都連在一起 要列出比較完整的資訊 想要的資料只用一個表無法滿足需求 為什麼要 GROUP BY 因為要分組統計 GROUP BY 與 JOIN 練習 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序 -- 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序 SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID, SUM(QUANTITY) AS SUM_QUANTITY FROM CUSTOMER C JOIN ORDER_MASTER OM ON C.CUSTOMER_ID = OM.CUSTOMER_ID JOIN ORDER_DETAIL OD ON OM.ORDER_ID = OD.ORDER_ID GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID ORDER BY SUM(QUANTITY); 列出每家出版社出版書籍的訂購總量在 3 以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序 -- 列出每家出版社出版書籍的訂購總量在3以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序 select p.PUBLISHER_ID 出版社編號,p.PUBLISHER_NAME 出版社名稱, sum(QUANTITY) 訂購總量 FROM publisher p join book b on b.publisher_id = p.publisher_id join order_detail od on od.isbn = b.isbn group by p.PUBLISHER_ID, p.PUBLISHER_NAME order by PUBLISHER_NAME; 統計 2016~2017 年間每月出版的書籍數量，並依照日期排序 -- 統計2016~2017年間每月出版的書籍數量，並依照日期排序 ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm'; SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT('ISBN') AS TOTAL FROM BOOK WHERE PUBLICATION_DATE BETWEEN '2016-01' AND '2017-12' GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm') ORDER BY to_char(PUBLICATION_DATE, 'yyyy-mm') ; SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT(1) AS TOTAL FROM BOOK WHERE to_char(PUBLICATION_DATE, 'yyyy-mm') BETWEEN '2016-01' AND '2017-12' GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm') ORDER BY PUB_MONTH; 子查詢 主要 SELECT 語句可以加上次要 SELECT 子句,也就是子查詢 (subquery) 子查詢需要放在小括弧內 提供主要 SELECT 語句的資料來源或是條件判斷的依據 在運算式內或是比較運算符號之後的子查詢,回傳的值只能 1 個 -- 將小於等於平均書價的書列出 SELECT * FROM BOOK WHERE PRICE DUAL 是 Oracle 專用字，用於直接執行子查詢的判斷 -- 書價1000元以上的書籍數量佔總書籍數量多少百分比 -- DUAL表格是一個虛擬表格，裡面只有一筆資料，用於只對查詢結果感興趣時使用，例如：SELECT SYSDATE FROM DUAL; SELECT (SELECT COUNT(ISBN) * 100 FROM BOOK WHERE PRICE >= 1000) / (SELECT COUNT(ISBN) FROM BOOK) AS PERCENT_PRICE_GT_1000 FROM DUAL; 子查詢 練習 計算各個客戶訂購總量佔所有訂單總訂購量的百分比,列出客戶名與所佔總訂購量的百分比 select c.customer_id, c.customer_name, sum(od.quantity)/(select sum(od.quantity) FROM order_detail od) * 100 as PERCENT_SALES from customer c join order_master om on om.customer_id = c.customer_id join order_detail od on od.order_id = om.order_id GROUP BY c.customer_id, c.customer_name; 列出大於訂單平均訂購量的訂單編號與訂購量 -- HAVING 用來做詳細判斷，像是這題需要跟子查詢的結果作比較，就要使用 HAVING -- 簡單的判斷使用 WHERE 就好， WHERE 跟 HAVING 則一 SELECT od.order_id, sum(od.quantity) FROM order_detail od GROUP BY od.order_id HAVING sum(od.quantity) > ((SELECT sum(quantity) FROM order_detail)/(SELECT count(order_id) FROM order_master)) order by od.order_id; 列出大於訂單平均訂購量的訂單編號與訂購量(更簡單的寫法) Oracle 支持子查詢中使用 order by SELECT od.order_id, sum(od.quantity) FROM order_detail od GROUP BY od.order_id HAVING sum(od.quantity) > (SELECT AVG(sum(quantity)) FROM order_detail GROUP BY order_id) order by od.order_id; ROWNUM 函式 ROWNUM 是 Oracle 特有功能,屬於 pseudo column (虛擬欄位),用於儲存查詢結果的列號 ROWNUM 從 1 開始,所以「ROWNUM = 2」或「ROWNUM > 1」都為 false,會查無資料,除非用子查詢 也可將 ROWNUM 欄位一併顯示 SELECT column_name(s) FROM table_name WHERE ROWNUM 可用於取得各分頁資料,例如取得第一頁 (1 ~ 5)、第二頁 (6 ~ 10) 搭配子查詢,主查詢要使用子查詢 ROWNUM 欄位,需給予別名,避免分不清是主查詢還是子查詢的 ROWNUM 可取得排序後前幾筆資料 搭配子查詢與 ORDER BY ROWNUM 可以當成序號產生機 ROWNUM 範例 ROWNUM 的簡易使用 -- 列出前5筆 SELECT * FROM BOOK WHERE ROWNUM ROWNUM 容易出現的誤區 -- ROWNUM從1開始，「ROWNUM = 2」或「ROWNUM > 1」都為false，會查無資料 -- 從第一個欄位的第一個字元開始抓，所以不可以設定條件為 \" = \" 或 \" > \" -- 值沒到，ROWNUM 號碼就不會出現 SELECT * FROM BOOK WHERE ROWNUM = 2; SELECT * FROM BOOK WHERE ROWNUM > 1; 顯示 ROWNUM 並設定範圍 -- 將ROWNUM欄位一併顯示 SELECT ROWNUM, ISBN, BOOK_NAME, PRICE FROM BOOK WHERE ROWNUM 分頁器★ 常用 會使用到 瀏覽器有 timeout 時間，資料讀取過久會取消連線 -- 主查詢要使用子查詢ROWNUM欄位，需給予別名，避免分不清是主查詢還是子查詢的ROWNUM SELECT * FROM (SELECT ROWNUM AS ROW_NO, ISBN, BOOK_NAME, PRICE FROM BOOK) WHERE ROW_NO BETWEEN 5 AND 10; 推薦商品★會用到 -- 將出版日期最新的3本書列出 SELECT BOOK_NAME, PUBLICATION_DATE FROM (SELECT BOOK_NAME, PUBLICATION_DATE FROM BOOK ORDER BY PUBLICATION_DATE DESC) WHERE ROWNUM 只使用 ROWNUM 容易缺資料 -- 將最便宜兩本書列出，但若要並列相同價格書就要改用RANK() SELECT * FROM (SELECT ISBN, BOOK_NAME, PRICE FROM BOOK ORDER BY PRICE) WHERE ROWNUM RANK() 函式命名後將變真實的值 -- 使用RANK()可以並列相同價格書 SELECT * FROM (SELECT BOOK_NAME, PRICE, RANK() OVER(ORDER BY PRICE) PRICE_RANK FROM BOOK) WHERE PRICE_RANK 更複雜的判斷 -- 將出書量最大的3家出版社列出 SELECT PUBLISHER_NAME, COUNT_BOOK FROM (SELECT B.PUBLISHER_ID, PUBLISHER_NAME, COUNT(ISBN) AS COUNT_BOOK FROM PUBLISHER P JOIN BOOK B ON P.PUBLISHER_ID = B.PUBLISHER_ID GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME ORDER BY COUNT_BOOK DESC) WHERE ROWNUM IN, ANY, ALL 差別 IN:用來判斷指定的值是否在子查詢中,子查詢的欄位只能有 1 個 SELECT column_name(s) FROM table_name WHERE column_name IN (SELECT statement); ANY/ALL:用來判斷指定的值是否在子查詢中,ANY 類似 OR;ALL 類似 AND SELECT column_name(s) FROM table_name WHERE column_name operator ANY|ALL (SELECT statement); EXISTS:檢查資料是否存在於子查詢中,如果有回傳 true,否則 false,與上述 IN 做值的比對不同,所以子查詢欄位使用一般常數即可 SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT 1 FROM table_name WHERE condition); IN, ANY, ALL 差別 IN: 單純比較是否與子查詢結果值相同,所以無法使用<>, , = ANY: 除了值是否相同外,還可以跟子查詢結果的任一個值比大小,屬於 OR 觀念 ALL: 跟子查詢結果的每一個值比大小,屬於 AND 觀念 EXISTS 與 IN 差別 EXISTS 判斷主查詢的欄位是否存在於子查詢,而回傳 true 或 false 以決定是否要剔除該筆資料,該欄位大都是 PK,會以索引比對,所以速度較快 範例: IN, ANY, ALL, EXISTS IN 最 常用 /* IN, ANY, ALL差別 IN: 單純比較是否與子查詢結果值相同，所以無法使用<>, , = ANY: 除了值是否相同外，還可以跟子查詢結果的任一個值比大小，屬於OR觀念 ALL: 跟子查詢結果的每一個值比大小，屬於AND觀念 */ 用這種方法，同樣價格的書也可以選中 -- IN 列出與Java書價相同的書 SELECT * FROM BOOK WHERE PRICE IN (SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%'); 列出高於任一本 Java 書價的書 -- ANY 列出高於任一本Java書價的書 SELECT * FROM BOOK WHERE PRICE >= ANY (SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%'); 列出高於所有 Java 書價的書 -- ALL: 列出高於所有Java書價的書 SELECT * FROM BOOK WHERE PRICE > ALL (SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%'); EXISTS 查詢 /* 1. EXISTS與IN執行效能比較 EXISTS判斷主查詢的欄位是否存在於子查詢，而回傳true或false以決定是否要剔除該筆資料， 該欄位大都是PK，會以索引比對，所以速度快。 IN則會以主/子查詢欄位內儲存的值詳細比對是否值相同而決定是否要剔除該筆資料， 所以一般而言只要資料庫沒有將IN語句優化，IN的執行效能會比較差。 2. EXISTS子查詢使用欄位名稱與定值 (例如數字1)的差異： 使用欄位名稱或定值不會影響EXISTS比對速度，因為如上述是以索引判斷， 但如果使用「*」或是多個欄位，會影響存入記憶體的速度，而且也較佔用記憶體空間。 */ EXISTS 有點類似 JOIN 會給每個值編號，所以在搜尋時資料量大會搜尋更快 資料少的時候使用 IN 會更快一些 -- 列出出版Java書的出版社 -- 使用 IN SELECT PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P WHERE PUBLISHER_ID IN (SELECT PUBLISHER_ID FROM BOOK B WHERE upper(BOOK_NAME) LIKE '%JAVA%'); -- 使用 EXISTS (因為這個子搜尋，欄位不是搜尋用依據，故 SELECT 1 或 SELECT 一個欄位都會更好，不要搜尋所有欄位) SELECT PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P WHERE EXISTS (SELECT 1 FROM BOOK B WHERE P.PUBLISHER_ID = B.PUBLISHER_ID AND upper(BOOK_NAME) LIKE '%JAVA%'); -- 使用 JOIN SELECT P.PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P JOIN BOOK B ON P.PUBLISHER_ID = B.PUBLISHER_ID AND upper(BOOK_NAME) LIKE '%JAVA%'; 循序搜尋 第一間房間敲到最後一間房間找人 IN 方法 剔除不對的房間 雜湊搜尋 房間只剩下 7 間住房間時讓 8 個，用同學座號%7(mod)最後住一間 EXISTS 方法 編號怎麼編，號碼就要怎麼找(用空間換時間) 將要找的值濃縮成一個整數 只找對的 直接找對的房間 EXISTS 練習 -- 使用EXISTS列出所有台北客戶的總訂購量 ---- EXISTS 好處是不需再作關聯即可跟主表的東西做比較，但兩張表一定要有相關聯的數據 ---- 而且也因是使用雜湊方式搜尋故數據量大時搜尋速度會更快 ---- 在此表當中因為order_detail要與customer沒有相關聯的數據，故要再多關聯一張order_master表 ---- 因為有關聯了order_master故也有它的數據，因此才能將\"台北客戶\"跟\"訂購量\"一起判斷 SELECT sum(QUANTITY) 台北客戶總訂購量 FROM order_detail od JOIN order_master om ON om.order_id = od.order_id WHERE EXISTS (SELECT 1 FROM customer c WHERE c.customer_id = om.customer_id AND upper(c.address) LIKE '%TAIPEI%'); -- 列出不在訂單上的所有書名 (使用EXISTS) SELECT BOOK_NAME 書名 FROM book b WHERE NOT EXISTS (SELECT 1 FROM order_detail od WHERE od.isbn = b.isbn); UNION JOIN 將不同欄位做水平合併,會增加欄位;UNION 將不同欄位做垂直合併,不會增加欄位,但會增加資料筆數 SELECT column_name(s) FROM table1 UNION (ALL) SELECT column_name(s) FROM table2; UNION 合併資料必須注意 要合併的 2 個 SELECT 子句,其欄位數要相同 要合併的 2 個 SELECT 子句,資料類型要相容 合併後會以第一個 SELECT 子句的欄位名稱為主 GROUP BY 和 HAVING 子句可用於 SELECT 子句中,但不可用於 UNION 之後的結果 ORDER BY 只能用於 UNION 之後的結果,不可用於 SELECT 子句中 UNION 後若有重複的結果,只會顯示一筆;加上 ALL 參數,則會全部顯示出來 "},"4.Oracle/7.查詢結果建立表格與View/01.SELECT與VIEW.html":{"url":"4.Oracle/7.查詢結果建立表格與View/01.SELECT與VIEW.html","title":"01.SELECT 與 VIEW","keywords":"","body":"利用 SELECT 新增資料 建立新表格並將查詢結果插入 CREATE TABLE table_name AS SELECT column1, column2,... FROM existing_table_name WHERE ....; 將查詢結果插入已存在表格 INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition; SELECT 範例 建立表格 -- CREATE TABLE AS SELECT -- 建立BOOK_BACK表格並將書價>=1000的書名、定價、作者、出版日期插入 ---- 建立表格並將 BOOK 資料複製過去 CREATE TABLE BOOK_BACK AS SELECT BOOK_NAME, PRICE, AUTHOR, PUBLICATION_DATE FROM BOOK WHERE PRICE >= 1000; 錄入新資料 -- INSERT INTO SELECT -- 將書價 View 概論 view (視表) 可說是一個虛擬表格 使用 SELECT 語法來建立 view view 永遠都呈現最新內容 每次 user 查詢 view 時,資料庫系統都會依照該 SELECT 語法重新建立一次 view 內容 可建立唯讀/非唯讀的 view 沒有表格就建立新的，還可以當作個判斷 這樣更好一些，不會 error View 的管理 建立 view CREATE VIEW view_name AS SELECT column1, column2, ... FROM table_name WHERE condition; 建立或取代 view CREATE OR REPLACE VIEW view_name AS SELECT column1, column2, ... FROM table_name WHERE condition; 查詢 view SELECT column1, column2, ... FROM view_name; 刪除 view DROP VIEW view_name; View 內容異動 可以將資料新增至 view 所代表的表格內,也可查詢到 將 FK 設定為 NULL,就不符合建立 view 時的查詢條件,所以無法透過 view 查詢到,必須查詢真實表格 不符合 view 條件的資料,也就無法透過 view 刪除 不建議使用，也很少用 建立唯讀 View 建立唯讀 view CREATE OR REPLACE VIEW view_name AS SELECT column1, column2, ... FROM table_name WHERE condition WITH READ ONLY; 唯讀 view 的內容無法異動,會發生錯誤 View 範例 建立 view -- 建立view CREATE VIEW BOOK_VIEW AS SELECT ISBN, BOOK_NAME, PRICE, AUTHOR, PUBLICATION_DATE, B.PUBLISHER_ID, PUBLISHER_NAME, PHONE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID WHERE PRICE 建立或取代 view -- 建立或取代view CREATE OR REPLACE VIEW BOOK_VIEW AS SELECT ISBN, BOOK_NAME, PRICE, AUTHOR, PUBLICATION_DATE, B.PUBLISHER_ID, PUBLISHER_NAME, PHONE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; 查詢 view -- 查詢view SELECT * FROM BOOK_VIEW; 刪除 view -- 刪除view DROP VIEW BOOK_VIEW; 新增 view 資料 -- VIEW CONTENT -- 可以將資料新增至view所代表的表格內，也可查詢到 INSERT INTO BOOK_VIEW (ISBN, BOOK_NAME, PRICE, PUBLISHER_ID) VALUES ('1234567890123', 'TEST_BOOK1', 250, 'P001'); 設定 view 查詢條件 -- 將FK設定為NULL，就不符合建立view時的查詢條件，所以無法透過view查詢到，必須查詢真實表格 UPDATE BOOK_VIEW SET PUBLISHER_ID = NULL WHERE ISBN = '1234567890123'; SELECT * FROM BOOK_VIEW; -- 查詢不到修改完的資料 SELECT * FROM BOOK; -- 必須查詢真實表格 不符合 view 條件的資料，就無法透過 view 刪除 -- 不符合view條件的資料，就無法透過view刪除 DELETE FROM BOOK_VIEW WHERE ISBN = '1234567890123'; DELETE FROM BOOK WHERE ISBN = '1234567890123'; 設定 View 表格唯讀 -- READ-ONLY VIEW CREATE OR REPLACE VIEW BOOK_VIEW AS SELECT ISBN, BOOK_NAME, PRICE, AUTHOR, PUBLICATION_DATE, B.PUBLISHER_ID, PUBLISHER_NAME, PHONE FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID WITH READ ONLY; 唯讀 view 的內容無法異動，會發生錯誤 -- 唯讀view的內容無法異動，會發生錯誤 INSERT INTO BOOK_VIEW (ISBN, BOOK_NAME, PUBLISHER_ID) VALUES ('9876543210123', 'TEST_BOOK2', 'P002'); "},"4.Oracle/8.使用者授權/01.權限相關.html":{"url":"4.Oracle/8.使用者授權/01.權限相關.html","title":"01.權限相關","keywords":"","body":"User 異動 SQL Developer 以 DBA 身份新增 user 與密碼,建立預設與暫時表格空間 點選連線資料庫 > Other Users 右鍵 > Create User USER 頁籤 > 填寫 User Name 與 Password > Default Tablespace 選 USERS;Temporary Tablespace 選 TEMP Granted Roles 頁籤 > 勾選 CONNECT 與 RESOURCE 方能連線 與使用資源 System Priviledges 頁籤 > 勾選 CREATE TABLE 方能建立表格 修改 User 設定 點選連線資料庫 > Other Users > 對指定 User 右鍵 > Edit User SQL 語法 新增 User CREATE USER user_name IDENTIFIED BY password DEFAULT TABLESPACE tablespace_name TEMPORARY TABLESPACE temp_tablespace_name 授權 CONNECT 與 RESOURCERESOURCE 包含表格權限 權限方能連線與使用資源 GRANT CONNECT TO user_name; SQL Plus:SQL> CONNECT user_name; GRANT RESOURCE TO user_name; 授權 CREATE TABLE 權限方能建立表格 GRANT CREATE TABLE TO user_name; 查詢 CONNECT 與 RESOURCE 系統權限。DBA 開頭的表格需要 DBA 身份方能查詢 SELECT _ FROM DBA_SYS_PRIVS WHERE GRANTEE = 'CONNECT'; SELECT _ FROM DBA_SYS_PRIVS WHERE GRANTEE = 'RESOURCE'; 修改 User 密碼 (以下 SQL 指令可以在 SQL Plus 或 SQL Developer 執行) 使用 sysdba 登入後修改指定 user 密碼 作業系統提示字元> sqlplus / as sysdba SQL> ALTER USER user_name IDENTIFIED BY \"password\"; User 登入後修改自己密碼 作業系統提示字元> sqlplus user_name/password SQL> PASSWORD 刪除 user 先中斷連線,加上 CASCADE 是要連鎖刪除相關物件 DROP USER user_name CASCADE; 表格授權 授權指定表格的 SELECT 權限方能查詢 GRANT SELECT ON table_name TO user_name; 測試時,連線改成指定的 SCHEMA,SQL 可以省掉輸入 SCHEMA 名稱的麻煩 ALTER SESSION SET CURRENT_SCHEMA = BOOKSHOP; 授權指定表格的所有權限 GRANT ALL ON table_name TO user_name; 查詢 User 權限 user 查詢自己的系統、角色、表格權限 SELECT * FROM USER_SYS_PRIVS; SELECT * FROM USER_ROLE_PRIVS; SELECT * FROM USER_TAB_PRIVS; 查詢 user 系統、角色、表格權限。DBA 開頭的表格需要 DBA 身份方能查詢 SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'user_name'; SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE = 'user_name'; SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE = 'user_name'; 撤銷表格授權 撤銷建立表格權限 REVOKE CREATE TABLE FROM user_name; 撤銷指定表格的 SELECT 權限 REVOKE SELECT ON table_name FROM user_name; 撤銷指定表格的所有權限 REVOKE ALL ON table_name FROM user_name; 建立表格的各種實際指令操作 -- CH8-1 User異動 -- 新增user，IDENTIFIED BY設定密碼，建立預設與暫時表格空間 ---- CREATE USER 創帳號 ---- IDENTIFIED BY 設定帳號的密碼 CREATE USER TEST1 IDENTIFIED BY TEST1 DEFAULT TABLESPACE \"USERS\" TEMPORARY TABLESPACE \"TEMP\"; -- 授權CONNECT與RESOURCE權限方能連線與使用資源 GRANT CONNECT TO TEST1; GRANT RESOURCE TO TEST1; -- 授權CREATE TABLE權限方能建立表格 GRANT CREATE TABLE TO TEST1; -- 登入新帳號測試可否建立表格 CREATE TABLE AUTHOR ( AUTHOR_ID VARCHAR2(40) PRIMARY KEY NOT NULL, AUTHOR_NAME VARCHAR2(40) NOT NULL ); DROP TABLE AUTHOR; -- 查詢CONNECT與RESOURCE系統權限，DBA開頭的表格需要DBA身份方能查詢 SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'CONNECT'; SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'RESOURCE'; ------------------------------------------------------------------------ -- 修改指定user密碼 ALTER USER TEST1 IDENTIFIED BY \"TEST111\"; -- 修改自己密碼 PASSWORD; ------------------------------------------------------------------------ -- 刪除user(要先中斷連線)，加上CASCADE是要連鎖刪除相關物件 DROP USER TEST1 CASCADE; ------------------------------------------------------------------------ ------------------------------------------------------------------------ -- CH8-2 表格授權 -- 授權指定表格的SELECT權限方能查詢 GRANT SELECT ON BOOK TO TEST1; GRANT SELECT ON PUBLISHER TO TEST1; -- 測試時，TEST1連線改成指定的SCHEMA，SQL可以省掉輸入SCHEMA名稱的麻煩 ALTER SESSION SET CURRENT_SCHEMA = BOOKSHOP; -- 取得指定表格的SELECT授權即可測試查詢功能 SELECT BOOK_NAME, PRICE, AUTHOR, PUBLISHER_NAME FROM BOOK B JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID; -- 授權指定表格的所有權限 GRANT ALL ON BOOK TO TEST1; GRANT ALL ON PUBLISHER TO TEST1; -- 取得指定表格的所有權限即可測試增刪改查功能 UPDATE PUBLISHER SET CONTACT = 'AAA' WHERE PUBLISHER_ID = 'P00X'; COMMIT; -- 查詢修改結果 SELECT * FROM PUBLISHER; ------------------------------------------------------------------------ ------------------------------------------------------------------------ -- CH8-3 查詢User權限 -- user查詢自己的系統、角色、表格權限 SELECT * FROM USER_SYS_PRIVS; SELECT * FROM USER_ROLE_PRIVS; SELECT * FROM USER_TAB_PRIVS; -- 查詢user系統、角色、表格權限，DBA開頭的表格需要DBA身份方能查詢 SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'TEST1'; SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE = 'TEST1'; SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE = 'TEST1'; ------------------------------------------------------------------------ ------------------------------------------------------------------------ -- CH8-4 撤銷表格授權 -- 撤銷建立表格權限(同時撤銷CREATE TABLE與RESOURCE比較保險) REVOKE CREATE TABLE FROM TEST1; REVOKE RESOURCE FROM TEST1; -- 撤銷指定表格的SELECT權限 REVOKE SELECT ON BOOK FROM TEST1; REVOKE SELECT ON PUBLISHER FROM TEST1; -- 撤銷指定表格的所有權限 REVOKE ALL ON BOOK FROM TEST1; REVOKE ALL ON PUBLISHER FROM TEST1; ------------------------------------------------------------------------ 參考鏈接: 結構化查詢語言 三大類型 "},"5.雲端概論及技術/1.雲端運算概論/1-1.什麼是雲端計算.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-1.什麼是雲端計算.html","title":"1-1.什麼是雲端計算","keywords":"","body":"目錄 1. 雲端計算歷史 2. 區塊鍊(Blockchain) 3. WEB 的演進 4. 人工智慧分類 5. 人工智慧與學習 6. 機器學習 (Machine Learning) 7. 物聯網(IoT)演進 8. 沉浸式體驗(Imersive Experience) 9. Gartner 2020 年十大策略性科技趨勢 10. 現在與未來 11. 工程思考 1. 雲端計算歷史 Moore's Law 電腦上的電晶體以摩爾定律方式運算，平均 1.5 年晶片上會增加 2 倍電晶體數量，故會越來越便宜(克服摩爾定律的部分，是量子電腦) 量子電腦，速度快效率高 1990s 分布式運算 Client Server(資料庫、網頁) 會有網頁伺服器 跟資料庫伺服器，將來會建立單獨分別的伺服器滿足各項需求 2000s 網路端應用 2010s 移動端發展 2020s 雲端與普存運算 無所不在的運算 Application 雲端應用 2. 區塊鍊(Blockchain) 區塊鏈概論 去中心化 交易公開化 帳本是一個區塊鏈的方式呈現 > 區塊鏈中的每個區塊記錄著幾百到幾千筆交易 > 最終將各個區塊串接起來形成一個帳本(區塊鏈) 帳本會存在成千上萬台電腦中，以後就不需要主管機構來管理了 區塊鏈的深入 密碼學 (幾乎)不可偽造、竄改 博弈理論 幾乎 不會讓人想修改他 電腦科學 樹狀結構 區塊鏈演化三部曲 沒區塊鏈前 中心化的世界 區塊鏈 1.0 比特幣: 去中心化開始 產品履歷可用區塊鏈上記錄 區塊鏈 2.0 以太坊: 智慧合約簽證 區塊鏈 3.0 IOTA: 連接實體生活、物聯網 中國數字貨幣：無紙化時代悄悄到來！ 3. WEB 的演進 1990-2000，Web 1.0 (Web，網，作用:連接知識，少數人產生內容給多人用) blog 2000-2010，Web 2.0 (Social Web，社群網，作用:連接知識引入社群) facebook，wiki，團購 2010-2020，Web 3.0 (Semantic Web，語義網，作用:連接知識，人工智慧) 淘寶推薦，博客來推薦 2020-2030，Web 4.0 (ubiquitous，無所不在的網，作用:連接情報) 4. 人工智慧分類 Artificial Narrow Intelligence: 弱人工智慧，只將 AI 運用於特定的任務即場域 (例:阿法狗) Artificial General Intelligence: 強人工智慧，機器能推理和解決問題，並有自我意識 Artificial Super Intelligence: 機器完全超人類 5. 人工智慧與學習 Artificial Intelligence 人工智慧 Machine Learning 機器學習 購物攔車原理 Deep Learning 深度學習 機器學習分支，用人工神經網路為架構，對資料進行表徵學習的方法 6. 機器學習 (Machine Learning) Supervised Learning(監督式學習) Unsupervidsed Learning(非監督式學習) Reinforcement Learning(強化學習) 阿法狗後期互相強化學習新的圍棋技巧 7. 物聯網(IoT)演進 2010 年之前，RFID 被廣泛應用於物流、零售和製藥領域 2010-2015，物體物連 2015-2020，物體進入辦智慧化 2020 年之後，物體進入全智慧化(AIOT) 8. 沉浸式體驗(Imersive Experience) VR(Virtual Reality)，虛擬實境 AR(Augmented Reality)，擴增實境 MR(Mixed Reality)，混合實境 9. 現在與未來 目前 工業 3.0 > 工業 4.0 7 奈米 > 5 奈米 > 3 奈米 > 量子電腦 Social Cloud Computing > Ubiquitous Computing Internet Web Site Hosting > Cloud Native Application 集中式雲端計算 > 分散式雲端計算 + 邊緣運算 Relational Database > NoSQL(Polyglot Persistence) Web 2.0 > Web 3.0 > Web 4.0 專家系統 > 類神經網路 > 深度學習 區塊鏈 1.0 > 區塊鏈 2.0 > 區塊鏈 3.0 10. Gartner 2020 年十大策略性科技趨勢 Gartner，每年會發布研究結果，需要關注 科技趨勢 Hyperautomation(超自動化) Multiexperience(多重體驗) Democratization of Expertise(專業知識的民主化) 不必有很深的數學統計背景就可使用 不必太專業 Human Augmentation(人類增強) Transparency and Traceablity(透明度的可追溯性) The Empowered Edge(邊緣賦能) Distributed Cloud(分布式雲) Autonomous Things(自主設備) Practical Blockchain(實用型區塊鏈) AI Security(AI 安全) 11. 工程思考 開發處裡 前進 倒退 多開 斷網 關閉 功能模組化 "},"5.雲端概論及技術/1.雲端運算概論/1-2.雲端運算的基本特性.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-2.雲端運算的基本特性.html","title":"1-2.雲端運算的基本特性","keywords":"","body":"目錄 1. 雲端的基本特性(會考) 2. 雲端運算案例 1. 雲端的基本特性(會考) 隨需自助服務(On-demand self-service) 用水，按量付費 廣泛的網路接入(Broad network access) 上網就可用 共享資源池(Resource pooling) 虛擬機共享一台實體機 快速彈性(Rapid elasticity) 隨時進行動態擴展與配置 測量服務(Measured Service) 自動監控資源使用與優化，由雲供應商來負責最佳化 2. 雲端運算案例 租機器 租平台 租軟體 "},"5.雲端概論及技術/1.雲端運算概論/1-3.雲端運算的服務模式.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-3.雲端運算的服務模式.html","title":"1-3.雲端運算的服務模式","keywords":"","body":"目錄 1. 雲端運算的服務模式(記住) 1. 雲端運算的服務模式(記住) Infrastructure-as-a-Service(Iaas) 計算能力 資料中心(Data Center) Platform-as-a-service(PaaS) 編程環境 開發、運行、管理、監控 少用，一旦用了就會被此平台綁住了 Software-as-a-Service(SaaS) 雲端軟體 應用系統 提供軟體服務，僅需打開瀏覽介面查看 Gmail 分類 服務類型 運用的靈活度 運用的難易度 IaaS 接近原始計算與儲存能力 高 難 Paas 應用軟體的託管環境 中 中 SaaS 特定功能的運用軟體 低 易 "},"5.雲端概論及技術/1.雲端運算概論/1-4.雲端運算的部屬模型.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-4.雲端運算的部屬模型.html","title":"1-4.雲端運算的部屬模型","keywords":"","body":"目錄 1. 雲端運算的部屬模型 2. 雲端運算對個人的影響 3. 雲端對企業的影響 4. Distributed Cloud Computing 分散式雲端運算 5. Edge Computing 邊緣運算 6. Cloud Computing + Edge Computing 1. 雲端運算的部屬模型 Public Cloud(公有雲) 成本低、安全性較低 Private Cloud(私有雲) 成本貴、安全性較高 建立在公司防火牆內，安全性較高，維護成本也高 Community Cloud(社群雲) 比私有雲小，比公有雲大 教育雲，給公有學校的老師、學生、家長使用 消防雲 市場雲 Hybrid Cloud(混合雲) 由兩個或兩個以上(公有雲/私有雲/社群雲)所組成的雲 Personal Cloud(個人雲) 任何一個裝置的更改都能同步 2. 雲端運算對個人的影響 使用方便性 立即可上線 操作更輕鬆 程式開發社群 3. 雲端對企業的影響 節省資金成本 更新、升級更快速 4. Distributed Cloud Computing 分散式雲端運算 Edge cloud 邊緣雲 Regional Cloud 區域雲 Central Cloud 中心雲 5. Edge Computing 邊緣運算 EDGE 邊緣設備，一個小設備即可處裡所有問題 6. Cloud Computing + Edge Computing EDGE 終端 FOG 霧端 CLOUD 雲端 "},"5.雲端概論及技術/1.雲端運算概論/1-5.雲端運算的關鍵技術.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-5.雲端運算的關鍵技術.html","title":"1-5.雲端運算的關鍵技術","keywords":"","body":"目錄 1. 虛擬化的特性 2. 虛擬化種類 3. Software Define Everything 1. 虛擬化的特性 各類的計算機資源都能虛擬化 隱藏了不必要的細節 實踐真實環境的部分或全部功能 2. 虛擬化種類 硬體(Hardware)虛擬化 (成熟) 對計算機或作業系統的虛擬化 提升能源效率 展現最高的可用性與效能 改善災難復原解決方案並提高可用性 加快桌面平台部屬速度 記憶體(Memory) 虛擬記憶體 (成熟) 將程式與記憶體切割成 page 大小，排程方式執行，若要執行新頁則將沒怎麼用到的功能剔除在放新的 可以做到多支程式同時執行 記憶體共用 (特殊環境) 記憶體虛擬化，將 RAM 與系統解耦合(decouple)後，再將這些記憶體資源整合入虛擬記憶池(memory)中，提供叢集從(Cluster)中應用 刀鋒伺服器(可研究) 共享記憶池 提升效率 儲存體 (成熟) 磁碟陣列(RAID)(Redundant Array of Independent Disks) 將很多個便宜硬碟組合，變成一個磁碟陣列組 看起來就像一個單獨的硬碟或邏輯存儲單元 Parity odd even 網路儲存設備(NAS) 儲存區域網路(SAN) 雲端儲存(Cloud Storage) 第三方託管的多台虛擬機 應用系統虛擬化 (不成熟) 將應用系統封裝起來，以獨立於其下之作業系統 Docker 讓應用程式部屬在軟體容器下的工作可以自動化進行 VM: 啟動與執行需要比較多資源，因為三個系統都要運行 CONTAINER: 除了 OS 層，作法會比較好 資料虛擬化 (不成熟) 各類資料庫中的資料加以抽象化 資料用處理後載入資料庫當中(ETL) 線上交易處裡(OLAP) (偏重) 桌面虛擬化 桌面環境與其使用的終端設備解耦合(decouple，桌面伺服器) 電腦上會建立一個獨立 OS 環境 不同位置環境資料可同步 資料不會外洩 系統所有操作都有紀錄 網路 (成熟) 所有網路相關都能虛擬化 區域網路虛擬化，VLAN(Virtual LAN)是代表技術 廣域網路虛擬化，VPN，可建立虛擬的私人專線，資料較不會被竊取盜用... 3. Software Define Everything SDx/SDE 無論網路、儲存、行動運算都可以經由軟體定義，化身成為雲端的一部分元件 "},"5.雲端概論及技術/1.雲端運算概論/1-6.雲端概論的資料讀取.html":{"url":"5.雲端概論及技術/1.雲端運算概論/1-6.雲端概論的資料讀取.html","title":"1-6.雲端概論的資料讀取","keywords":"","body":"目錄 1. GFS 用來容錯的概念與方法 2. 提升系統容錯 3. Consistency Model 4. Master Operations 5. Fault Tolerance 6. RDBMS Vs. NoSQL 7. MapReduce Programming Model 8. Automatic ... 1. GFS 用來容錯的概念與方法 GFS 可擴充分散式的 GFS Client 老師會考(圖文填空，p.110)會將資料挖空，考實際內容。問挖空的區域具體是在做什麼 chunk locations 資料塊位置 chunk handel 資料塊編號 chunk data 資料塊值 Control message 小資料量 Data message 大資料量 不管是 client 或 chunkserver 都不會快取 file data，因為每個人都一直在讀取，所以都會一直由源頭拿資料 資料塊大可以減少跟 master 取資料的機會，但資料塊大會容易 hot spots Chunk Locations 資料塊所在位置，電腦關機後資料保存的地方 資料會放在記憶體中(因為放在硬碟讀取太慢) polls chunkservers ，polls 輪流詢問 HeartBeat message，HeartBeat 心跳，心跳回應 Operation Log 工作紀錄，包含對 metadata 更改的歷史紀錄 checkpoint 用檔案大小、檔案時間來確認資料備份的時間點(缺點 1-0.5 小時回復，即需要很久的資料時間) 要回復資料，也要暫停系統(對即時處裡的站台會很有影響，ex.gmail 不能當掉) 2. 提升系統容錯 Active Master Standby Master 平常只作複製 Active Master 環境的作用，用於 master 當機立刻接手 Active Master 的工作 3. Consistency Model 多人存取會造成一致性的問題，將會複雜化整個動作 由 cline 確定是 retrying 還是 aboal 4. Master Operations 考慮附載安全 考慮機架問題(不要放在同一排，同一機架上)(分散儲存) 5. Fault Tolerance HA 架構 分散式都有做到，透過 standby master 都能做到 能支援大量儲存的能力 6. RDBMS Vs. NoSQL RDBMS 資料庫 關聯式料庫 NoSQL 資料庫(Big Table) google 跟亞瑪遜幾乎同一個時間創建了大數據資料庫的概念(後續回學到 Redls 資料庫，此資料庫也是 NoSql 的一種) 聊天信息池 因為放在資料庫裏面所以會很快(資料量小、資料結構複雜、速度需要很快可以放 Redls) 7. MapReduce Programming Model 資料平行處裡 MapReduce 是種 Programming Model(寫作程式模型)，適合用來處理大量資料。一般電腦就能做所以也要容錯、狀態監控等等 別名 yarn 名子可能被換掉，多用在 google(google 先做到了) 8. Automatic ... Map Overation 會將輸入資料切割成很多分割(split)，並給不同的機器，這些分割可以在不同機器上平行處理 虛擬碼可以很好的表達概念 洗牌動作 "},"6.Javascript/1.CoreJavascript/01.Javascript新手村.html":{"url":"6.Javascript/1.CoreJavascript/01.Javascript新手村.html","title":"01.Javascript 新手村","keywords":"","body":"Javascript? 是一種直譯式語言 是一種單執行敘 (而 java 是一種多執行敘) 機制 自動回收記憶體 執行三步驟 語法分析 預編譯 解釋執行 編譯一行執行一行 放置位置 head body 放置方法 為什麼要用變數 變數相當於指向資料的標籤 所有變數都是弱型別 var let const \"\" 字串型別 '' 基本型別 true/false boolean 第一個 javascript Document console.log('Hello World'); Hello World 基本型別轉換 var a; var b = 23; var c = 'hellow'; var d = true; console.log(a); console.log(b); console.log(c); console.log(d); console.log('---------------'); console.log(typeof a); console.log(typeof b); console.log(typeof c); console.log(typeof d); undefined 23 hellow true --------------- undefined number string boolean 數字與非數字檢查 console.log('--------string to num-------'); let e = parseInt('23'); let f = parseFloat('23.22'); let g = parseInt('abc'); console.log(typeof e); console.log(typeof f); console.log(typeof g); console.log(e); console.log(f); console.log(g); // NAN 型別是 number console.log('--------num to string-------'); let h = new String('233.3'); let h2 = 233 + ''; console.log(typeof h); console.log(typeof h2); console.log('--------test NaN-------'); console.log(isNaN(123)); // false console.log(isNaN('123')); // false console.log(isNaN('abc')); // true --------string to num------- number number number 23 23.22 NaN --------num to string------- object --------test NaN------- false false true 運算式 + 加法 - 減法 * 乘法 / 除法 % 取餘 ++ 遞增 -- 遞減 ** 指數運算 平方或次方 let y = 5; x = y + 2; console.log(x); x = y - 2; console.log(x); x = y * 2; console.log(x); x = y / 2; console.log(x); x = y ** 2; console.log(x); console.log(y); 7 3 10 2.5 25 5 嚴格相等 > 大於 >= 大於等於 小於等於 小於 == 一般等於(比較值) 0 == false true === 嚴格等於(比較類型與值) 0 === false false !== 嚴格不等於 5 !== 5 false let str1 = 'H'; let str2 = 'i'; console.log(str1 + str2); console.log('---------------'); let num = 1; let str3 = '1'; let bool = true; console.log(num == str3); console.log(num === str3); console.log(bool == str3); console.log(bool === str3); console.log('---------------'); console.log(null === undefined); Hi --------------- true false true false --------------- true 邏輯運算 && and || or ! not 指定運算 = += a = a + 33 -= *= /= %= 三元運算 (條件) ? 對的值 : 錯的值 switch let value = 'b'; switch (value) { case 'a': console.log('A'); break; case 'b': console.log('B'); break; default: console.log('default'); break; } 從上執行而下 例子 1 let value = 'b'; switch (value) { default: console.log('default'); case 'a': console.log('A'); case 'b': console.log('B'); } B 例子 2 let value = 'g'; switch (value) { default: console.log('default'); case 'a': console.log('A'); case 'b': console.log('B'); } default A B 為什麼要有陣列(Array)? 同類型的資料不用命名太多變數 集合在一起也方便管理 for loop 配合可以迭代宣告、取值、修改 陣列內容可以放任何資料型別 陣列也是一種物件 陣列長度可以動態配置 copy by reference 宣告及初始化陣列的兩種方式? let arr = []; let arr = new Array(); let arr = new Array(3); 陣列的練習 let arr = new Array(); console.log(arr); arr.push(1); console.log(arr); arr[1] = 2; console.log(arr); [] [1] [1,2] 二維陣列 let arr = []; for(let i = 0;i 0: (4) [0, 1, 2, 4] 1: (4) [1, 2, 3, 4] 2: (4) [2, 3, 4, 4] 3: (4) [3, 4, 5, 4] 陣列常用屬性與方法 length 陣列長度 push(元素) 新增最後 pop() unshift(元素) 新增開頭 shift() 移除開頭 let arr = []; for (let i = 0; i [5, 0, 1, 2, 3] [0, 1, 2, 3] [0, 1, 2, 3, 6] [0, 1, 2, 3] 陣列常用屬性與方法 2 arr.splice(start, delNum) arr.slice(start, getNum) ，不包含取出的最後一個數 arr.reverse() 陣列反轉 arr.sort() 陣列用 unicode 順序排序 let arr = [1, 3, 8, 2, 4]; console.log(arr.sort()); [1, 2, 3, 4, 8]; arr.indexOf(元素) 找到第一個該元素的索引值(index) 找不到則回傳 -1 arr.lastIndexOf(元素) 找出最後一個該元素的索引值(index) arr.join(串接字符) 將陣列中所有元素,藉由指定的字符合併在一起變成字串 let arr = [1, 3, 8, 2, 4]; let arr2 = [1, 3, 8, 2, 4]; console.log(arr.join(arr2)); console.log(arr.join('@@')); 11,3,8,2,431,3,8,2,481,3,8,2,421,3,8,2,44 1@@3@@8@@2@@4 arr.concat() let arr = [1, 3, 8, 2, 4]; let arr2 = [1, 3, 8, 2, 4]; console.log(arr.concat(arr2)); [1, 3, 8, 2, 4, 1, 3, 8, 2, 4] function 函式 函式 (function),用來將會重複使用的程式碼封裝在一起,方便重複執行。 函式包含了兩個的部分,名稱 (name) 與可執行的程式內容 (code) 函式的名稱是可有可無的,它可以是一個匿名函式 (anonymous function); 而程式內容的部分,我們則是可以透過 () 來加以執行(invoke)。 在 JavaScript 中,函式也是一種物件,所以 可以將 function 儲存成變數 可以將 function 當成參數代入另一個 function 中 (callback function 回呼函式) 可以在一個 function 中回傳另一個 function function 跟物件一樣有屬性 (property) 匿名函式需要先宣告在執行 msg(); // 執行失敗 let msg = () => {}; // 變成變數後在此步驟才創建好 msg(); // 所以只能 msg 後用 msg(); // 執行成功 function msg() {} msg(); // 執行成功 函式變數作用域 let a = 10; // 全域變數 function sum(b, c) { a = 23; // 全域變數 let d = a + b + c; // 區域變數 return d; } sum(2, 3); console.log(a); // 23 console.log(sum(2, 3)); 23 28 回呼函式 回呼函式(CallBack Function) 將 function 當成參數代入另一個 function 的例子: Callback 函式,亦稱回呼函式,是「在一支函式執行完後,才要執行的函式」 document.addEventListener('click', function () { console.log('Mouse Click!'); }); window 物件 全域物件，窗口關閉才會消失 let a = 10; console.log(window.a); // undefined var b = 10; console.log(window.b); // 10 function sum() { return 2 + 3; } let sums = () => { return 2 + 3; }; console.log(window.sum()); // 5 console.log(window.sums()); // window.sums is not a function 常用視窗屬性 alert(文字) 彈訊息框 confirm(文字) 彈對話框 prompt(文字, 預設值) 彈輸入框 open(URL, 視窗名稱) 開新視窗，回傳一個 window close() 關窗口 focus() 母窗到子窗 blur() 去除焦點 計時器 setInterval(指定程式, 間格時間) 週期性執行 clearInterval(計時器變數) 關閉 setInterval setTimeout(指定格式, 間隔時間) 經過一段時間後執行一次 clearTimeout(計時器變數) 取消 setTimeout 取得 Dom 元素的六種方法 document.getElementById(idName) document.getElementsByClassName(className) document.getElementsByTagName(tagName) 用標籤名稱 document.getElementsByName(tagName) 用標籤 document.querySelector(css 選擇器) 找到第一個 document.querySelectorAll(css 選擇器) 找到全部★ css 熟直接用這個 "}}