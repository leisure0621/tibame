# Javascript?

- 是一種直譯式語言

- 是一種單執行敘 (而 java 是一種多執行敘)

# 機制

- 自動回收記憶體

# 執行三步驟

- 語法分析
- 預編譯
- 解釋執行

  - 編譯一行執行一行

# 放置位置

- head
- body

# 放置方法

- `<script></script>`

- `<script src=""></script>`

# 為什麼要用變數

- `變數`相當於`指向資料的標籤`

# 所有變數都是弱型別

- `var`

- `let`

- `const`

- `""` 字串型別

- `''` 基本型別

- `true/false` boolean

# 第一個 javascript

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script src="script.js"></script>
    <title>Document</title>
  </head>
  <body>
    <script>
      console.log('Hello World');
    </script>
  </body>
</html>
```

---

```cs
Hello World
```

# 基本型別轉換

```html
<script>
  var a;
  var b = 23;
  var c = 'hellow';
  var d = true;
  console.log(a);
  console.log(b);
  console.log(c);
  console.log(d);
  console.log('---------------');
  console.log(typeof a);
  console.log(typeof b);
  console.log(typeof c);
  console.log(typeof d);
</script>
```

---

```cs
undefined
23
hellow
true
---------------
undefined
number
string
boolean
```

# 數字與非數字檢查

```html
<script>
  console.log('--------string to num-------');
  let e = parseInt('23');
  let f = parseFloat('23.22');
  let g = parseInt('abc');
  console.log(typeof e);
  console.log(typeof f);
  console.log(typeof g);
  console.log(e);
  console.log(f);
  console.log(g); // NAN 型別是 number
  console.log('--------num to string-------');
  let h = new String('233.3');
  let h2 = 233 + '';
  console.log(typeof h);
  console.log(typeof h2);
  console.log('--------test NaN-------');
  console.log(isNaN(123)); // false
  console.log(isNaN('123')); // false
  console.log(isNaN('abc')); // true
</script>
```

```cs
--------string to num-------
number
number
number
23
23.22
NaN
--------num to string-------
object
--------test NaN-------
false
false
true
```

# 運算式

- `+` 加法

- `-` 減法

- `*` 乘法

- `/` 除法

- `%` 取餘

- `++` 遞增

- `--` 遞減

- `**` 指數運算 平方或次方

```js
let y = 5;
x = y + 2;
console.log(x);
x = y - 2;
console.log(x);
x = y * 2;
console.log(x);
x = y / 2;
console.log(x);
x = y ** 2;
console.log(x);
console.log(y);
```

---

```cs
7
3
10
2.5
25
5
```

# 嚴格相等

- `>` 大於

- `>=` 大於等於

- `<=` 小於等於

- `<` 小於

- `==` 一般等於(比較值) `0 == false` `true`

- `===` 嚴格等於(比較類型與值) `0 === false` `false`

- `!==` 嚴格不等於 `5 !== 5` `false`

```js
let str1 = 'H';
let str2 = 'i';
console.log(str1 + str2);
console.log('---------------');
let num = 1;
let str3 = '1';
let bool = true;
console.log(num == str3);
console.log(num === str3);
console.log(bool == str3);
console.log(bool === str3);
console.log('---------------');
console.log(null === undefined);
```

```cs
Hi
---------------
true
false
true
false
---------------
true
```

# 邏輯運算

- `&&` and

- `||` or

- `!` not

# 指定運算

- `=`

- `+=` a = a + 33

- `-=`

- `*=`

- `/=`

- `%=`

# 三元運算

- (條件) ? 對的值 : 錯的值

# switch

```js
let value = 'b';
switch (value) {
  case 'a':
    console.log('A');
    break;
  case 'b':
    console.log('B');
    break;
  default:
    console.log('default');
    break;
}
```

- 從上執行而下

- 例子 1

```js
let value = 'b';
switch (value) {
  default:
    console.log('default');
  case 'a':
    console.log('A');
  case 'b':
    console.log('B');
}
```

---

```cs
B
```

- 例子 2

```js
let value = 'g';
switch (value) {
  default:
    console.log('default');
  case 'a':
    console.log('A');
  case 'b':
    console.log('B');
}
```

---

```cs
default
A
B
```

# 為什麼要有陣列(Array)?

- 同類型的資料不用命名太多變數
- 集合在一起也方便管理
- for loop 配合可以迭代宣告、取值、修改
- 陣列`內容`可以放`任何資料型別`
- 陣列也是一種`物件`
- 陣列`長度`可以`動態`配置
- copy by reference

# 宣告及初始化陣列的兩種方式?

- let arr = [];
- let arr = new Array();
- let arr = new Array(3);

# 陣列的練習

```js
let arr = new Array();
console.log(arr);
arr.push(1);
console.log(arr);
arr[1] = 2;
console.log(arr);
```

---

```
[]
[1]
[1,2]
```

# 二維陣列

```js
let arr = [];
for(let i = 0;i<4;i++){
  arr[i] = [i,i+1,1+,1+3];
}
console.log(arr);
```

---

```cs
0: (4) [0, 1, 2, 4]
1: (4) [1, 2, 3, 4]
2: (4) [2, 3, 4, 4]
3: (4) [3, 4, 5, 4]
```

# 陣列常用屬性與方法

- length 陣列長度
- push(元素) 新增最後
- pop()
- unshift(元素) 新增開頭
- shift() 移除開頭

```js
let arr = [];
for (let i = 0; i < 4; i++) {
  arr[i] = i;
}
arr.unshift(5);
console.log(arr);
arr.shift(5);
console.log(arr);
arr.push(6);
console.log(arr);
arr.pop();
console.log(arr);
```

---

```cs
[5, 0, 1, 2, 3]
[0, 1, 2, 3]
[0, 1, 2, 3, 6]
[0, 1, 2, 3]
```

# 陣列常用屬性與方法 2

- arr.splice(start, delNum)
- arr.slice(start, getNum) ，`不包含取出的最後一個數`
- arr.reverse() 陣列反轉
- arr.sort() 陣列用 unicode 順序排序

```js
let arr = [1, 3, 8, 2, 4];
console.log(arr.sort());
```

---

```
[1, 2, 3, 4, 8];
```

- arr.indexOf(元素) 找到第一個該元素的索引值(index) `找不到則回傳 -1`
- arr.lastIndexOf(元素) 找出最後一個該元素的索引值(index)
- arr.join(串接字符) 將陣列中所有元素,藉由指定的字符合併在一起變成字串

```js
let arr = [1, 3, 8, 2, 4];
let arr2 = [1, 3, 8, 2, 4];
console.log(arr.join(arr2));
console.log(arr.join('@@'));
```

---

```cs
11,3,8,2,431,3,8,2,481,3,8,2,421,3,8,2,44
1@@3@@8@@2@@4
```

- arr.concat()

```js
let arr = [1, 3, 8, 2, 4];
let arr2 = [1, 3, 8, 2, 4];
console.log(arr.concat(arr2));
```

---

```cs
[1, 3, 8, 2, 4, 1, 3, 8, 2, 4]
```

# function 函式

- 函式 (function),用來將會重複使用的程式碼封裝在一起,方便重複執行。
- 函式包含了兩個的部分,名稱 (name) 與可執行的程式內容 (code)
- 函式的名稱是可有可無的,它可以是一個`匿名函式` (anonymous function);
  而程式內容的部分,我們則是可以透過 () 來加以執行(invoke)。
- 在 JavaScript 中,函式也是一種`物件`,所以
- 可以將 function `儲存成變數`
- 可以將 function `當成參數代入另一個 function 中` (`callback function` 回呼函式)
- 可以在一個 function 中回傳另一個 function
- function `跟物件一樣有屬性` (property)
- `匿名函式`需要`先宣告`在執行

```js
msg(); // 執行失敗

let msg = () => {}; // 變成變數後在此步驟才創建好

msg(); // 所以只能 msg 後用
```

```js
msg(); // 執行成功
function msg() {}
msg(); // 執行成功
```

# 函式變數作用域

```js
let a = 10; // 全域變數
function sum(b, c) {
  a = 23; // 全域變數
  let d = a + b + c; // 區域變數
  return d;
}
sum(2, 3);
console.log(a); // 23
console.log(sum(2, 3));
```

---

```cs
23
28
```

# 回呼函式

- 回呼函式([CallBack Function](https://ithelp.ithome.com.tw/articles/10209211))

- 將 function 當成參數代入另一個 function 的例子:

  Callback 函式,亦稱回呼函式,是「在一支函式執行完後,才要執行的函式」

```js
document.addEventListener('click', function () {
  console.log('Mouse Click!');
});
```

# window 物件

- 全域物件，窗口關閉才會消失

```js
let a = 10;
console.log(window.a); // undefined
var b = 10;
console.log(window.b); // 10
```

```js
function sum() {
  return 2 + 3;
}
let sums = () => {
  return 2 + 3;
};
console.log(window.sum()); // 5
console.log(window.sums()); // window.sums is not a function
```

# 常用視窗屬性

- alert(`文字`) 彈訊息框
- confirm(`文字`) 彈對話框
- prompt(`文字`, `預設值`) 彈輸入框
- open(URL, `視窗名稱`) 開新視窗，回傳一個 window
  - close() 關窗口
  - focus() 母窗到子窗
  - blur() 去除焦點

# 計時器

- setInterval(`指定程式`, `間格時間`)

  - `週期性執行`

- clearInterval(`計時器變數`)

  - `關閉 setInterval`

- setTimeout(`指定格式`, `間隔時間`)

  - `經過一段時間後執行一次`

- clearTimeout(`計時器變數`)

  - `取消 setTimeout`

# 取得 Dom 元素的六種方法

- document.getElementById(idName)
- document.getElementsByClassName(className)
- document.getElementsByTagName(tagName) 用標籤名稱
- document.getElementsByName(tagName) 用標籤
- document.querySelector(css 選擇器) 找到第一個
- document.querySelectorAll(css 選擇器) 找到全部<sup><bikao>★ css 熟直接用這個</bikao></sup>

# 事件驅動程式設計

- js 是一種事件驅動

- 事件(Event)
- 事件處理器(Event Handler)

# 為什麼 js 是一種事件驅動的程式?為什麼 js 要事件?

- js 最初發明餘用戶端環境(client-side)
- 因為要`及時處理使用者的互動行為`
- 並且,Javascript 是單執行緒。所以,也無法使用多個 while loop 來模擬
  event 的行為。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <p><button id="myButton" onclick="myHandler('me')">Click Me!</button></p>
    <p>
      <button id="myButton2">
        Click Meeeeeee!
      </button>
    </p>
    <p>
      <button id="myButton3">
        Click Meeeeeeeeeeeeeeee!
      </button>
    </p>
    <script>
      // 方法1: 不建議，與HTML耦合
      function myHandler(say) {
        alert(say);
      }
      // 方法2
      let btn = document.getElementById('myButton2');
      btn.onclick = () => {
        alert('me too');
      };
      // 方法3: 推薦，不用記很多 addEventListener(事件名稱, 事件處裡函式)
      let btn2 = document.getElementById('myButton3');
      btn2.addEventListener('click', () => {
        alert('me tooooooooooooooooo');
      });
    </script>
  </body>
</html>
```
