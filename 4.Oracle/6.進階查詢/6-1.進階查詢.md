# JOIN 概論

- `INNER JOIN` 顯示雙方表格都有的

  - `FROM 左表格 JOIN 右表格 ON 共同欄位`

    - BOOK B 表示定義 BOOK 表格的別名為 B，這樣以就不用用別名

  - 兩個表格的資料都要有

```sql
-- INNER JOIN
-- 2個表格都有相同的PUBLISHER_ID才會呈現該筆資料
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `LEFT JOIN` 只`顯示左表有的值`，右表無此值會顯示 `NULL`

  - `FROM 左表格 LEFT JOIN 右表格 ON 共同欄位`

  - 左表格資料當重點

```sql
-- LEFT JOIN
-- 只顯示左邊表格有的值，右邊表格無此值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
LEFT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `RIGHT JOIN` 只`顯示右表有的值`，左表無此值會顯示 `NULL`

  - 右表格當重點

```sql
-- RIGHT JOIN
-- 只顯示右邊表格有的值，左邊表格無此值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
RIGHT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `FULL JOIN` 顯示雙方表格都有的值，無此值會顯示 `NULL`

  - 兩個表格的資料都有

```sql
-- FULL OUTER JOIN
-- 顯示雙方表格都有的值，無值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
FULL JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `JOIN 自己`

```sql
-- SELF JOIN
-- MANAGER_ID與EMPLOYEE_ID有相同意義

-- 步驟1: 創建表格並添加表格資料
CREATE TABLE EMPLOYEE (
	EMPLOYEE_ID INT PRIMARY KEY NOT NULL,
	NAME VARCHAR(40),
	MANAGER_ID INT,
	FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEE (EMPLOYEE_ID)
);

INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (1, 'Mary', NULL);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (2, 'John', 1);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (3, 'Ben', 1);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (4, 'Joe', 2);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (5, 'James', 2);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (6, 'Betty', 3);

-- 步驟2:  員工資料對應自己，這樣能查到員工，與員工對應的老闆(因為老闆也是公司的員工)
SELECT E.EMPLOYEE_ID, E.NAME, E.MANAGER_ID, M.NAME AS MANAGER_NAME
FROM EMPLOYEE E
LEFT JOIN EMPLOYEE M ON E.MANAGER_ID = M.EMPLOYEE_ID
ORDER BY EMPLOYEE_ID;
```

# JOIN 練習

- `INNER JOIN` 下列表格
  `ORDER_MASTER`, `CUSTOMER`, `ORDER_DETAIL`, `BOOK`
  顯示 `ORDER_ID`, `CUSTOMER_NAME`, `ORDER_DATE`,
  `BOOK_NAME`, `PRICE`, `QUANTITY` 欄位
  依照 `ORDER_ID` 排序

```sql
-- INNER JOIN下列表格
-- ORDER_MASTER, CUSTOMER, ORDER_DETAIL, BOOK
-- 顯示 ORDER_ID, CUSTOMER_NAME, ORDER_DATE,
-- BOOK_NAME, PRICE, QUANTITY 欄位
-- 依照ORDER_ID排序

-- 因為 ORDER_ID 在多張表都有出現，所以 ORACLE 規定需要
SELECT
  od.ORDER_ID, CUSTOMER_NAME, ORDER_DATE, BOOK_NAME, PRICE, QUANTITY
FROM
  ORDER_MASTER om inner join
  ORDER_DETAIL od ON om.ORDER_ID = od.ORDER_ID inner join
  CUSTOMER cu ON om.customer_id = cu.customer_id inner join
  BOOK b ON b.isbn = od.isbn
Order by PRICE;
```

- `ORA-00918: column ambiguously defined`

  - [select 查询的字段在 from 的两张表中都存在，导致数据库无法区别需要查询的字段来自于哪张表](https://blog.csdn.net/sinat_29774479/article/details/77987815)

# GROUP BY

- 沒有放在聚集函式中的欄位，一定要放在 GROUP BY 否則會報錯

```sql
SELECT 出版社名稱, COUNT(書本) AS 刊登的書本數量
FROM 書本表
GROUP BY 出版社名稱
ORDER BY 出版社名稱 DESC;
```

- 表格要顯示`出版社名稱`與`該出版社有的書本`並且排序方式需要使用`出版社名稱`做排序

| 出版社名稱 | 刊登的書本數量 |
| :--------: | :------------: |
|    手民    |       4        |
|    白卷    |       2        |
|    教育    |       8        |
|    辛裡    |       2        |

```sql
-- GROUP BY
-- 列出每個出版社出版了幾本書
SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT
FROM BOOK
GROUP BY PUBLISHER_ID
ORDER BY BOOK_COUNT DESC;
```

# GROUP BY HAVING

- `WHERE` 針對`未分組的原始資料`做查詢

- `HAVING` `不能使用別名`，因為在 ORACLE 當中執行到 HAVING 時 BOOK_COUNT `名稱還未生成`，所以不能使用

```sql
-- GROUP BY
-- 列出每個出版社出版了幾本書
SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT

FROM BOOK
-- WHERE 原始資料(WHERE 針對未分組的原始資料做查詢)
WHERE PRICE < 1000
-- 依照 PUBLISHER_ID 分組
GROUP BY PUBLISHER_ID
-- 新增計算後的書本數量需大於等於2
-- HAVING 不能使用 BOOK_COUNT 這個名稱，因為在ORACLE當中執行到 HAVING 時 BOOK_COUNT 名稱還未生成，所以不能使用
HAVING COUNT(BOOK_NAME)>= 2
-- 需要使用 BOOK_COUNT 做排序
ORDER BY BOOK_COUNT DESC;
```

- `別名尚未產生`的第二個範例

```sql
-- 列出平均書價超過1000元的出版社
-- HAVING不能使用AVERAGE_PRICE別名是因為GROUP BY時別名尚未產生
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME
HAVING AVG(PRICE) > 1000;
```

- 每多加一個`欄位`，就等於多了個`次分組`

```sql
-- SELECT列出來的欄位，除了聚集函數的欄位外，其餘都要列在GROUP BY條件中，否則會不符合閱讀邏輯
SELECT PUBLISHER_ID, AUTHOR, COUNT(BOOK_NAME) AS BOOK_COUNT
FROM BOOK
GROUP BY PUBLISHER_ID, AUTHOR
ORDER BY BOOK_COUNT DESC;
```

- GROUP BY 中有值但 SELECT 沒有值，這樣不會出錯但是不是個好方法，容易造成資訊混淆

  - `最好不要偷偷在 GROUP BY 中分組`，但不給人看，否則容易在顯示的有相同資料時以為錯了

```sql
-- 列出每個出版社的平均書價，顯示欄位包含出版社名稱與平均書價
-- 若不將出版社ID列在GROUP BY，當出版社名稱相同時，會將不同出版社ID但相同出版社名稱的資料合併
SELECT PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME;
```

- 沒有用 `SUM`|`AVG`|`COUNT`|`MAX`|`MIN` 的欄位才`一定要`放在 `GROUP BY` 中分組

```sql
-- 列出每個出版社最貴/最便宜的書價
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE), MIN(PRICE)
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME;
```

- 特別的是在 ORDER BY 中`使用別名不會有錯`
- 而且也能用 `SUM`|`AVG`|`COUNT` ... 排序

```sql
-- 列出每個出版社最貴的書價，並降冪排序
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE) AS MAX_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME
ORDER BY MAX_PRICE DESC;
```

# 為什麼要 JOIN (合併)

- 因為列出來的欄位數超過單一表格，所以要 join

- 因為要列出很多不同的表格欄位，所以要把表格都連在一起

- 要列出比較完整的資訊

- 想要的資料只用一個表無法滿足需求

# 為什麼要 GROUP BY

- 因為要分組統計

# GROUP BY 與 JOIN 練習

- 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序

```sql
-- 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序
SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID, SUM(QUANTITY) AS SUM_QUANTITY
FROM CUSTOMER C
JOIN ORDER_MASTER OM ON C.CUSTOMER_ID = OM.CUSTOMER_ID
JOIN ORDER_DETAIL OD ON OM.ORDER_ID = OD.ORDER_ID
GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID
ORDER BY SUM(QUANTITY);
```

- 列出每家出版社出版書籍的訂購總量在 3 以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序

```sql
-- 列出每家出版社出版書籍的訂購總量在3以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序
select p.PUBLISHER_ID 出版社編號,p.PUBLISHER_NAME 出版社名稱, sum(QUANTITY) 訂購總量
FROM publisher p
join book b on b.publisher_id = p.publisher_id
join order_detail od on od.isbn = b.isbn
group by p.PUBLISHER_ID, p.PUBLISHER_NAME
order by PUBLISHER_NAME;
```

- 統計 2016~2017 年間每月出版的書籍數量，並依照日期排序

```sql
-- 統計2016~2017年間每月出版的書籍數量，並依照日期排序
ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm';

SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT('ISBN') AS TOTAL
FROM BOOK
WHERE PUBLICATION_DATE BETWEEN '2016-01' AND '2017-12'
GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm')
ORDER BY to_char(PUBLICATION_DATE, 'yyyy-mm') ;
```

---

```sql
SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT(1) AS TOTAL
FROM BOOK
WHERE to_char(PUBLICATION_DATE, 'yyyy-mm') BETWEEN '2016-01' AND '2017-12'
GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm')
ORDER BY PUB_MONTH;
```
