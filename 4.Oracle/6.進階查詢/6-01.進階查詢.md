# JOIN 概論

- `INNER JOIN` 顯示雙方表格都有的

  - `FROM 左表格 JOIN 右表格 ON 共同欄位`

    - BOOK B 表示定義 BOOK 表格的別名為 B，這樣以就不用用別名

  - 兩個表格的資料都要有

```sql
-- INNER JOIN
-- 2個表格都有相同的PUBLISHER_ID才會呈現該筆資料
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `LEFT JOIN` 只`顯示左表有的值`，右表無此值會顯示 `NULL`

  - `FROM 左表格 LEFT JOIN 右表格 ON 共同欄位`

  - 左表格資料當重點

```sql
-- LEFT JOIN
-- 只顯示左邊表格有的值，右邊表格無此值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
LEFT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `RIGHT JOIN` 只`顯示右表有的值`，左表無此值會顯示 `NULL`

  - 右表格當重點

```sql
-- RIGHT JOIN
-- 只顯示右邊表格有的值，左邊表格無此值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
RIGHT JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `FULL JOIN` 顯示雙方表格都有的值，無此值會顯示 `NULL`

  - 兩個表格的資料都有

```sql
-- FULL OUTER JOIN
-- 顯示雙方表格都有的值，無值者會顯示NULL
SELECT BOOK_NAME, PRICE, AUTHOR, B.PUBLISHER_ID, P.PUBLISHER_ID, PUBLISHER_NAME
FROM BOOK B
FULL JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID;
```

- `JOIN 自己`

```sql
-- SELF JOIN
-- MANAGER_ID與EMPLOYEE_ID有相同意義

-- 步驟1: 創建表格並添加表格資料
CREATE TABLE EMPLOYEE (
	EMPLOYEE_ID INT PRIMARY KEY NOT NULL,
	NAME VARCHAR(40),
	MANAGER_ID INT,
	FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEE (EMPLOYEE_ID)
);

INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (1, 'Mary', NULL);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (2, 'John', 1);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (3, 'Ben', 1);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (4, 'Joe', 2);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (5, 'James', 2);
INSERT INTO EMPLOYEE (EMPLOYEE_ID, NAME, MANAGER_ID)
VALUES (6, 'Betty', 3);

-- 步驟2:  員工資料對應自己，這樣能查到員工，與員工對應的老闆(因為老闆也是公司的員工)
SELECT E.EMPLOYEE_ID, E.NAME, E.MANAGER_ID, M.NAME AS MANAGER_NAME
FROM EMPLOYEE E
LEFT JOIN EMPLOYEE M ON E.MANAGER_ID = M.EMPLOYEE_ID
ORDER BY EMPLOYEE_ID;
```

# JOIN 練習

- `INNER JOIN` 下列表格
  `ORDER_MASTER`, `CUSTOMER`, `ORDER_DETAIL`, `BOOK`
  顯示 `ORDER_ID`, `CUSTOMER_NAME`, `ORDER_DATE`,
  `BOOK_NAME`, `PRICE`, `QUANTITY` 欄位
  依照 `ORDER_ID` 排序

```sql
-- INNER JOIN下列表格
-- ORDER_MASTER, CUSTOMER, ORDER_DETAIL, BOOK
-- 顯示 ORDER_ID, CUSTOMER_NAME, ORDER_DATE,
-- BOOK_NAME, PRICE, QUANTITY 欄位
-- 依照ORDER_ID排序

-- 因為 ORDER_ID 在多張表都有出現，所以 ORACLE 規定需要
SELECT
  od.ORDER_ID, CUSTOMER_NAME, ORDER_DATE, BOOK_NAME, PRICE, QUANTITY
FROM
  ORDER_MASTER om inner join
  ORDER_DETAIL od ON om.ORDER_ID = od.ORDER_ID inner join
  CUSTOMER cu ON om.customer_id = cu.customer_id inner join
  BOOK b ON b.isbn = od.isbn
Order by PRICE;
```

- `ORA-00918: column ambiguously defined`

  - [select 查询的字段在 from 的两张表中都存在，导致数据库无法区别需要查询的字段来自于哪张表](https://blog.csdn.net/sinat_29774479/article/details/77987815)

# GROUP BY 函式

- 沒有放在聚集函式中的欄位，一定要放在 GROUP BY 否則會報錯

```sql
SELECT 出版社名稱, COUNT(書本) AS 刊登的書本數量
FROM 書本表
GROUP BY 出版社名稱
ORDER BY 出版社名稱 DESC;
```

- 表格要顯示`出版社名稱`與`該出版社有的書本`並且排序方式需要使用`出版社名稱`做排序

| 出版社名稱 | 刊登的書本數量 |
| :--------: | :------------: |
|    手民    |       4        |
|    白卷    |       2        |
|    教育    |       8        |
|    辛裡    |       2        |

```sql
-- GROUP BY
-- 列出每個出版社出版了幾本書
SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT
FROM BOOK
GROUP BY PUBLISHER_ID
ORDER BY BOOK_COUNT DESC;
```

# GROUP BY 與 HAVING

- `WHERE` 針對`未分組的原始資料`做查詢

- `HAVING` `不能使用別名`，因為在 ORACLE 當中執行到 HAVING 時 BOOK_COUNT `名稱還未生成`，所以不能使用

```sql
-- GROUP BY
-- 列出每個出版社出版了幾本書
SELECT PUBLISHER_ID, COUNT(BOOK_NAME) AS BOOK_COUNT

FROM BOOK
-- WHERE 原始資料(WHERE 針對未分組的原始資料做查詢)
WHERE PRICE < 1000
-- 依照 PUBLISHER_ID 分組
GROUP BY PUBLISHER_ID
-- 新增計算後的書本數量需大於等於2
-- HAVING 不能使用 BOOK_COUNT 這個名稱，因為在ORACLE當中執行到 HAVING 時 BOOK_COUNT 名稱還未生成，所以不能使用
HAVING COUNT(BOOK_NAME)>= 2
-- 需要使用 BOOK_COUNT 做排序
ORDER BY BOOK_COUNT DESC;
```

- `別名尚未產生`的第二個範例

```sql
-- 列出平均書價超過1000元的出版社
-- HAVING不能使用AVERAGE_PRICE別名是因為GROUP BY時別名尚未產生
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME
HAVING AVG(PRICE) > 1000;
```

- 每多加一個`欄位`，就等於多了個`次分組`

```sql
-- SELECT列出來的欄位，除了聚集函數的欄位外，其餘都要列在GROUP BY條件中，否則會不符合閱讀邏輯
SELECT PUBLISHER_ID, AUTHOR, COUNT(BOOK_NAME) AS BOOK_COUNT
FROM BOOK
GROUP BY PUBLISHER_ID, AUTHOR
ORDER BY BOOK_COUNT DESC;
```

- GROUP BY 中有值但 SELECT 沒有值，這樣不會出錯但是不是個好方法，容易造成資訊混淆

  - `最好不要偷偷在 GROUP BY 中分組`，但不給人看，否則容易在顯示的有相同資料時以為錯了

```sql
-- 列出每個出版社的平均書價，顯示欄位包含出版社名稱與平均書價
-- 若不將出版社ID列在GROUP BY，當出版社名稱相同時，會將不同出版社ID但相同出版社名稱的資料合併
SELECT PUBLISHER_NAME, AVG(PRICE) AS AVERAGE_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME;
```

- 沒有用 `SUM`|`AVG`|`COUNT`|`MAX`|`MIN` 的欄位才`一定要`放在 `GROUP BY` 中分組

```sql
-- 列出每個出版社最貴/最便宜的書價
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE), MIN(PRICE)
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME;
```

- 特別的是在 ORDER BY 中`使用別名不會有錯`
- 而且也能用 `SUM`|`AVG`|`COUNT` ... 排序

```sql
-- 列出每個出版社最貴的書價，並降冪排序
SELECT B.PUBLISHER_ID, PUBLISHER_NAME, MAX(PRICE) AS MAX_PRICE
FROM BOOK B
JOIN PUBLISHER P ON B.PUBLISHER_ID = P.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME
ORDER BY MAX_PRICE DESC;
```

# 為什麼要 JOIN (合併)

- 因為列出來的欄位數超過單一表格，所以要 join

- 因為要列出很多不同的表格欄位，所以要把表格都連在一起

- 要列出比較完整的資訊

- 想要的資料只用一個表無法滿足需求

# 為什麼要 GROUP BY

- 因為要分組統計

# GROUP BY 與 JOIN 練習

- 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序

```sql
-- 計算每客戶在每張訂單的訂購種類，列出客戶編號、名稱、訂單編號、訂購總量，並照客戶名稱排序
SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID, SUM(QUANTITY) AS SUM_QUANTITY
FROM CUSTOMER C
JOIN ORDER_MASTER OM ON C.CUSTOMER_ID = OM.CUSTOMER_ID
JOIN ORDER_DETAIL OD ON OM.ORDER_ID = OD.ORDER_ID
GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME, OM.ORDER_ID
ORDER BY SUM(QUANTITY);
```

- 列出每家出版社出版書籍的訂購總量在 3 以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序

```sql
-- 列出每家出版社出版書籍的訂購總量在3以上的出版社編號、出版社名稱、訂購總量，並依照出版社名稱排序
select p.PUBLISHER_ID 出版社編號,p.PUBLISHER_NAME 出版社名稱, sum(QUANTITY) 訂購總量
FROM publisher p
join book b on b.publisher_id = p.publisher_id
join order_detail od on od.isbn = b.isbn
group by p.PUBLISHER_ID, p.PUBLISHER_NAME
order by PUBLISHER_NAME;
```

- 統計 2016~2017 年間每月出版的書籍數量，並依照日期排序

```sql
-- 統計2016~2017年間每月出版的書籍數量，並依照日期排序
ALTER SESSION SET NLS_DATE_FORMAT = 'yyyy-mm';

SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT('ISBN') AS TOTAL
FROM BOOK
WHERE PUBLICATION_DATE BETWEEN '2016-01' AND '2017-12'
GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm')
ORDER BY to_char(PUBLICATION_DATE, 'yyyy-mm') ;
```

---

```sql
SELECT to_char(PUBLICATION_DATE, 'yyyy-mm') AS PUB_MONTH, COUNT(1) AS TOTAL
FROM BOOK
WHERE to_char(PUBLICATION_DATE, 'yyyy-mm') BETWEEN '2016-01' AND '2017-12'
GROUP BY to_char(PUBLICATION_DATE, 'yyyy-mm')
ORDER BY PUB_MONTH;
```

# 子查詢

- 主要 SELECT 語句可以加上次要 SELECT 子句,也就是子查詢 (subquery)

  - 子查詢需要放在小括弧內
  - 提供主要 SELECT 語句的資料來源或是條件判斷的依據
  - 在運算式內或是比較運算符號之後的子查詢,回傳的值只能 1 個

```sql
-- 將小於等於平均書價的書列出
SELECT * FROM BOOK
WHERE PRICE <= (SELECT AVG(PRICE) FROM BOOK)
ORDER BY ISBN;
```

- `DUAL` 是 Oracle 專用字，用於`直接執行子查詢的判斷`

```sql
-- 書價1000元以上的書籍數量佔總書籍數量多少百分比
-- DUAL表格是一個虛擬表格，裡面只有一筆資料，用於只對查詢結果感興趣時使用，例如：SELECT SYSDATE FROM DUAL;
SELECT
(SELECT COUNT(ISBN) * 100 FROM BOOK WHERE PRICE >= 1000) /
(SELECT COUNT(ISBN) FROM BOOK) AS PERCENT_PRICE_GT_1000
FROM DUAL;
```

# 子查詢 練習

- 計算各個客戶訂購總量佔所有訂單總訂購量的百分比,列出客戶名與所佔總訂購量的百分比

```sql
select
c.customer_id, c.customer_name,
sum(od.quantity)/(select sum(od.quantity) FROM order_detail od) * 100 as PERCENT_SALES
from customer c
join order_master om on om.customer_id = c.customer_id
join order_detail od on od.order_id = om.order_id
GROUP BY c.customer_id, c.customer_name;
```

- 列出大於訂單平均訂購量的訂單編號與訂購量

```sql
-- HAVING 用來做詳細判斷，像是這題需要跟子查詢的結果作比較，就要使用 HAVING
-- 簡單的判斷使用 WHERE 就好， WHERE 跟 HAVING 則一
SELECT od.order_id, sum(od.quantity)
FROM order_detail od
GROUP BY od.order_id
HAVING sum(od.quantity) > ((SELECT sum(quantity) FROM order_detail)/(SELECT count(order_id) FROM order_master))
order by od.order_id;
```

- 列出大於訂單平均訂購量的訂單編號與訂購量(`更簡單的寫法`)

  - Oracle 支持子查詢中使用 order by

```sql
SELECT od.order_id, sum(od.quantity)
FROM order_detail od
GROUP BY od.order_id
HAVING sum(od.quantity) > (SELECT AVG(sum(quantity)) FROM order_detail GROUP BY order_id)
order by od.order_id;
```

# ROWNUM 函式

- ROWNUM 是 Oracle 特有功能,屬於 pseudo column (虛擬欄位),用於儲存查詢結果的列號

  - ROWNUM 從 1 開始,所以「ROWNUM = 2」或「ROWNUM > 1」都為 false,會查無資料,除非用子查詢
  - 也可將 ROWNUM 欄位一併顯示

```sql
SELECT column_name(s)
FROM table_name
WHERE ROWNUM <= number;
```

- 可用於取得各分頁資料,例如取得第一頁 (1 ~ 5)、第二頁 (6 ~ 10)

  - 搭配子查詢,主查詢要使用子查詢 ROWNUM 欄位,需給予別名,避免分不清是主查詢還是子查詢的 ROWNUM

- `可取得排序後前幾筆資料`

  - `搭配子查詢與 ORDER BY`

- ROWNUM 可以當成`序號產生機`

# ROWNUM 範例

- ROWNUM 的簡易使用

```sql
-- 列出前5筆
SELECT * FROM BOOK WHERE ROWNUM <= 5;
```

- ROWNUM 容易出現的誤區

```sql
-- ROWNUM從1開始，「ROWNUM = 2」或「ROWNUM > 1」都為false，會查無資料
-- 從第一個欄位的第一個字元開始抓，所以不可以設定條件為 " = " 或 " > "
-- 值沒到，ROWNUM 號碼就不會出現
SELECT * FROM BOOK WHERE ROWNUM = 2;
SELECT * FROM BOOK WHERE ROWNUM > 1;
```

- 顯示 ROWNUM 並設定範圍

```sql
-- 將ROWNUM欄位一併顯示
SELECT ROWNUM, ISBN, BOOK_NAME, PRICE FROM BOOK
WHERE ROWNUM <= 5;
```

- `分頁器`<sup><bikao>★ 常用 </bikao></sup>會使用到

- 瀏覽器有 timeout 時間，資料讀取過久會取消連線

```sql
-- 主查詢要使用子查詢ROWNUM欄位，需給予別名，避免分不清是主查詢還是子查詢的ROWNUM
SELECT * FROM (SELECT ROWNUM AS ROW_NO, ISBN, BOOK_NAME, PRICE FROM BOOK)
WHERE ROW_NO BETWEEN 5 AND 10;
```

- `推薦商品`<sup><bikao>★</bikao></sup>會用到

```sql
-- 將出版日期最新的3本書列出
SELECT BOOK_NAME, PUBLICATION_DATE FROM
(SELECT BOOK_NAME, PUBLICATION_DATE FROM BOOK ORDER BY PUBLICATION_DATE DESC)
WHERE ROWNUM <= 3;
```

- 只使用 ROWNUM 容易缺資料

```sql
-- 將最便宜兩本書列出，但若要並列相同價格書就要改用RANK()
SELECT * FROM
(SELECT ISBN, BOOK_NAME, PRICE
FROM BOOK
ORDER BY PRICE)
WHERE ROWNUM <=2;
```

- RANK() 函式命名後將變真實的值

```sql
-- 使用RANK()可以並列相同價格書
SELECT * FROM
(SELECT BOOK_NAME, PRICE, RANK() OVER(ORDER BY PRICE) PRICE_RANK FROM BOOK)
WHERE PRICE_RANK <= 2;
```

- 更複雜的判斷

```sql
-- 將出書量最大的3家出版社列出
SELECT PUBLISHER_NAME, COUNT_BOOK FROM
(SELECT B.PUBLISHER_ID, PUBLISHER_NAME, COUNT(ISBN) AS COUNT_BOOK
FROM PUBLISHER P
JOIN BOOK B ON P.PUBLISHER_ID = B.PUBLISHER_ID
GROUP BY B.PUBLISHER_ID, PUBLISHER_NAME
ORDER BY COUNT_BOOK DESC)
WHERE ROWNUM <= 3;
```

# IN, ANY, ALL 差別

- IN:用來判斷指定的值是否在子查詢中,子查詢的欄位只能有 1 個

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT statement);
```

- ANY/ALL:用來判斷指定的值是否在子查詢中,ANY 類似 OR;ALL 類似 AND

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY|ALL (SELECT statement);
```

- EXISTS:檢查資料是否存在於子查詢中,如果有回傳 true,否則 false,與上述 IN
  做值的比對不同,所以子查詢欄位使用一般常數即可

```sql
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT 1 FROM table_name WHERE condition);
```

- IN, ANY, ALL 差別

  - IN: 單純比較是否與子查詢結果值相同,所以無法使用<>, <, >, <=, >=
  - ANY: 除了值是否相同外,還可以跟子查詢結果的任一個值比大小,屬於 OR 觀念

  - ALL: 跟子查詢結果的每一個值比大小,屬於 AND 觀念

- EXISTS 與 IN 差別

  - EXISTS 判斷主查詢的欄位是否存在於子查詢,而回傳 true 或 false 以決定是否要剔除該筆資料,該欄位大都是 PK,會以索引比對,所以速度較快

- 範例: IN, ANY, ALL, EXISTS

- `IN` 最 `常用`

```cs
/* IN, ANY, ALL差別
IN: 單純比較是否與子查詢結果值相同，所以無法使用<>, <, >, <=, >=
ANY: 除了值是否相同外，還可以跟子查詢結果的任一個值比大小，屬於OR觀念
ALL: 跟子查詢結果的每一個值比大小，屬於AND觀念
*/
```

- 用這種方法，同樣價格的書也可以選中

```sql
-- IN 列出與Java書價相同的書
SELECT * FROM BOOK
WHERE PRICE IN
(SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%');
```

- 列出高於任一本 Java 書價的書

```sql
-- ANY 列出高於任一本Java書價的書
SELECT * FROM BOOK
WHERE PRICE >= ANY
(SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%');
```

- 列出高於所有 Java 書價的書

```sql
-- ALL: 列出高於所有Java書價的書
SELECT * FROM BOOK
WHERE PRICE > ALL
(SELECT PRICE FROM BOOK WHERE upper(BOOK_NAME) LIKE '%JAVA%');
```

# EXISTS 查詢

```cs
/*
1. EXISTS與IN執行效能比較
EXISTS判斷主查詢的欄位是否存在於子查詢，而回傳true或false以決定是否要剔除該筆資料，
該欄位大都是PK，會以索引比對，所以速度快。
IN則會以主/子查詢欄位內儲存的值詳細比對是否值相同而決定是否要剔除該筆資料，
所以一般而言只要資料庫沒有將IN語句優化，IN的執行效能會比較差。

2. EXISTS子查詢使用欄位名稱與定值 (例如數字1)的差異：
使用欄位名稱或定值不會影響EXISTS比對速度，因為如上述是以索引判斷，
但如果使用「*」或是多個欄位，會影響存入記憶體的速度，而且也較佔用記憶體空間。
*/
```

- EXISTS 有點類似 JOIN

  - 會給每個值編號，所以在搜尋時資料量大會搜尋更快
  - 資料少的時候使用 IN 會更快一些

```sql
-- 列出出版Java書的出版社

-- 使用 IN
SELECT PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P
WHERE PUBLISHER_ID IN
(SELECT PUBLISHER_ID FROM BOOK B
WHERE upper(BOOK_NAME) LIKE '%JAVA%');

-- 使用 EXISTS (因為這個子搜尋，欄位不是搜尋用依據，故 SELECT 1 或 SELECT 一個欄位都會更好，不要搜尋所有欄位)
SELECT PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P
WHERE EXISTS
(SELECT 1 FROM BOOK B
WHERE P.PUBLISHER_ID = B.PUBLISHER_ID AND upper(BOOK_NAME) LIKE '%JAVA%');

-- 使用 JOIN
SELECT P.PUBLISHER_ID, PUBLISHER_NAME FROM PUBLISHER P
JOIN BOOK B ON P.PUBLISHER_ID = B.PUBLISHER_ID AND upper(BOOK_NAME) LIKE '%JAVA%';
```

- 循序搜尋 第一間房間敲到最後一間房間找人

  - IN 方法

  - `剔除不對的房間`

- 雜湊搜尋 房間只剩下 7 間住房間時讓 8 個，用同學座號%7(mod)最後住一間

  - EXISTS 方法
  - 編號怎麼編，號碼就要怎麼找(用空間換時間)
  - 將要找的值濃縮成一個整數
  - `只找對的` 直接找對的房間

# EXISTS 練習

```sql
-- 使用EXISTS列出所有台北客戶的總訂購量
---- EXISTS 好處是不需再作關聯即可跟主表的東西做比較，但兩張表一定要有相關聯的數據
---- 而且也因是使用雜湊方式搜尋故數據量大時搜尋速度會更快
---- 在此表當中因為order_detail要與customer沒有相關聯的數據，故要再多關聯一張order_master表
---- 因為有關聯了order_master故也有它的數據，因此才能將"台北客戶"跟"訂購量"一起判斷
SELECT sum(QUANTITY) 台北客戶總訂購量
FROM order_detail od
JOIN order_master om ON om.order_id = od.order_id
WHERE EXISTS
(SELECT 1 FROM customer c
WHERE c.customer_id = om.customer_id AND upper(c.address) LIKE '%TAIPEI%');

-- 列出不在訂單上的所有書名 (使用EXISTS)
SELECT BOOK_NAME 書名
FROM book b
WHERE NOT EXISTS
(SELECT 1 FROM order_detail od WHERE od.isbn = b.isbn);
```

# UNION

- JOIN 將不同欄位做水平合併,會增加欄位;UNION 將不同欄位做垂直合併,不會增加欄位,但會增加資料筆數

```sql
SELECT column_name(s) FROM table1
UNION (ALL)
SELECT column_name(s) FROM table2;
```

- UNION 合併資料必須注意
  - 要合併的 2 個 SELECT 子句,其欄位數要相同
  - 要合併的 2 個 SELECT 子句,資料類型要相容
  - 合併後會以第一個 SELECT 子句的欄位名稱為主
  - GROUP BY 和 HAVING 子句可用於 SELECT 子句中,但不可用於 UNION 之後的結果
  - ORDER BY 只能用於 UNION 之後的結果,不可用於 SELECT 子句中
  - UNION 後若有重複的結果,只會顯示一筆;加上 ALL 參數,則會全部顯示出來
