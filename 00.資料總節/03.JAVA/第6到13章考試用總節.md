<h1 id="top">目錄</h1>

- [1. static](#s1)
- [2. final](#s2)
- [3. 陣列 Array](#s3)
- [4. 字串 String](#s4)
- [5. 方法 與 建構子](#s5)
- [6. 方法覆載 Overloading](#s6)
- [7. 變數 virable](#s7)
- [8. 物件 Object](#s8)
- [9. 封裝](#s9)
- [10. 繼承 extends](#s10)
- [11. 多型 Polymorphism](#s11)
- [12. 泡沫排序法](#s12)
- [13. 抽象(abstract)與介面(interface...implements)](#s13)
- [14. 不固定參數個數](#s14)

---

# <a id='s1' class='md-title' href='#top'>1. static</a>

- 使用 static 宣告的東西會 `先執行`

- static{} `static 區塊中的東西會載入類別就執行`

- static 方法 `不能用 this`

- static 方法 `不能被覆寫為非 static`

- 使用 `類別.變數` 或 `類別.方法` 方式使用和修改

- static 變數可以在 non-static 位置用

```java
public class TestInterface extends TestAbstracts {
  // 步驟3 => num = 12
  void methods() {
    TestInterface.num = 12;
  }

  static int num = 10; // 步驟1 => num = 10

  public static void main(String args[]) {

    TestInterface ti = new TestInterface();
    TestInterface.num = 11;
    ti.methods(); // 步驟2 => 呼叫方法

    System.out.println(TestInterface.num); // 步驟4 => 顯示 num = 12 的結果
  }
}
```

# <a id='s2' class='md-title' href='#top'>2. final</a>

- `不能繼承`

- `不能修改`

- `不能指向`

- 簡單來說變成一個類似於常數的東西

# <a id='s3' class='md-title' href='#top'>3. 陣列 Array</a>

- int[] intArray = new int[10]; `最終一定要 new 並給陣列大小後才能用`

- int[] intArray2 = intArray1; 這樣是 `繼承` `記憶體位置` ，修改 intArray2 就會同時改到 intArray1

- Arrays.sort(arrayName); `由小排到大`

```java
int[] arr = { 1, 3, 5, 2, 9 };
int[] arr2 = Arrays.copyOf(arr, arr.length);
arr2[2] = 135;
System.out.println(Arrays.toString(arr2)); // 1 2 135 5 9
System.out.println(Arrays.toString(arr)); // 1 3 5 2 9
```

- Arrays.binarySearch(ayyarName,searchData); `陣列搜尋` ，`陣列一定要先排序` `沒搜到則回傳負數`

- Arrays.copyOf(arr,arr.length); `複製並回傳新陣列` ，修改時不會改到之前陣列的值，因為是新記憶體位置

```java
int[] arr = {1,3,5,2,9};
int[] arr2 = Arrays.copyOf(arr,arr.length);
System.out.println(Arrays.toString(arr2));
```

- Arrays.toString; `陣列轉字串`

```java
int[] arr = {1,3,5,2,9};
String str = Arrays.toString(arr);
System.out.println(str);
```

# <a id='s4' class='md-title' href='#top'>4. 字串 String</a>

- str.equals(); `比較相等`

- str.length(); `回傳字串長度`

- str.isEmpty(); `檢查是否為空字串`，字傳為 0 回傳 true，則回傳 false

- `"hellowWorld"`.charAt(1); `取得字串` `指定位置` `字元`，顯示 `e`

- `"hellowWorld"`.substring(3); `指定位置到結尾值`，顯示 `lowWorld`

- `"hellowWorld"`.substring(3,5); `指定位置到結尾值前`，顯示 `lo`

- `"hellowWorld"`.compareTo(`"hellowWorld"`); `用字元 ASCII 值比較大小`，可以比較相等 `相等顯示 0`，顯示 > 0 是左大於右，顯示 < 0 是右大於左

# <a id='s5' class='md-title' href='#top'>5. 方法 與 建構子</a>

- 有 void 是 `方法`，沒有的話是 `建構子`

- void 表示*方法沒有回傳值*

- `建構子需跟 className 相同`

# <a id='s6' class='md-title' href='#top'>6. 方法覆載 Overloading</a>

- `不能` 根據 `回傳值` 的 `型態` 不同而區別

- 使用 `參數的數目` 以及 `不同的資料型別` 區分

```java
public class ClassName{

  // Overloading
  void className(){} // method => 名稱可以隨便定義
  void className(String str){}
  void className(String str,int num){}

  // Overloading
  className(){} // 建構子 => 名稱須同class
  className(String str){}
  className(String str,int num){}

}
```

# <a id='s7' class='md-title' href='#top'>7. 變數 virable</a>

- `右邊` 的資料型別不能比 `左邊` 大

```java
int i = 0.5f; // 錯誤，右邊不能大於左邊
```

# <a id='s8' class='md-title' href='#top'>8. 物件 Object</a>

- ClassA a = new Object(); 是錯誤的，原因是因為 `右邊` 的資料型別不能比 `左邊` 大
  - `Object Reference Variables (Reference)` mean `a = new Object()`
  - `Object` 是所有人的爸爸

```java
AddInt[] add2 = new AddInt[1];
add2[0] = new Object(); // 錯誤，右邊不能大於左邊
```

# <a id='s9' class='md-title' href='#top'>9. 封裝</a>

- public ( `所有類別` 皆能存取) >

  - `不包含` `沒有 package` 的

- protected ( `同套件(package)下` 類別或所有其子類別) >

- default ( `同套件下的` 類別) (default 不用特別寫) >

- private (只有 `該類別內` 部)

- 類別能用的只有 public 跟 default

# <a id='s10' class='md-title' href='#top'>10. 繼承 extends</a>

- 繼承後叫爸爸的建構子用 `super()`，因為繼承並不會繼承建構子

- 叫爸爸的方法可以用 `super.方法()`

- `super()` 跟 `this()` 都需要 `放在第一個敘述位置`

- `super()` 跟 `this()` `一個方法內只能用一種`，但 `super()` 跟 `this.參數名稱` 可以同時存在

```java
public class ClassB extends ClassA{...}
```

- 每個類別內可以 `改寫` 自己要用的方法

- 叫自己類別的建構子用 `this()`，叫實體變數則是 `this.實體變數`

```java
class Animal {
  public void animalSound() {
    System.out.println("The animal makes a sound");
  }
}

class Pig extends Animal {
  public void animalSound() {
    System.out.println("The pig says: wee wee");
  }
}

class Dog extends Animal {
  public void animalSound() {
    System.out.println("The dog says: bow wow");
  }
}
```

# <a id='s11' class='md-title' href='#top'>11. 多型 Polymorphism</a>

- 父類別能當子類別的通用型態，子類別要使用時再逐一*實體化*(new)就行

- `instanceof` 用來*判斷真正指向何種子類別的實體*

- `直系繼承` 才能 instanceof 為 true

- `子類別要用自己類別的方法需要降轉型`

- 繼承關係
  - Employee
    - FullTimeEmployee
      - Manager
    - PartTimeEmployee

```java
// e3 的對照看右邊 new 的東西
EmployeePoly e3 = new PartTimeEmployeePoly(7004, "John", 1000.0, 8);

System.out.println(e3 instanceof FullTimeEmployeePoly); // false
System.out.println(e3 instanceof ManagerPoly); // false
System.out.println(e3 instanceof PartTimeEmployeePoly); // true
System.out.println(e3 instanceof EmployeePoly); // true
```

# <a id='s12' class='md-title' href='#top'>12. 泡沫排序法</a>

- 簡單來說就是雙層迴圈，接著每個數相比比較在陣列中的大小，數字比現在的字小就交換。大於就不變，值到陣列所有值排序完畢

# <a id='s13' class='md-title' href='#top'>13. 抽象(abstract)與介面(interface...implements)</a>

- 抽象類別與介面 `一定要實做` `方法`

- 抽象用法 ( 抽象類別 `不能` `實體化` )

```java
public abstract class ClassName{
  public abstract method(){}
}
```

- 介面用法

```java
public interface IWritable {
  void write();
}
```

```java
public class InkBrush2 implements IWritable {
  public void write() {
  }
}
```

- 物件複製 需使用 `Cloneable` 介面

```java
// 步驟1: 使用 Cloneable 介面
public class CloneClass implements Cloneable {
  public int aInt;

  public Object clone() {
    // 步驟2: 宣告類別物件
    CloneClass o = null;
    try {
      // 步驟3: 複製建構子
      o = (CloneClass) super.clone();
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
    return o;
  }
}
```

# <a id='s14' class='md-title' href='#top'>14. 不固定參數個數</a>

- `須放在最後`，`一個方法` `只能` `有一個`

```java
public int varArgsTest(int... c){
  int sum = 0;

  for(int i = 0; i < c.length ; i++){
    sum += c[i];
  }

  return sum;
}
```
