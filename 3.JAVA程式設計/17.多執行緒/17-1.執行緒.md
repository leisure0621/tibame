<h1 id="top">目錄</h1>

- [1. 執行緒](#s1)
- [2. Thread 類別](#s2)
- [3. Runnable 介面](#s3)
- [4. 執行緒生命週期](#s4)
- [5. 執行緒常用方法](#s5)
- [6. 執行續的特性](#s6)
- [7. 控制執行續與優先安排](#s7)
- [8. 執行續總結](#s8)
- [9. 同步 (Synchronization) (1/2)](#s9)
- [10. 資源鎖定的理解](#s10)
- [11. 同步 (Synchronization) 總結](#s11)
- [12. 執行緒間通訊](#s12)
- [13. 死結 (DeadLock)](#s13)
- [14. Daemon 執行緒](#s14)
- [15. 執行續留意總結](#s15)

---

# <a id='s1' class='md-title' href='#top'>1. 執行緒</a>

- 什麼是執行緒(Thread)

  - 執行緒是程式中的執行區段,這個區段中的指令能夠不被其它區段影響而獨立執行,並可以在我們需要時啟動,不需要時關閉,以節省系統資源

- Multithreading(多執行緒)

  - Java 支援多執行緒:

    - 看似電腦可同時執行許多工作,`實質為 CPU 在各個程式中切換`

    - 不是每個程式都必須使用執行緒,但使用多緒多工,可使系統的效率
      得以充分發揮

  - 已知的執行緒:

    - Java 的 Garbage Collector 即是一個執行緒 (daemon thread)

      - `daemon thread` 意思就是`背景執行續`

      - 舉例:
        - 音樂播放
        - Java 垃圾執行續

    - Java 程式啟動時,即自動建立一個執行緒,稱為主執行緒(main thread)
      - `main thread` 任務就是`把 main 方法執行完畢`

<div style="
width: 300px;
height: 300px;
text-align: center;
background: rgba(66, 185, 130, 0.1);
border-radius: 50%;
line-height: 70px;
">
<div>應用程式(Application)</div>
<div style="
background: rgba(66, 185, 130, 0.1);
border-radius: 50%;
height: 65%;
width: 65%;
line-height: 70px;
margin-left: 10px;
">
  <div>作業系統</div>
  <div style="
background: rgba(66, 185, 130, 0.1);
border-radius: 50%;
height: 40%;
width: 40%;
line-height: 50px;
margin-left: 10px;
">
    <div>硬體</div>
  </div>
</div>
</div>

- 經常被誤會的詞

- Process(程序，行程)
- Thread(執行續)

# <a id='s2' class='md-title' href='#top'>2. Thread 類別</a>

- 教科書說法

  1. `繼承 java.lang.Thread 類別`
  1. 建立 Thread 類別的衍生類別,並覆寫(Override)其 `run()` 方法
  1. `run()` 方法為執行緒執行的地方(用了 run 表示使用單執行續，只有`start()`裁示啟動多執行續)

- 簡說

  1. 繼承 `Thread` 類別
  2. 覆寫 `run()`
  3. 實體化物件後，呼叫 `start()` 啟用

- 多執行續

```java
package ch04;

// 多執行續
public class CounterThread extends Thread {
  int counter = 10;

  public CounterThread() {
  } // 建構者函數

  public void run() { // 執行緒執行的地方
    while (counter > 0) {
      System.out.println(counter);
      counter--;

      try {
        Thread.sleep(1000); // 暫停一秒
      } catch (Exception e) {
      }
    }
  }

  public static void main(String arg[]) {
    CounterThread t1 = new CounterThread(); // 產生執行緒物件
    CounterThread t2 = new CounterThread();
    t1.start(); // 呼叫執行緒物件的start()方法(即啟動執行緒) , 隨即執行物件中的run方法
    t2.start();
  }
}
```

# <a id='s3' class='md-title' href='#top'>3. Runnable 介面</a>

- 教科書說法

  - 在不能多重繼承時,可實作 `java.lang.Runnable` 介面
  - 建立實作 `Runnable` 介面的類別,並實作(implements)其 `run()` 方法,再將上述衍生類別的參考,透過 Thread 類別的建構子以建立一個 Thread 類別的實體

- 簡說

  1. 實作 `Runnable` 介面
  2. 覆寫 `run()`
  3. 實體化物件`CounterRunnable r = new CounterRunnable;` (物件名自訂)
  4. 用 Thread 物件包裝 `Thread t = new Thread(r);`
  5. 呼叫 `t.start()` 啟用

```java
package ch04;

public class CounterRunnable implements Runnable {
  int counter = 10;

  public CounterRunnable() {
  } // 建構者函數

  public void run() { // 執行緒執行的地方
    while (counter > 0) {
      System.out.println(counter);
      counter--;

      try {
        Thread.sleep(1000); // 暫停一秒
      } catch (Exception e) {
      }
    }
  }

  public static void main(String arg[]) {
    CounterRunnable r1 = new CounterRunnable();// 產生Runnable物件
    Thread t1 = new Thread(r1); // 再由Runnable物件, 產生執行緒Thread物件
    CounterRunnable r2 = new CounterRunnable();
    Thread t2 = new Thread(r2);
    t1.start(); // 呼叫執行緒物件的start()方法(即啟動執行緒) , 隨即執行物件中的run方法
    t2.start();
  }
}
```

# <a id='s4' class='md-title' href='#top'>4. 執行緒生命週期</a>

<div style="text-align:center">
  <img src="./image/17-01_01.png">
</div>

- 預備狀態(Ready)

  - 執行 start()方法即進入排程器中等候 CPU 處理(`不一定啟動就執行`)

- 執行狀態(Running)

  - run()方法被呼叫時

- 死亡狀態(Dead)

  - run()方法執行完畢時,或 stop()方法被呼叫時 (`註: stop()不再使用，官方也不建議用`)

    - 這種方法被稱為被列為 `Deprecated (淘汰)` 的方法
    - 開發工具會顯示 ~~`stop()`~~

- 等待狀態(Waiting)(`用在執行續之間的溝通設計`)

  - 執行 wait()方法即移出執行狀態,透過 notify()或 notifyAll()方法回到預備狀態

- 睡眠狀態(Sleeping)

  - 停止一段時間後回到預備狀態

- 阻塞狀態(Blocked)

  - 需等待一段不確定的 `I/O 時間(硬體的執行時間)`,移出執行狀態

- 暫停狀態(Suspended)

  - 透過 resume()方法回到預備狀態 (`註: 不再使用，因為有sleep所以這個官方也不建議在使用，若要用相關功能則使用sleep即可`)

---

- start() > Runnable(Ready)(`作業系統排程區`) > Running(`run()`方法執行) > Dead(`run()執行完畢`)
- wait()、notify() 是 Object 類別的方法
- I/O blocked 硬體執行的延遲時間

# <a id='s5' class='md-title' href='#top'>5. 執行緒常用方法</a>

- 因為 run 方法本身是沒有丟出例外的，所以如果要 override 這樣一定要用 try catch
- Interrupted 干擾/打斷，而 <code>InterruptedException</code> 在下列常用方法中是一種 check exception ，即<code>一定要處裡的意外</code>，這種意外跟作業系統執行因素影響有關
- <code>milliseconds</code> 是<code>毫秒</code>的意思

<table>
<tbody>
<tr>
<td>方法</td>
<td>說明</td>
</tr>
<tr>
<td>void run()</td>
<td>執行緒執行的地方</td>
</tr>
<tr>
<td>void start()</td>
<td>啟動執行緒</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>設定執行緒的名字</td>
</tr>
<tr>
<td>String getName()</td>
<td>回傳執行緒的名字</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>設定執行緒的優先權為newPriority</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>取得執行緒的優先權值</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>判斷目前執行緒狀態是否為存在(<code>還活著嗎</code>)</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>設定為背景執行緒</td>
</tr>
<tr>
<td>boolean isDaemon()</td>
<td>判斷是否為背景執行緒</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>回傳目前正在執行的執行緒物件</td>
</tr>
<tr>
<td>void join() throws InterruptedException</td>
<td>等待此執行緒執行終止</td>
</tr>
<tr>
<td>static void yield()</td>
<td>使目前的執行緒讓出執行權</td>
</tr>
<tr>
<td>static void sleep (long milliseconds)<br />Throws InterruptedException</td>
<td>使執行緒休眠多少毫秒</td>
</tr>
<tr>
<td>ThreadGroup getThreadGroup()</td>
<td>回傳目前執行緒的<code>執行緒群組</code></td>

</tr>
</tbody>
</table>

# <a id='s6' class='md-title' href='#top'>6. 執行續的特性</a>

1. `行為難以掌握 順序難以預測` (依照 cpu 自訂的排程運行，所以每次順序都會不同)
2. `執行時隨時會切換`

```cs
範例程式: "/JavaEx_Part2/src/ch04/MyThread.java"
範例程式: "/JavaEx_Part2/src/ch04/TestMyThread.java"
```

```java
package ch04;

public class MyThread extends Thread {
  public static boolean ready = false; // 「開跑」變數

  // 以四種不同的建構者函數來建立物件 (function overloading)
  public MyThread() {
    super("NT1");
  }

  public MyThread(String name) {
    super(name);
  }

  public MyThread(String name, int priority) {
    super(name);
    setPriority(priority); // 設定執行緒的優先權為newPriority
  }

  public MyThread(String name, int priority, boolean isDaemon) {
    super(name);
    setPriority(priority); // 設定執行緒的優先權為newPriority
    setDaemon(isDaemon); // 設定為背景執行緒
  }

  public void run() {
    while (!ready) {
    } // 只要沒開跑，就不執行下一行。

    System.out.println("My name is " + getName() + "..... My priority is " + getPriority() + "..... Am I alive? "
        + isAlive() + "..... Am I daemon? " + isDaemon());

    String nameOfcurrentThread = Thread.currentThread().getName();
    System.out.println("目前正在執行的執行緒的名字=" + nameOfcurrentThread);
  }
}
```

```java
package ch04;

public class TestMyThread {

  // main也是種執行續，所以目前共啟動6組執行續
  public static void main(String[] args) {
     MyThread nt[] = new MyThread[] {
                     new MyThread(),
                     new MyThread("NT2", 2),
                     new MyThread("NT3", 3),
                     new MyThread("NT6", 6, true),
                     new MyThread("NT9", 9, true)
                     };

            for (int i = 0; i < nt.length; i++)
                nt[i].start();

            //將執行緒物件中的ready變數設為true時，
            //才會離開永久迴圈而執行下去
            MyThread.ready = true;
  }
}
```

# <a id='s7' class='md-title' href='#top'>7. 控制執行續與優先安排</a>

- 執行緒 join 其它執行緒:等它所呼叫的執行緒終止後再繼續執行(`控制執行續的"先後"順序`)

  - join()
  - join(long milliseconds)

- `優先權(Priority)`可確保重要或急迫性執行緒可被`立即`或`經常`執行

  - `流程安排(Scheduling)`是決定多個執行緒的執行順序
  - 優先權的值為 `1` 至 `10` 的整數,由 Thread 類別定義三種常數:
    - `Thread`.`MIN_PRIORITY` : 最小值 = 1 (`增加程式碼的閱讀性`)
      - Thread(類別直接取 static 的資料)
    - `Thread`.`NORM_PRIORITY` : 預設值 = 5
    - `Thread`.`MAX_PRIORITY` : 最大值 = 10
  - 可使用 setPriority() 和 getPriority()方法重新設定和取得優先權值
  - 優先權較高者先執行,但優先權相等時,並非是等待最久者先執行,而是任選其一執行

- `執行續切換`發生於:

  - `有較高優先權的執行續進入排程時`
  - 執行續被`中止執行`或 `run() method 執行完畢`
  - Time-Slice 系統: 系統分配時間用完了(`作業系統的機制`)

- 註: 一般情況下擁有最高優先權的執行續先執行，不過有時候會有例外，因此有時排程器會挑選優先權較低者來執行，以避免`餓死(starvation)`的情形，因此`優先權的使用紙是為了讓排程更有效率而已，物在程是中完全使用優先權的關係來控制程式的進行`

  - 簡言: `比重安排`

- 時間分割(Time-slicing):

  - 如 windows 系統會將 CPU 的時間分成一段段的時間槽(time slot)，特性為:
    - 具 time-slicing 特性作業系統將 time slot 分給「Priority 最高且香等的數個執行續」，直到執行完畢或是被更高優先權的執行續搶走
    - `無法保證 time slot 的平均分配`，也`不保證執行的先後順序`

- 自私的執行續(Selfish thread):

  - 自私的執行續實踐了「socially-impaired」，其特性為:
    - 擁有「密實迴圈(tight loop)」，將一直獨佔 CPU 執行權
    - 如果系統不支援 Time-Slice 則易完全獨佔，直到:
      - 該迴圈執行完畢
      - 或被更高 Priority 之其他執行續被搶走 CPU 執行權
    - windows 系統本身就具有 Time-Slice 的功能，所以測試實不容易有效果

- 禮讓的執行緒

  - 用 `yield()` 改進,自願移出執行(Running)狀態至預備(Ready)狀態
  - 對 `Priority 相等` 的數個執行緒有效

# <a id='s8' class='md-title' href='#top'>8. 執行續總結</a>

- `多執行緒程式的特性(結論一)`:

  - 多執行緒是難以預測其行為的
  - 執行緒的執行順序無法完全保證
  - `Task Switches` 可能在任何時刻任何位置發生
  - 執行緒對於`小改變有高度的敏感性`

    - (類似於一用 yield 就立刻在執行續尚有改變)

  - 執行緒並不總是立刻啟動執行(需被排程)

- `多執行緒程式的特性(結論二)`:

  - 在時間分割(Time-Slicing)系統中優先權相同的執行緒會以一種`幾乎`相同機會的循環方式來執行,甚至優先權較低的執行緒也能取得時間糟(time slot)的一小部份,其`比例`大約正比於他們的優先權值,因此在長時間的執行中不會有執行緒完全都沒有被顧及到

    - 可應用在 server 運行機制

  - 在非時間分割(Time-Slicing)系統中則易發生完全獨佔的情況

  - 對於有大量運算的執行緒應適度的呼叫 yield()來讓其它執行緒有執行的機會,尤其可增加圖形使用者介面(GUI)的良好互動

# <a id='s9' class='md-title' href='#top'>9. 同步 (Synchronization) (1/2)</a>

- `為什麼使用 synchronized 關鍵字`

  - 原因: 在程式的某 Critical Section(危險區域)裡,不同執行緒可能同時存取同一份資源因而產生衝突或重覆修改的問題

  - 目的: 控制每次只能有一個執行緒在使用同一份資源,此時另外的執行緒`無法同時`使用此同一份資源

  - 舉例: 銀行領錢問題

- `使用同步的概念`

  - `Monitor`: 所有物件共有一個 `Monitor` (監控),用來當`每次只能有一個執行緒進入獨佔的鎖(Lock)(或稱作旗標 Flag)`

  - `進入 Monitor`: 在 Java 裡,由呼叫已經 synchronized 關鍵字修正過的 method 即`進入 Monitor 並得到鎖(Lock)`。此時其它所有嘗試進入 Monitor 的執行緒將會`暫停(Blocked 狀態)直到該執行緒離開`

- 什麼資源要鎖定是靠工程師設定

# <a id='s10' class='md-title' href='#top'>10. 資源鎖定的理解</a>

- 步驟 1: 初始資料

```java
package ch04;

import java.io.PrintWriter;

public class TestSync0 {
  static int balance = 1000; // simulate balance kept remotely

  public static void main(String args[]) {
    PrintWriter out = new PrintWriter(System.out, true);
    Account account = new Account(out);

    DepositThread first, second;

    first = new DepositThread(account, 1000, "#1"); // Step1
    second = new DepositThread(account, 1000, "\t\t\t\t#2"); // Step2

    // start the transactions
    first.start();
    second.start();

    // wait for both transactions to finish
    try {
      first.join();
      second.join();
    } catch (InterruptedException e) {
    }
    // print the final balance
    out.println("*** Final balance is " + balance);
  }
}

class Account {
  PrintWriter out;

  Account(PrintWriter out) {
    this.out = out;
  }

  // 因為在這個區域，開始執行價格跟計算，所以必須在此就切斷影響
  // 主要是在這片區域當中，執行的部分是先在這邊計算好後才set金錢
  // 危險區: 執行區都是在這邊執行。多個執行續都呼叫同個方法
  void deposit(int amount, String name) {
    int balance;
    out.println(name + " trying to deposit " + amount);
    out.println(name + " getting balance...");
    balance = getBalance();
    out.println(name + " balance got is " + balance);
    balance += amount;
    out.println(name + " setting balance...");
    setBalance(balance);
    out.println(name + " new balance set to " + TestSync0.balance);
  }

  int getBalance() {
    // simulate the delay in getting balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    return TestSync0.balance;
  }

  void setBalance(int balance) {
    // simulate the delay in setting new balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    TestSync0.balance = balance;
  }
}

class DepositThread extends Thread {
  Account account;
  int depositAmount;
  String message;

  DepositThread(Account account, int amount, String message) {
    this.message = message;
    this.account = account;
    this.depositAmount = amount;
  }

  public void run() {
    account.deposit(depositAmount, message);
  }
}
```

- 步驟 2: 鎖 deposit()

```java
package ch04;

import java.io.PrintWriter;

public class TestSync1 {
  static int balance = 1000; // simulate balance kept remotely

  public static void main(String args[]) {
    PrintWriter out = new PrintWriter(System.out, true);
    Account1 account = new Account1(out);
    DepositThread1 first, second;
    first = new DepositThread1(account, 1000, "#1"); // 因為在這共用同一個account所以才會出現搶資源的情形
    second = new DepositThread1(account, 1000, "\t\t\t\t#2");

    // start the transactions
    first.start();
    second.start();

    // wait for both transactions to finish
    try {
      first.join();
      second.join();
    } catch (InterruptedException e) {
    }

    // print the final balance
    out.println("*** Final balance is " + balance);
  }
}

// 因為Account物件是被共用的，所以是要在這拿鎖
class Account1 {
  PrintWriter out;

  Account1(PrintWriter out) {
    this.out = out;
  }

  synchronized void deposit(int amount, String name) { // synchronized 整個存款method
    int balance;
    out.println(name + " trying to deposit " + amount);
    out.println(name + " getting balance...");
    balance = getBalance();
    out.println(name + " balance got is " + balance);
    balance += amount;
    out.println(name + " setting balance...");
    setBalance(balance);
    out.println(name + " new balance set to " + TestSync1.balance);
  }

  int getBalance() {
    // simulate the delay in getting balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    return TestSync1.balance;
  }

  void setBalance(int balance) {
    // simulate the delay in setting new balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    TestSync1.balance = balance;
  }
}

class DepositThread1 extends Thread {
  Account1 account;
  int depositAmount;
  String message;

  DepositThread1(Account1 account, int amount, String message) {
    this.message = message;
    this.account = account;
    this.depositAmount = amount;
  }

  public void run() {
    account.deposit(depositAmount, message);
  }
}
```

- 步驟 3: 鎖區域

```java
package ch04;

import java.io.PrintWriter;

public class TestSync2 {
  static int balance = 1000; // simulate balance kept remotely

  public static void main(String args[]) {
    PrintWriter out = new PrintWriter(System.out, true);
    Account2 account = new Account2(out);
    DepositThread2 first, second;
    first = new DepositThread2(account, 1000, "#1");
    second = new DepositThread2(account, 1000, "\t\t\t\t#2");
    // start the transactions
    first.start();
    second.start();
    // wait for both transactions to finish
    try {
      first.join();
      second.join();
    } catch (InterruptedException e) {
    }
    // print the final balance
    out.println("*** Final balance is " + balance);
  }
}

class Account2 {
  PrintWriter out;

  Account2(PrintWriter out) {
    this.out = out;
  }

  void deposit(int amount, String name) {
    int balance;
    out.println(name + " trying to deposit " + amount);

    out.println(name + " getting balance...");
    // method 內必需synchronized的片段程式碼，須設定鎖哪個物件
    // this = 現在這個物件 => Account2
    synchronized (this) {
      balance = getBalance(); //
      out.println(name + " balance got is " + balance); //
      balance += amount; //
      out.println(name + " setting balance..."); //
      setBalance(balance); //
    } //
    out.println(name + " new balance set to " + TestSync2.balance);
  }

  int getBalance() {
    // simulate the delay in getting balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    return TestSync2.balance;
  }

  void setBalance(int balance) {
    // simulate the delay in setting new balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    TestSync2.balance = balance;
  }
}

class DepositThread2 extends Thread {
  Account2 account;
  int depositAmount;
  String message;

  DepositThread2(Account2 account, int amount, String message) {
    this.message = message;
    this.account = account;
    this.depositAmount = amount;
  }

  public void run() {
    account.deposit(depositAmount, message);
  }
}
```

- 步驟 4: 鎖 Account

```java
package ch04;

import java.io.PrintWriter;

public class TestSync3 {
  static int balance = 1000; // simulate balance kept remotely

  public static void main(String args[]) {
    PrintWriter out = new PrintWriter(System.out, true);
    Account3 account = new Account3(out);
    DepositThread3 first, second;
    first = new DepositThread3(account, 1000, "#1");
    second = new DepositThread3(account, 1000, "\t\t\t\t#2");

    // start the transactions
    first.start();
    second.start();

    // wait for both transactions to finish
    try {
      first.join();
      second.join();
    } catch (InterruptedException e) {
    }

    // print the final balance
    out.println("*** Final balance is " + balance);
  }
}

class Account3 {
  PrintWriter out;

  Account3(PrintWriter out) {
    this.out = out;
  }

  void deposit(int amount, String name) {
    int balance;
    out.println(name + " trying to deposit " + amount);
    out.println(name + " getting balance...");
    balance = getBalance();
    out.println(name + " balance got is " + balance);
    balance += amount;
    out.println(name + " setting balance...");
    setBalance(balance);
    out.println(name + " new balance set to " + TestSync3.balance);
  }

  int getBalance() {
    // simulate the delay in getting balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    return TestSync3.balance;
  }

  void setBalance(int balance) {
    // simulate the delay in setting new balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    TestSync3.balance = balance;
  }
}

class DepositThread3 extends Thread {
  Account3 account;
  int depositAmount;
  String message;

  DepositThread3(Account3 account, int amount, String message) {
    this.message = message;
    this.account = account;
    this.depositAmount = amount;
  }

  public void run() {
    synchronized (account) { // synchronized 於執行緒 run() method 內
      account.deposit(depositAmount, message);
    }
  }
}
```

- 步驟 5: 類別資料

```java
package ch04;

import java.io.PrintWriter;

public class TestSync2 {
  static int balance = 1000; // simulate balance kept remotely

  public static void main(String args[]) {
    PrintWriter out = new PrintWriter(System.out, true);
    Account2 account = new Account2(out);
    DepositThread2 first, second;
    first = new DepositThread2(account, 1000, "#1");
    second = new DepositThread2(account, 1000, "\t\t\t\t#2");
    // start the transactions
    first.start();
    second.start();
    // wait for both transactions to finish
    try {
      first.join();
      second.join();
    } catch (InterruptedException e) {
    }
    // print the final balance
    out.println("*** Final balance is " + balance);
  }
}

class Account2 {
  PrintWriter out;

  Account2(PrintWriter out) {
    this.out = out;
  }

  void deposit(int amount, String name) {
    int balance;
    out.println(name + " trying to deposit " + amount);

    out.println(name + " getting balance...");

    // 鎖定類別資料
    synchronized (TestSync2.class) {
      balance = getBalance();
      out.println(name + " balance got is " + balance);
      balance += amount;
      out.println(name + " setting balance...");
      setBalance(balance);
    }
    out.println(name + " new balance set to " + TestSync2.balance);
  }

  int getBalance() {
    // simulate the delay in getting balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    return TestSync2.balance;
  }

  void setBalance(int balance) {
    // simulate the delay in setting new balance remotely
    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
    }
    TestSync2.balance = balance;
  }
}

class DepositThread2 extends Thread {
  Account2 account;
  int depositAmount;
  String message;

  DepositThread2(Account2 account, int amount, String message) {
    this.message = message;
    this.account = account;
    this.depositAmount = amount;
  }

  public void run() {
    account.deposit(depositAmount, message);
  }
}
```

- 最終鎖的地方`都是 Account 物件`
  - 步驟 4 跟步驟 2 效率相同
  - 步驟 3 效率較優

# <a id='s11' class='md-title' href='#top'>11. 同步 (Synchronization) 總結</a>

- 使用同步的方法

  - 先找出 Critical Section(危險區域)後:

    1. 在`方法宣`告中加入 synchronized 關鍵字

       - `synchronized method(){...}`

    2. 或`程式區塊`以 synchronized 標示

       - `synchronized(物件){...}`

    3. 或`類別資料`以 synchronized 標示

       - `synchronized(類別名稱.class){...}` 鎖定類別資料

  - 再執行已經用 synchronized 修正過的方法(method)或程式區塊

- 執行效率與程式的穩定度

  - 同步化是一個相當耗時的運算,除非必要,否則應減少使用,尤其是經常執行的方法(method)或程式區段
  - 然而妥善的運用對程式的穩定度和強健度有極大幫助

- 可以不用的地方，`訪客人數`; 需要用的地方，`錢`

# <a id='s12' class='md-title' href='#top'>12. 執行緒間通訊</a>

- 執行緒間的通訊(interthread communication)

  - 目的: 讓執行緒之間可互相交談,彼此等待

  - 方式:

    1. 可透過共同使用的資料交談
    2. 或使用執行緒控制的方法(method),如 join()
    3. 或於 `synchronized 的方法內使用` wait(), notify(), notifyAll()等更細微溝通機制,彼此等待,以避免「生產過剩、不足」或是「消費過剩、不足」的問題,並使 CPU 使用更有效率

  - wait(), notify(), notifyAll() 這些方法在 Object 類別裡實作成 `final` 的方法,所有 Java 類別都可以使用這些方法

  - `wait()`:當一執行緒呼叫 wait()方法時,會放棄 monitor,將 lock 釋放出給另一個正等待進入 monitor 的執行緒,並且進入等待執行緒群(pool)開始等待,直到等待時間終了,或是被另一個進入相同 monitor 的執行緒呼叫 notify()或 notifyAll()方法所叫醒,而再進入 ready 狀態

  - `notify()`: `隨機`叫醒在相同物件上某一個正在 waiting 的執行緒

  - `notifyAll()`: `叫醒`在相同物件上`所有`正在 waiting 的執行緒,priority 最高者將第一個執行

```java
範例程式: "/JavaEx_Part2/src/ch04/TestWaitNotify.java"
```

```java
package ch04;

class Depot {
  private int stock = 0; // 庫存量

  synchronized public void produce(int qty) {
    while (stock > 20) {
      System.out.println("庫存量超過20，暫停生產");
      try {
        wait();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    stock += qty;
    System.out.println("產量：" + qty + "；庫存量：" + stock);
    notify();
  }

  synchronized public void consume(int qty) {
    while (stock < qty) {
      System.out.println("庫存量不足，暫停消費");
      try {
        wait();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    stock -= qty;
    System.out.println("消費量：" + qty + "；庫存量" + stock);
    if (stock < 5) {
      System.out.println("庫存量低，催促生產");
      notify();
    }
  }
}

class Producer extends Thread {
  Depot depot;

  public Producer(Depot depot) {
    this.depot = depot;
  }

  public void run() {
    for (int i = 1; i <= 10; i++)
      depot.produce(4); // 每次生產4個
  }
}

class Consumer extends Thread {
  Depot depot;

  public Consumer(Depot depot) {
    this.depot = depot;
  }

  public void run() {
    for (int i = 1; i <= 10; i++)
      depot.consume(3); // 每次消費3個
  }
}

public class TestWaitNotify {
  public static void main(String[] args) {
    Depot depot = new Depot();
    Producer producer = new Producer(depot);
    Consumer consumer = new Consumer(depot);
    producer.start();
    consumer.start();
  }
}
```

# <a id='s13' class='md-title' href='#top'>13. 死結 (DeadLock)</a>

- 死結(DeadLock)

  - 原因:多執行緒的同步化鎖定(synchronized)可能造成執行緒間相互等待的死結。而 Java 無法偵測或預防死結的發生,須由程式設計師自行控制與掌握

- [哲學家用餐問題](http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)

- 避免死結: 最好方法是預防而非偵測它

- 預防死結: 最簡單方式是將一群物件的鎖定動作,依據相同的順序為之

```cs
範例程式: "/JavaEx_Part2/src/ch04/DeadLock.java"
```

```java
package ch04;

public class DeadLock {
  public static void main(String args[]) {
    T1 t1 = new T1(3, "T1"); // 3 secs
    T2 t2 = new T2(0, "T2"); // 0 secs

    t1.start();
    t2.start();
    try {
      // 睡了一秒
      Thread.sleep(1000); // 1 secs
    } catch (Exception e) {
    }
    t1.stop(); // Deprecated (淘汰)
  }
}

class T1 extends Thread {
  private int sleepTime = 0;
  public static boolean finished = false;

  public T1(int second, String name) {
    super(name);
    sleepTime = second;
  }

  public void run() {
    System.out.println("T1 running...");
    try {
      // 睡三秒在起來
      Thread.sleep(sleepTime * 1000); // 3 secs
    } catch (Exception e) {
    }
    System.out.println("T1 finished.");
    T1.finished = true;
  }
}

class T2 extends Thread {
  private int sleepTime = 0;

  public T2(int second, String name) {
    super(name);
    sleepTime = second;
  }

  public void run() {
    while (!T1.finished) {
      yield();
    }
    System.out.println("T2 running...");
    System.out.println("T2 finished.");
  }
}
```

```cs
範例程式: "/JavaEx_Part2/src/ch04/NoDeadLock.java"
```

```java
package ch04;

public class NoDeadLock {
  public static void main(String args[]) {
    T1_1 t1 = new T1_1(3, "T1_1"); // 3 secs
    T2_1 t2 = new T2_1(0, "T2_1"); // 0 secs

    t1.start();
    t2.start();
    try {
      Thread.sleep(5000); // 原1 sec 比 3 secs 小 , 使得t1仍在sleep時被 stop
    } catch (Exception e) {
    }                       // 因此無法執行T1_1.finished = true;
    t1.stop();              // 造成t2之迴圈 while(!T1_1.finished){yield();} 為真,無法離開
  }
}

class T1_1 extends Thread {
  private int sleepTime = 0;
  public static boolean finished = false;

  public T1_1(int second, String name) {
    super(name);
    sleepTime = second;
  }

  public void run() {
    System.out.println("T1_1 running...");
    try {
      Thread.sleep(sleepTime * 1000); // 3 secs
    } catch (Exception e) {
    }
    System.out.println("T1_1 finished.");
    T1_1.finished = true;
  }
}

class T2_1 extends Thread {
  private int sleepTime = 0;

  public T2_1(int second, String name) {
    super(name);
    sleepTime = second;
  }

  public void run() {
    while (!T1_1.finished) {
      yield();
    }
    System.out.println("T2_1 running...");
    System.out.println("T2_1 finished.");
  }
}
```

# <a id='s14' class='md-title' href='#top'>14. Daemon 執行緒</a>

- Daemon 執行緒

  - Daemon 執行緒的工作是等待別人要求服務,其 run 方法通常是一個`無窮迴圈`
  - 當其它所有執行緒都結束執行,只剩 Daemon 執行緒時,JVM 便會結束 Daemon 執行緒的執行
  - Daemon 執行緒通常為系統程式,而非 Daemon 執行緒通常為應用程式,建議前者的優先權應比後者為低
  - Java 的 Garbage collector 即是一種 Daemon 執行緒

- 單核多續/多核多續

# <a id='s15' class='md-title' href='#top'>15. 執行續留意總結</a>

- thread
- runnable
- 執行續特性
- 剩下兩個小節沒有要繼續說了，主要是手機會出現的問題
