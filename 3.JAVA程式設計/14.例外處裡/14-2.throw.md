<h1 id="top">目錄</h1>

- [1. throw 關鍵字](#s1)
- [2. 取得錯誤訊息的方法](#s2)
- [3. 自訂例外](#s3)
- [4. 例外處裡注意](#s4)
- [5. Exception 與 Override](#s5)
- [6. 例外處裡範例](#s6)
- [7. 例外類型多重捕捉](#s7)
- [8. 改良重新拋出例外的類型檢查](#s8)

---

# <a id='s1' class='md-title' href='#top'>1. throw 關鍵字</a>

- 可使用 throw 關鍵字,將方法內的例外手動丟出

- throw 的指令格式:

  - throw 「一個可被丟出的物件」

  - 該物件必須是 java.lang.`Throwable` 類別的子類別，即表示所有狀態異常的方法都可以用 Throwable 中的功能

- throw 使用時機

  - 對方法設計時參數資料的檢查，有問題即可自行產生例外丟出，強制結束該方法的執行

  - 搭配`自訂例外`的產生丟出

```java
package ch01;

public class TestThrowDemo {
  // ArithmeticException 分母為 0 時的狀態異常
  public static double method(double i, double j) throws ArithmeticException {
    double result;
    if (j == 0) {
      /*
      * 1. 指定發生原因說明  ArithmeticException(自訂錯誤信息)
      * ArithmeticException ae = new ArithmeticException("喂! 除到0 ! 算數錯誤!");
      * 2. 有問題就在這直接拋出異常
      * throw ae;
      * 以上方法就是下述步驟的完整版:
      */
      throw new ArithmeticException("喂! 除到0 ! 算數錯誤!");
    }
    result = i / j;
    return result;
  }

  public static void main(String[] args) {
    try {
      System.out.println(method(1, 0));
    } catch (ArithmeticException e) { // e 例外物件名
      /*
      * e.getMessage() 可以取得自訂錯誤提示信息，但程式會繼續執行
      * e.printStackTrace() 可以得到完整錯誤信息與錯誤方法、錯誤行數，並強制結束該方法的執行(Debuger時推薦)
      */
      e.printStackTrace();
    }
  }

}
```

---

```java
java.lang.ArithmeticException: 喂! 除到0 ! 算數錯誤!
	at ch01.TestThrowDemo.method(TestThrowDemo.java:8)
	at ch01.TestThrowDemo.main(TestThrowDemo.java:18)
```

- 錯誤信息查看是由下而上查看 `main` > `method`

# <a id='s2' class='md-title' href='#top'>2. 取得錯誤訊息的方法</a>

- printStackTrace() `大推，開發階段的神兵利器` `p.204`

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">取得錯誤訊息的方法</th>
<th style="text-align:center">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">getMessage()</td>
<td style="text-align:center">Returns the detail message string of this throwable</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">printStackTrace()</td>
<td style="text-align:center">Prints this throwable and it's backtrace to the standard error stream</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">printStackTrace (PrintStream s)</td>
<td style="text-align:center">Prints this throwable and it's backtrace to the specified print stream 至指定的輸出設備</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">toString()</td>
<td style="text-align:center">Returns a short description of this throwable 簡短描述</td>
</tr>
</tbody>
</table>

# <a id='s3' class='md-title' href='#top'>3. 自訂例外</a>

- 一定得繼承 Throwable 或以下兩種

  - 一定`要處裡的例外`就繼承 Exception

  - `不一定要處裡的例外`就繼承 RuntimeException

- `自訂的例外`類別通常會包含`兩個建構子`

```java
public 建構子名稱(){}
public 建構子名稱(String message){
  super(message);
}
```

# <a id='s4' class='md-title' href='#top'>4. 例外處裡注意</a>

- 例外處裡`不能為空`，否則不會提示相關錯誤信息

```java
try {
  Cube cu = new Cube(length);
  System.out.println(cu.getVolume());
} catch (CubeException e) {

}
```

# <a id='s5' class='md-title' href='#top'>5. Exception 與 Override</a>

- `子類別`覆寫其父類別定義有`throws`方法時，子類別所 throws 的 Exception 必須與父類別被覆寫方法的 Exception 一樣或更低階(`子類別例外`)

- 例外只能`越丟越小` (`參考分享資料夾 codes > exceptions > SmartPhone.java + IPhone.java + Test.java`)

  ```java
  public class BaseClass {
    // try IOException
    public void method() throws IOException { }
  }
  public class OK_A extends BaseClass {
    // true 例外能跟父類別相同
    public void method() throws IOException { }
  }
  public class OK_B extends BaseClass {
    // true 不會有例外產生所以也不需要例外處裡
    public void method() { }
  }
  public class NG_C extends BaseClass {
    // error 只能越丟越小
    public void method() throws Exception { }
  }
  ```

# <a id='s6' class='md-title' href='#top'>6. 例外處裡範例</a>

- 1 2 因為只要執行就拋出 所以會執行異常

  ```java
  package ch01;

  public class ExceptionFlow2 {

    public static void main(String[] args) {
      try {
        method();
      } catch (Exception e) {
        System.out.println("3 - Exception handling in main()");
      }
    }

    public static void method() throws Exception {
      try {
        System.out.println("1 - in method()"); // 步驟1
        throw new Exception();
      } catch (Exception e) {
        System.out.println("2 - Exception handling in method()");
      }
    }
  }
  ```

- 1 3 拋出的例外可以自己解決 就會自己解決 不行解決就會拋出

  ```java
  package ch01;

  public class ExceptionFlow2 {

    public static void main(String[] args) {
      try {
        method();
      } catch (Exception e) {
        // 步驟3: Exception 可以解決 Exception 的例外，問題解決
        System.out.println("3 - Exception handling in main()");
      }
    }

    public static void method() throws Exception {
      try {
        // 步驟1: 執行結果
        System.out.println("1 - in method()");
        // 步驟2: 拋出例外
        throw new Exception();
      } catch (RuntimeException e) {
        // 步驟3: RuntimeException 無法解決 Exception(爸爸) 的例外，所以不會進入拋出
        System.out.println("2 - Exception handling in method()");
      }
    }
  }
  ```

- 1 2 3 錯誤可以連續拋出

  ```java
  package ch01;

  public class ExceptionFlow2 {

    public static void main(String[] args) {
      try {
        method();
      } catch (Exception e) {
        // 步驟5: 接住例外並執行結果，例外結束
        System.out.println("3 - Exception handling in main()");
      }
    }

    public static void method() throws Exception {
      try {
        // 步驟1: 執行結果
        System.out.println("1 - in method()");
        // 步驟2: 拋出例外
        throw new Exception();
      } catch (Exception e) {
        // 步驟3: 執行結果
        System.out.println("2 - Exception handling in method()");
        // 步驟4: 拋出例外
        throw e;
      }
    }
  }
  ```

# <a id='s7' class='md-title' href='#top'>7. 例外類型多重捕捉</a>

- `Java7` 開始一個 catch()中可以處裡多個例外，例如: `catch(Exction a | Excetion b)`

- catch 括號內的例外類型`不能有繼承關係`

  ```java
  static class ExceptionA extends Exception {}
  static class ExceptionB extends Exception {}
  static class ExceptionC extends ExceptionB {}

  // 編譯失敗，catch括號內的例外類型不可有繼承關係
  try {
    methodA("A");
    methodB("B");
    methodC("C");

    // C 繼承 B，B > C B就會先處理。而且因為這樣的問題所以JAVA7這方法會處理這個問題
  } catch (ExceptionA | ExceptionB | ExceptionC e) {
      e.printStackTrace();
  }
  ```

- 適合`對各種不同例外`(`沒繼承關係`)作`相同處裡`的動作

- 做不同處裡，但這樣撰寫`不會增加效率`建議正常寫 try catch 就好

  ```java
  try{
    methodA("A");
    methodB("B");
  } catch  (ExceptionA | ExceptionB) {
    if(e instanceof ExceptionA){
      ExceptionA 的處裡...
    }
    if(e instanceof ExceptionB){
      ExceptionB 的處裡...
    }
  }
  ```

# <a id='s8' class='md-title' href='#top'>8. 改良重新拋出例外的類型檢查</a>

- JAVA7 以前，只能指定一個例外型別

  ```java
  public static void methodA(String name) throws ExceptionA {}
  ```

- `JAVA7` 後編譯器可以更精確地分析需重新拋出的例外類型,在方法宣告的 throws 子句中 `可以` `指定更多明確的例外型別`(`不用另外寫說明書或原碼才能知道例外處裡有哪些`)

  ```java
  public static void methodA(String name) throws ExceptionA,ExceptionB {}
  ```
