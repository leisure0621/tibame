<h1 id="top">目錄</h1>

- [1. I/O 運用時機](#s1)
- [2. InputStream / OutputStream 資料流](#s2)
- [3. BufferedInputStream](#s3)
- [4. 讀入程式片段](#s4)
- [5. 寫出程式片段](#s5)
- [6. 高低接管連接方式](#s6)
- [7. 使用最頻繁的讀取方式 readLine()](#s7)
- [8. Reader / Writer 資料流](#s8)
- [9. 爬蟲的開始](#s9)
- [10. I/O Stream 與 Reader / Writer](#s10)
- [11. Google Map Api 調用方法](#s11)
- [12. CSV 讀取方法](#s12)
- [13. 輸入文字用法](#s13)

---

# <a id='s1' class='md-title' href='#top'>1. I/O 運用時機</a>

- Reader / Writer `專門處理文字`

- InputStrean / OutputStream `網路資料傳輸(會有各種不同格式)`(ex. 影像傳輸...)

# <a id='s2' class='md-title' href='#top'>2. InputStream / OutputStream 資料流</a>

- 低階 I/O: 節點資料流(Node Stream)

- 高階 I/O: 處裡(加工)資料流(Procressing Stream)

  - 負責與媒體資料做存取(`跟資料源頭或目的地相接使用`)

- 水管串接的工作

  - I/O 鍊(I/O Chain)

    - 建立一個 I/O 前要 `先` 用 `低階 I/O 類` 來存取資料(如檔案)
    - 之後 `再` `用高階 I/O 來控制低階 I/O 類別` 的動作
    - 此層層架構稱之為 I/O 鍊 (I/O Chain)

- 高階 I/O 類別可再與其它高階 I/O 類別連結

- `輸入` 類的資料流 `只能` 與 `輸入` 類的類別相連接

- `輸出` 類的資料流 `只能` 與 `輸出` 類的類別相連接

# <a id='s3' class='md-title' href='#top'>3. BufferedInputStream</a>

- 生活化例子

  - 有 10 箱東西要從貨車上運往倉庫，運送方法有兩種

    - 一次運送 1 個，送 10 次
    - 用推車一次運送 5 個，送 2 次

- Buffer 緩衝，就像運送的小推車，有了小推車後運送次數可以少很多又快

  - 緩衝(記憶體空間)，為了減少硬體執行次數而做的機制

- BufferedInputStream ，Java 提供的`具有緩衝區功能的類`，8kb 緩衝大小，滿了 8kb 就送資料 (後續能夠`自訂緩衝`)

# <a id='s4' class='md-title' href='#top'>4. 讀入程式片段</a>

```java
// 建立一個檔案輸入流
FileInputStream fis = new FileInputStream("讀入檔案名");
// 建立一個高階 I/O 物件 BufferedInputStream bis, 並連結至 fis,將 fis 放到緩衝區
BufferedInputStream bis = new BufferedInputStream(fis);
// 從緩衝區讀取資料,以減少 CPU 的 I/O 時間
bis.read();
```

- `資源關閉(close)順序: 越晚建立的資料越早關閉`

- `源頭`(FileInputStream) → `程式`(BufferedInputStream)

# <a id='s5' class='md-title' href='#top'>5. 寫出程式片段</a>

```java
// 低接管
FileOutputStream fos = new FileOutputStream("寫出檔案名");
// 高階管
BufferedOutputStream bos = new BufferedOutputStream(fos);
// 高階管
PrintStream ps = new PrintStream(bos);
// 使用後文字覆寫入檔案中 原檔案資料將被覆寫(覆蓋)
ps.println("Hello World");

ps.close();
bos.close();
fos.close();
```

- `程式`(PrintStream) → (BufferedOutputStream) → `盡頭(目的地)`(FileOutputStream)

- 範例程式: `/JavaEx_Part2/src/ch02/FileInputStreamReadFile.java`

# <a id='s6' class='md-title' href='#top'>6. 高低接管連接方式</a>

```java
// 低階管 建立
FileInputStream fis = new FileInputStream("c:\\javawork\\hello.txt");
// 高階管 接入 資料放入緩衝區加速
BufferedInputStream bis = new BufferedInputStream(fis);
// 使用管道
while ((i = bis.read()) != -1) {
  System.out.print((char) i);
}
// bis 先建立，先關閉(資源)。就像衣服穿很多層越晚穿上的衣服越早脫
bis.close();
fis.close();
```

- 範例程式: `/JavaEx_Part2/src/ch02/FileReaderReadFile.java`

# <a id='s7' class='md-title' href='#top'>7. 使用最頻繁的讀取方式 readLine()</a>

```java
String str;
FileReader fr = new FileReader("c:\\javawork\\hello.txt");
BufferedReader br = new BufferedReader(fr) ;
while ((str = br.readLine()) != null)
    System.out.println(str);

br.close();
fr.close();
```

# <a id='s8' class='md-title' href='#top'>8. Reader / Writer 資料流</a>

- 與 I/O Stream 不同則在於 Reader / Writer 是專門用於 Unicode 的字元處理

- 其他使用方式相同

```java
// 建立一個檔案輸入流
FileReader fr = new FileReader("讀入檔案名");

// 建立一個高階I/O物件BufferedReader br, 並連結至fr,將fr放到緩衝區
BufferedReader br = new BufferedReader(fr);

// 從緩衝區讀取資料,以減少CPU的I/O時間
br.readLine();
```

```java
// 如果沒有檔案則會直接創建
FileWriter fw = new FileWriter("寫出檔案名");

BufferedWriter bw = new BufferedWriter(fw);

PrintWriter pw = new PrintWriter(bw);

pw.println("Hello World");

pw.close();
bw.close();
fw.close();
```

- 範例程式: `/JavaEx_Part2/src/ch02/PrintWriterWriteFile.java`

# <a id='s9' class='md-title' href='#top'>9. 爬蟲的開始</a>

- 網址 `代表一個資源在網路上所帶表的位置`

- 爬蟲主要針對指定頁面撰寫，因為有指定頁面結構(因為每個頁面結構都不同)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>

```java
package ch02;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class GetNatalieFromInternet {

  public static void main(String[] args) {
    File dir = new File("C:\\Pictures");
    // 資料夾不存在
    if (!dir.exists()) {
      // 創建資料夾
      dir.mkdir();
    }

    // 目的: 取得42張圖片
    for (int i = 1; i <= 42; i++) {
      // 設定路徑
      String url = "http://www.space-fox.com/wallpapers/celebs/natalie-portman" + "/natalie_portman_" + i
          + ".jpg";
      // 存檔名稱 最後一個/之後的位置開始，即 natalie_portman_[i].jpg
      String filename = url.substring(url.lastIndexOf("/") + 1);
      // 輸出 檔案路徑，檔案名稱 ，即 C:\\Pictures\natalie_portman_[i].jpg
      File file = new File(dir, filename);
      try {
        // 放如符合網址格式的字串 產生網址(URL)物件
        URL myURL = new URL(url);
        // 呼叫通道 回傳一個HTTP連線物件
        HttpURLConnection conn = (HttpURLConnection) myURL.openConnection();
        // 取得輸入資料流 圖片
        InputStream is = conn.getInputStream();
        // 輸出目的地
        FileOutputStream fos = new FileOutputStream(file);

        System.out.println("Wallpaper: " + filename + " kick-off!");

        // 自訂緩衝(分段輸入/輸出)
        int length = 0;
        // 設定(分段讀取)緩衝區大小 4KB (根據資料源頭大小約定在八分之一或十分之一的大小)
        byte[] b = new byte[4096];
        // 參考 [輸入父類別] p.215 的方法2，將資料用 bytes(位元組) 方式寫入 byte 陣列當中
        // int read(byte[] b) 中的 int 表示[讀取後該陣列資料的長度]
        while ((length = is.read(b)) != -1) {
          // 資料分段讀取
          // b: 代表要輸出的byte陣列 (資料都放在裡面了)
          // 0: 代表從這個陣列的第一個元素開始輸出 (索引值)
          // length: 代表要輸出的資料量
          fos.write(b, 0, length);
          // 沖出 把緩衝區資料[強制]送出，為了保證資料不裝滿的情況下都會送出(避免資料遺失)
          fos.flush();
        }

        // 關閉水管
        fos.close();
        is.close();
        System.out.println(filename + " Done!");

      } catch (MalformedURLException e) {
        e.printStackTrace();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```

- 範例程式: [抓取妮可波曼 GetNatalieFromInternet](https://drive.google.com/drive/folders/12Y_1Ky7br8gvHI0q0ZY68ACOSazDmpM0)

# <a id='s10' class='md-title' href='#top'>10. I/O Stream 與 Reader / Writer</a>

- 網路 I/O 與 Console I/O

  - 因為網路 I/O 與 Console I/O 是以 b*yte[]為基礎*的 I/O,
    所以 `Reader / Writer 不能夠直接存取網路` I/O 與 Console I/O

  - `System.in`、`System.out`、`System.err` 三個不同資料流
    不需經 new 宣告即可使用(見下一頁)

    - `System.in`: 標準 `輸入` 資料流

    - `System.out`: 標準 `輸出` 資料流 (display，輸出至螢幕)

    - `System.err`: 標準 `錯誤輸出` 資料流 (display，輸出至螢幕並顯示`紅色`)

- InputStreamReader 類別

  - An InputStreamReader is a bridge from byte streams to character
    streams

  - 使用此類別後文字能正常顯示，但有時仍須用此方法轉碼

  - 一般用法: `InputStreamReader isr = new InputStreamReader(doc);`

  - `轉碼` 的原因是 Windows 的編碼格式是 `MS950`(中文編碼為 Big5，windows 系統建立之初還沒有 Unicode 的規範，所以每種語言都有獨自的編碼格式)

  - 轉碼用法: `InputStreamReader isr = new InputStreamReader(doc,"MS950");`

- OutputStreamWriter 類別

  - An OutputStreamWriter is a bridge from character streams to byte

- InputStreamReader 與 OutputStreamWriter 可以想像為是 `轉接頭`

# <a id='s11' class='md-title' href='#top'>11. Google Map Api 調用方法</a>

```java
package xxx;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class GetGooglePlaceTest {
  private static final String GOOGLE_URL =
      "https://maps.googleapis.com/maps/api/place/nearbysearch/json?"
      + "location=24.95375,121.22575&"
      + "radius=500&"
      + "types=food&"
      + "name=吃到飽&"
      + "language=zh-TW&"
      + "key=AIzaSyAYmC8oUYc9DGAZn8hqZKakFeclhAbTRSI";

  public static void main(String[] args) throws IOException {
    URL url = new URL(GOOGLE_URL);
    HttpURLConnection con = (HttpURLConnection) url.openConnection();
    con.setRequestMethod("GET");
    con.setUseCaches(false);

    int statusCode = con.getResponseCode();
    System.out.println(statusCode);

    InputStream is = con.getInputStream();
    InputStreamReader isr = new InputStreamReader(is);
    BufferedReader br = new BufferedReader(isr);

    String data;
    while ((data = br.readLine()) != null) {
      System.out.println(data);
    }

    br.close();
    isr.close();
    is.close();
  }
}
```

- 範例程式: [抓取 googleMapApi 並轉成文字 GetGooglePlaceTest](https://drive.google.com/drive/folders/12Y_1Ky7br8gvHI0q0ZY68ACOSazDmpM0)

# <a id='s12' class='md-title' href='#top'>12. CSV 讀取方法</a>

```java
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class CSVTest {

  public static void main(String[] args) throws IOException {
    File file = new File("C:\\javawork\\student.csv");
    // (不建議)
    // 2. 直接更改Java環境的編碼設定 (windows -> preferences -> General -> Workspace -> Text file encoding)
    FileReader fr = new FileReader(file);
    BufferedReader br = new BufferedReader(fr);

    String str;
    while ((str = br.readLine()) != null)
      System.out.println(str);

    br.close();
    fr.close();

    // (建議用)
    // 1. 先以位元資料讀取進來, 在程式裡做轉換並指定正確的編碼
    FileInputStream fis = new FileInputStream(file);
    InputStreamReader isr = new InputStreamReader(fis, "MS950");
    BufferedReader br = new BufferedReader(isr);

    String str;
    while ((str = br.readLine()) != null)
      System.out.println(str);

    br.close();
    isr.close();
    fis.close();
  }
}
```

- 範例程式: [取得 csv 資料 CSVTest](https://drive.google.com/drive/folders/12Y_1Ky7br8gvHI0q0ZY68ACOSazDmpM0)

# <a id='s13' class='md-title' href='#top'>13. 輸入文字用法</a>

- `沒用 Scanner 前使用此方法`，現在是 Scanner 好用喔

```java
package ch02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class InputFromKeyboard {
  public static void main(String args[]) {

    System.out.println("請輸入資料....");

    // 步驟一
    InputStreamReader isr = new InputStreamReader(System.in);

    // 步驟二
    BufferedReader br = new BufferedReader(isr);

    try {

      // 步驟三
      String data = br.readLine();

      System.out.println(data);

    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

- 範例程式: `/JavaEx_Part2/src/ch02/InputFromKeyboard.java`

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/299634/">http 與 https 處裡</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
