# Map 介面

- Map(`Dictionary`) 是一種`key/value`的集合,每一筆資料皆有一對(`對應(映)`)主鍵值(key)和內含值(value)

  - Hashtable table = new Hashtable();
    table.put("key", "value");

- 若使用相同的主鍵值,則新的資料會取代舊的資料
- 使用主鍵值尋找內含值,若主鍵值不存在,則會回傳 null
- HashMap 類別實作 Map 介面

  - 取得 Map 集合中所有的 key,可以使用 keySet(),它會將 Map 裡所包含的所有 key 以 Set 介面的型態回傳

- Set keySet()

  - 取得 Map 集合中所有的 value,可以使用 values(),它會將 Map 裡所包含的所有 value 以 Collection 介面的型態回傳

- Collection values()

- `Map 是一種key/value的集合`,每一筆資料皆有一對主鍵值(key)和內含值(value)

  - Hashtable table = new Hashtable();
    table.put("key", "value");

- 若使用`相同的主鍵值`,則`新的資料會取代舊的資料`

- 使用主鍵值尋找內含值,若`主鍵值不存在`,則`會回傳 null`

- `HashMap` 類別實作 Map 介面

- 取得 Map 集合中所有的 key,可以使用 keySet(),它會將 Map 裡所包含的所有 key 以 Set 介面的型態回傳

- Set keySet()

  - 取得 Map 集合中所有的 value,可以使用 values(),它會將 Map 裡所包含的所有 value 以 Collection 介面的型態回傳

- Collection values()

# Map 常用方法

- 因為資料型態是 Object ，所以可以將任何資料做 key 或 value
- 重複的 key 會將既有 key 值取代

<table>
<tbody>
<tr style="height: 43px;">
<td style="height: 43px;" colspan="2" align="center">&lt;&lt;interface&gt;&gt;<br />Map&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;"><code>Object</code> put(Object key, Object value)</td>
<td style="height: 23px;">將指定的鍵與值放到Map裡</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Object get(Object key)</td>
<td style="height: 23px;">依指定的鍵取得對應的值</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Object remove(Object key)</td>
<td style="height: 23px;">依指定的鍵移除對應的鍵值組</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">void clear()</td>
<td style="height: 23px;">清空Map內所有的鍵值組</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean containsKey(Object key)</td>
<td style="height: 23px;">檢查Map內是否有指定的鍵</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean containsValue(Object value)</td>
<td style="height: 23px;">檢查Map內是否有指定的值</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean isEmpty()</td>
<td style="height: 23px;">檢查Map是否為空容器</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">int size()</td>
<td style="height: 23px;">回傳Map內的鍵值組總數</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Set keySet()</td>
<td style="height: 23px;">將Map內的所有鍵轉存成Set物件</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Collection values()</td>
<td style="height: 23px;">將Map內的所有值轉存成Collection集合</td>
</tr>
</tbody>
</table>

# HashMap 類別範例

- 範例 1

```java
package ch03;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class TestHashMap {

  public static void main(String[] args) {
    Map map = new HashMap();
    map.put("one", new Integer(1));
    map.put("two", "2");
    map.put("three", new Float(3.0));

    System.out.println(map.get("one"));
    System.out.println(map.get("two"));
    System.out.println(map.get("three"));

    // 取出所有的key,包裝為Set的型態
    Set set = map.keySet();

    Iterator it = set.iterator();
    while (it.hasNext()) {
      Object myKey = it.next();
      System.out.println(myKey + "=" + map.get(myKey));
    }

    //keySet() 方法來自Map介面, 所以所有Map家族成員都適用此方式取值

  }
}
```

- 範例程式: `/JavaEx_Part2/src/ch03/TestHashMap.java`

- 範例 2

```java
package idv.david.additional.iocollection;

import static java.lang.System.out;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

public class DataInputExample {
  public static void main(String[] args) throws IOException {
    // Variables declare 宣告變數
    int totalAge = 0;
    double totalHeight = 0.0;
    double totalWeight = 0.0;
    int totalPerson = 0;
    // 設定map
    Map<String, Integer> cities = new HashMap<String, Integer>();

    // Read data from file 讀取檔案
    BufferedReader br = new BufferedReader(new FileReader("files/data.txt"));

    // Parsing data 設定字串，讀取檔案內容
    String data;
    // 將每行值指定到字串中
    while ((data = br.readLine()) != null) {
      totalPerson++;
      // 文字切割工具(要處裡的字串,分割符)
      // Token 字符(處理過的字串)
      StringTokenizer st = new StringTokenizer(data, ",");
      // hasMoreTokens 返回是否還有分割符
      if (st.hasMoreTokens()) {
        int no = Integer.parseInt(st.nextToken());
        String name = st.nextToken();
        // 總年齡
        totalAge += Integer.parseInt(st.nextToken());
        // 總身高
        totalHeight += Double.parseDouble(st.nextToken());
        // 總重量
        totalWeight += Double.parseDouble(st.nextToken());
        // 用於返回下一個匹配的字串
        String tel = st.nextToken();

        // 顯示各個地方有幾個人
        String city = st.nextToken();
        if (cities.containsKey(city)) {
          int count = cities.get(city) + 1;
          cities.put(city, count);
        } else
          cities.put(city, 1);
      }
    }

    // Output result
    out.printf("平均 年齡: %d歲%n", totalAge / totalPerson);
    out.printf("平均 身高: %.2f公分%n", totalHeight / totalPerson);
    out.printf("平均 體重: %.2f公斤%n", totalWeight / totalPerson);

    Set<String> keys = cities.keySet();
    for (String city : keys)
      out.printf("住址 %S: %d人%n", city, cities.get(city));

    System.out.println("\n---------測試toString()-----------");
    System.out.println("toString()=" + cities); // 測試toString()
  }
}
```

- 範例程式: `/JavaEx_Part2/src/idv/david/additional/iocollection/DataInputExample.java`

# Vector 與 Hashtable 類別

- Vector 為一可置入「任意物件」的「動態陣列」(可隨內含物自動增減長度)

- Hashtable 內部是一個「類似表格」的資料結構來儲存資料

- Vector 從 `JDK1.0` 時代就已存在,在 JDK1.2 時,新的 List 介面出現後,Vector 才加入 List 家族,並實作新的方法

  - `Vector 實作了 List`

- Hashtable 從 `JDK1.0` 時代就已存在,在 JDK1.2 時,新的 Map 介面出現後,Hashtable 才加入 Map 家族,並實作新的方法

- `Vector` 類別等同於 `ArrayList` 類別,但是 Vector 提供`同步化`的優點(與`負擔`),這對`多執行緒`的存取是很重要的

- `Hashtable` 類別等同於 `HashMap` 類別,但是 Hashtable 提供`同步化`的優點(與`負擔`),這對`多執行緒`的存取是很重要的

# Vector 範例

```java
package ch03;

import java.util.*;

//Vector 為一可置入"任意物件"的"動態陣列"(可隨內含物多寡增減其長度)
public class TestVector1 {
  public static void main(String args[]) {
    // 方法1: 使用舊方法必須用 Vector 宣告
    Vector v = new Vector();
    v.addElement(new Integer(12));
    v.addElement(new Long(34L));
    v.addElement(new Float(5.6f));
    v.addElement(new Double(7.8));
    v.addElement(new String("Hello"));

    for (int i = 0; i < v.size(); i++) {
      Object obj = v.elementAt(i);
      System.out.println(obj);
    }

    // 方法2: 也可寫成 List v2 = new Vector();
    Vector v2 = new Vector();
    v2.add(new Integer(12));
    v2.add(new Long(34L));
    v2.add(new Float(5.6f));
    v2.add(new Double(7.8));
    v2.add(new String("Hello"));

    for (int i = 0; i < v2.size(); i++) {
      Object obj = v2.get(i);
      System.out.println(obj);
    }

  }
}
```

- 範例程式: `/JavaEx_Part2/src/ch03/TestVector2.java`
- 範例程式: `/JavaEx_Part2/src/ch03/TestVector1.java`

# Hashtable 範例

```java
/*
1.Hashtable 內部是一個"類似表格"的資料結構來儲存資料, 每一筆資料都有
  對應的索引鍵(key) , 這索引鍵是物件的型態 , 但是通常為方便起見, 大
  部份的情況都是利用"字串"值當做索引鍵(key). 反之當欲取出這筆資料時,
  也是利用剛剛所設定的索引鍵值來取出資料

2.欲儲存不同的資料時必需用不同的索引鍵, 否則其索引鍵所對應資料值為最
  後儲存的那筆資料

3.Hashtable 的資料也是物件的型態, 所以可以儲存任何形式的資料, 使用者
  取出資料的同時, 必須注意該資料的型態而自行作物件資料轉換(casting)的動作.

*/
package ch03;

import java.util.*;

public class TestHashtable {
  public static void main(String args[]) {
    Hashtable hash = new Hashtable();
    hash.put("one", new Integer(1));
    hash.put("two", "2");
    hash.put("three", new Float(3.0));

    // 必須型別轉換
    Integer oneValue = (Integer) hash.get("one");
    String twoValue = (String) hash.get("two");
    Float threeValue = (Float) hash.get("three");

    System.out.println(oneValue);
    System.out.println(twoValue);
    System.out.println(threeValue);
  }
}
```

- 範例程式: `/JavaEx_Part2/src/ch03/TestHashtable.java`

# Enumeration 範例

- JDK1.0 的 `Enumeration` 介面`類似` JDK1.2 的迭代器 `Iterator` 介面

- 介面方法

  - public boolean hasMoreElements()

  - public Object nextElement()

- 物件實作此介面目的是產生一序列的元素,透過呼叫 nextElement() 方法來取得一個一個接續的元素

- nextElement() 所回傳的資料是 Object 的型態,使用者需要做 Casting

- Hashtable 與 Vector 都有提供方法將其資料置於 Enumeration 物件中,並透過 Enumeration 物件來存取所有的資料

# Enumeration 介面

- `System` 可有標準輸入/輸出
- `System.getProperties()` 可獲得系統當前屬性

```java
package ch03;

import java.util.Enumeration;
import java.util.Properties;

// Property(屬性)
// TestProperties 獲得系統屬性
public class TestProperties {
  public static void main(String args[]) {
    Properties props = System.getProperties();
    Enumeration names = props.propertyNames();
    while (names.hasMoreElements()) {
      String name = (String) names.nextElement();
      String val = props.getProperty(name);
      System.out.println("property of " + name + " = " + val);
    }
  }
}
```

# 必須熟練使用

- hashMap
- hashSet
- ArrayList

- 集合比陣列使用更頻繁

---

參考鏈接:

- [java 字符串分解 StringTokenizer 用法（比 split()方法效率高）](https://www.cnblogs.com/gaopeng527/p/4899237.html)
- [java 中 System.getProperty 的用法。](https://blog.csdn.net/BrotherDong90/article/details/49073941)
- [Java 关于 Properties 用法的总结(一)](https://www.cnblogs.com/gongchenglion/p/properties.html)
