<h1 id="top">目錄</h1>

- [1. JDK5](#s1)
- [2. 集合與陣列的比較](#s2)
- [3. 認識物件](#s3)
- [4. 集合架構](#s4)
- [5. 集合常用方法](#s5)
- [6. 如何取得集合中的元素](#s6)
- [7. ArrayList 範例](#s7)
- [8. HashSet 範例](#s8)
- [9. 課堂作業](#s9)

---

# <a id='s1' class='md-title' href='#top'>1. JDK5</a>

- JDK5 開始增加了很多功能，也新增了 foreach 的功能 foreach 也是 JDK5 的 suger

# <a id='s2' class='md-title' href='#top'>2. 集合與陣列的比較</a>

- 集合與陣列比較

<table>
<tbody>
<tr>
<td>&nbsp;</td>
<td>集合</td>
<td>陣列</td>
</tr>
<tr>
<td>空間大小</td>
<td>建立時<code>不必指定集合大小</code>,無論將元素存入或移除,集合都會動態調整空間以符合需求;這是集合最大優點</td>
<td>建立時就必須指定陣列大小,而且之後無法改變。元素存取時,不可超過索引上限,否則會產生<code>ArrayIndexOutOfBoundsException</code></td>
</tr>
<tr>
<td>資料類型</td>
<td><code>可存放任何物件</code>,但若存放<code>基本類型</code>,會先<code>AutoBoxing(y自動裝箱)</code>成對應的物件後再存放。放入的<code>物件</code>還會<code>自動轉型成Object</code>類型,但若搭配泛型功能就可像陣列般限制元素的資料類型</td>
<td>可存放物件或基本類型,但必須符合陣列所宣告的資料類型</td>
</tr>
<tr>
<td>資料存取</td>
<td>要將元素取出,可使用<br />1. for-each<br />2. Iterator<code>(迭代器)</code></td>
<td>要將元素取出,可使用<br />1. for迴圈搭配索引<br />2. for-each</td>
</tr>
</tbody>
</table>

# <a id='s3' class='md-title' href='#top'>3. 認識物件</a>

- 認識集合物件

  - 集合物件是指一群相關聯的資料,集合在一起組成一個物件

  - 集合物件裡面的資料,稱之為元素(element)

- 從 JDK1.2 開始,Java 的集合物件以 Collection 介面與 Map 介面分作兩大類

  - `Collection 介面` 可持有各自獨立的物件
  - `Map 介面` 持有成對的 key-value 物件

- Collection 介面最`重要`的兩個子介面(`背起來，面試必考這兩項`)

  - 子介面 `Set`

    - `無特定順序`,`不允許重複`(重複時不加入)
    - `HashSet` 類別實作 Set 介面

  - 子介面 `List`

    - `有特定順序`,`允許重複`
    - `ArrayList`<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 類別實作 List 介面

# <a id='s4' class='md-title' href='#top'>4. 集合架構</a>

- java.util.Collection 介面是整個集合架構的根介面

  - 有`底線`的代表`類別`
  - 沒`底線`的是`介面`

- Iterable

  - Collection
    - set
      - SortedSet
        - <u>TreeSet</u>
      - <u>HashSet</u>
    - list
      - <u>ArrayList</u>
      - <u>Vector</u>
      - <u>LinkedList</u>
    - Queue
      - <u>LinkedList</u>
      - <u>PriorityQueue</u>

* LinkedList 同時實作 list 與 Queue 兩個介面

---

- 以下兩個特別重要(面試必考)

  - set

  - list

- queue(佇列，排隊)也重要只是大多數人說不到就沒時間了

# <a id='s5' class='md-title' href='#top'>5. 集合常用方法</a>

- size() 就像一維陣列的 length
- toArray() 也可轉為 object 陣列(因為已被自動晉升為 Object 型別)
- 與傳統陣列相比，集合變成用方法來處理各種元素的存取

<table>
<tbody>
<tr style="height: 23px;">
<td style="height: 23px;" colspan="2" align="center">&lt;&lt;interface&gt;&gt;<br />Collection</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean add (E obj)</td>
<td style="height: 23px;">指定物件新增至集合內</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">void clear()</td>
<td style="height: 23px;">將集合內所有元素清空</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean isEmpty()</td>
<td style="height: 23px;">檢查集合是否為空容器</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Iterator iterator()</td>
<td style="height: 23px;">取得iterator物件走訪集合內所有元素</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean remove(Object obj)</td>
<td style="height: 23px;">將指定元素從集合中移除</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">int size()</td>
<td style="height: 23px;">回傳集合內的元素總數</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">boolean contains (Object obj)</td>
<td style="height: 23px;">檢查集合內是否有指定元素</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Object[] toArray()</td>
<td style="height: 23px;">將集合內元素轉存為陣列</td>
</tr>
</tbody>
</table>

<table>
<tbody>
<tr>
<td colspan="2" align="center">&lt;&lt;interface&gt;&gt;<br />List</td>
</tr>
<tr>
<td>void add(int index, E element)<br />boolean add(E element)</td>
<td>指定物件新增至集合指定索引內<br />指定物件新增至集合內</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>取得指定索引的元素</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>指定物件取代集合指定索引的元素</td>
</tr>
</tbody>
</table>

# <a id='s6' class='md-title' href='#top'>6. 如何取得集合中的元素</a>

- 如何取得集合裡的元素

  - Collection 介面提供 iterator() 方法,回傳 Iterator 介面

    - public Iterator iterator()

  - 利用此方法,可把位在 collection 裡的所有元素,轉換成可進行迭代的迭代器(Iterator)

    - `迭代器的使用維一次性`

  - 關於元素傳回的順序是`沒有任何保證的` (除非此 collection 是某個能提供保證順序的類別實體)

    - 所以在此就會用到了 java 本身提供的迭代器，以保證資料的順序姓

- Iterator 介面 (稱為迭代器介面,JDK1.2 開始)

  - 此介面被用來擷取 collection 集合裡的所有元素(也包含了其子介面 Set 與 List)

    - public boolean hasNext()

    - public Object next()

  - Iterator(`迭代器`)介面是為了取代 JDK1.0 的 Enumeration(列舉)介面

- hasNext 可以想像摸彩箱抽獎時，喊下一個~

# <a id='s7' class='md-title' href='#top'>7. ArrayList 範例</a>

```cs
範例程式: "/JavaEx_Part2/src/ch03/TestArrayList.java"
```

```java
package ch03;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class TestArrayList {

  public static void main(String[] args) {
    List list = new ArrayList();
    list.add(new Integer(12));
    list.add(new Long(34L));
    list.add(new Double(5.6));
    list.add("Hello");
    list.add("Hello"); // 值重覆仍加入到集合裡

    System.out.println("toString()=" + list); // 已經對toString改寫過了
    System.out.println("元素個數=" + list.size());

    Iterator objs = list.iterator();
    while (objs.hasNext())
      System.out.println(objs.next());

    // List家族可以用Iterator(迭代器)或for迴圈取值
    System.out.println();
    for (int i = 0; i < list.size(); i++) {
      Object obj = list.get(i);
      System.out.println(obj);
    }
  }
}
```

# <a id='s8' class='md-title' href='#top'>8. HashSet 範例</a>

- 只要用了 set，Java 官方就不保證資料存取時的順序性

```java
package ch03;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class TestHashSet {

  public static void main(String[] args) {
    Set set = new HashSet();
    set.add(new Integer(12));
    set.add(new Long(34L));
    set.add(new Double(5.6));
    set.add("Hello");
    set.add("Hello"); // 值重覆不會加入

    System.out.println("toString()=" + set);
    System.out.println("元素個數=" + set.size());

    // Set家族只能用 Iterator 取值
    Iterator objs = set.iterator();
    while (objs.hasNext())
      System.out.println(objs.next());

  }
}
```

# <a id='s9' class='md-title' href='#top'>9. 課堂作業</a>

```cs
範例程式: "/JavaEx_Part2/src/ch03/TestHashSet.java"
```

```java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class class1 {
  public static void main(String[] args) {
    Set<Integer> set = new HashSet<Integer>();

    while (set.size() < 6)
      set.add((int) (Math.random() * 50 + 1));

    // 陣列值
    System.out.println(set);

    // 照輸入的順序取出
    Iterator<Integer> it = set.iterator();
    while (it.hasNext()) {
      System.out.print(it.next() + "\t");
    }
  }
}
```

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>ArrayList，又稱作動態陣列 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
