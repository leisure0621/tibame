# Math 類別

- java.lang.Math 類別提供許多數學上實用的方法如亂數、絕值、平方根、立方根與三角函數等,讓程式設計師在設計時,省去許多數學運算程式碼的撰寫

- 因為 java.lang.Math 類別所提供的屬性與方法都是類別等級(都是 static 修飾子),因此我們只要透過 Math 類別名稱,即可呼叫所需的屬性或方法,非常方便

# Math 類別常用方法

<table>
<tbody>
<tr style="height: 23px;">
<td style="height: 23px;">方法</td>
<td style="height: 23px;">說明</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double abs(double a)<br />float abs(float a)<br />int abs(int a)<br />long abs(long a)</td>
<td style="height: 83px;">回傳a的絕對值</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double max(double a, double b)<br />float max(float a, float b)<br />int max(int a, int b)<br />long max(long a, long b)</td>
<td style="height: 83px;">比較a, b大小後,回傳較大者</td>
</tr>
<tr style="height: 83px;">
<td style="height: 83px;">double min(double a, double b)<br />float min(float a, float b)<br />int min(int a, int b)<br />long min(long a, long b)</td>
<td style="height: 83px;">比較a, b大小後,回傳較小者</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double pow(double a, double b)</td>
<td style="height: 23px;">回傳a的b次方運算結果</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">random()</td>
<td style="height: 23px;">回傳一個double類型的亂數,值介於0.0(含)~1.0(不含)</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double sqrt(double a)</td>
<td style="height: 23px;">回傳a的正平方根</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">double cbrt(double a)</td>
<td style="height: 23px;">回傳a的立方根</td>
</tr>
</tbody>
</table>

# Math 使用範例

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestMath.java"
```

```java
package ch05;

public class TestMath {
  public static void main(String[] args) {
    System.out.println("Math.PI = " + Math.PI);
    System.out.println("Math.abs(-1.1) = " + Math.abs(-1.1));
    System.out.println("Math.random = " + Math.random());
    System.out.println("Math.max(1.1, 2.1) = " + Math.max(1.1, 2.1));
    System.out.println("Math.min(1.1, 2.1) = " + Math.min(1.1, 2.1));
    System.out.println("Math.pow(3, 3) = " + Math.pow(3, 3));
    System.out.println("Math.sqrt(9) = " + Math.sqrt(9));
    System.out.println("Math.cbrt(27) = " + Math.cbrt(27));
  }
}
```

# String 類別與 StringBuffer 類別

- String 類別不可在原字串所在記憶體位置改變字串內容

- StringBuffer 類別則在原字串所在記憶體位置改變字串內容(append, insert, delete, replace)

- 使用 StringBuffer 類別中的任何方法時,回傳的字串會使用原有的記憶體空間

- `StringBuffer 字串與 String 字串不可以比較`

  - SreintBuffer 未 Override equals 方法

- 如:
  - String s1 = new String(“test”);
  - String s2 = new StringBuffer(“test”);
  - if (s1 == s2) {...} //false
  - if (s1.equals(s2)) {...} //false

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestStringBuffer.java"
```

```java
package ch05;

public class TestStringBuffer {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("Hello Java ");
    sb.append("StringBuffer!");
    System.out.println(sb); // Hello Java StringBuffer!

    StringBuffer sb2 = new StringBuffer();
    sb2.append("現在是上午").append(11).append("點"); // 現在是上午11點

    StringBuffer sb3 = new StringBuffer("Hello  StringBuffer!");
    sb3.insert(6, "Java");
    System.out.println(sb3); // Hello Java StringBuffer!

    StringBuffer sb4 = new StringBuffer("Hello Java StringBuffer!");
    sb4.replace(7, 10, "AVA");
    System.out.println(sb4); // Hello JAVA StringBuffer!

    StringBuffer sb5 = new StringBuffer("Hello Java StringBuffer!");
    sb5.delete(6, 10);
    System.out.println(sb5); // Hello  StringBuffer!

    StringBuffer sb1 = new StringBuffer("AB");
    System.out.println("sb1= " + sb1); // sb1= AB

    StringBuffer sb2 = sb1.append("CD");
    System.out.println("sb1= " + sb1); // sb1= ABCD
    System.out.println("sb2= " + sb2); // sb2= ABCD

    System.out.println(sb1 == sb2); // true 比較址
    System.out.println(sb2.equals(sb1)); // true

    StringBuffer sb = new StringBuffer("AB"); // 需轉成string才能比較
    String s = "AB";
    System.out.println(s3.equals(sb1.toString())); // true
  }
}
```

# StringBuilder 類別

- StringBuilder 類別是 JDK 5 的新類別,其用法與 StringBuffer 類別完全一樣(append, insert, delete, replace)

- 老類別 StringBuffer 是 `thread-safe`(同步) ,新類別 StringBuilder 則是 non-thread-safe

  - 跟 vector , Hashtable 一樣有同步化的優點

- 使用上,如果不考慮多執行緒的問題可以使用 StringBuilder 來提升執行的效率

# Regular Expression 正規表示法

- 正規表示法(Regular Expression)就是由許多樣式的符號組成的樣式句,
  主要功能就是用來比對文字是否符合該規則的要求

- 正規表示法並非 Java 語法,但為了通過編譯,都是以字串型式存在,
  等到要執行時,再由特定的編譯器進行處理

- 正規表示法在本課程會簡略說明,如有興趣的同學可以在網路上搜尋
  到更多規則與說明

<table>
  <tbody>
    <tr style="height: 23px;">
      <td style="height: 23px;">符號</td>
      <td style="height: 23px;">說明</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[ABC]</td>
      <td style="height: 23px;">
        <p>
          A、B、C任一個字元都符合要求<br />例:[ABC]ook,可以是Aook, Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[^ABC]</td>
      <td style="height: 23px;">
        <p>
          不可以含有A、B、C任一個字元<br />例:[^ABC]ook,就不可以是Aook,
          Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[A-C]</td>
      <td style="height: 23px;">
        <p>
          可以是A到C連續字元的任何一個<br />例:[A-C]ook,可以是Aook, Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">[^A-C]</td>
      <td style="height: 23px;">
        <p>
          不可以含有A到C連續字元的任何一個<br />例:[^A-C]ook,就不可以是Aook,
          Book或Cook
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n,m}</td>
      <td style="height: 23px;">
        代表指定字元出現次數最少n次,最多m次<br />逗號之間不得有空白,n與m都要是大於等於0的整數n
        &lt;= m<br />例:Book{1,2}代表k最少要出現1次,最多2次,即Book或Bookk
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n}</td>
      <td style="height: 23px;">
        <p>
          代表指定字元正好出現n次<br />例:Book{1}代表k要出現正好1次,所以只能是Book
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">{n,}</td>
      <td style="height: 23px;">
        <p>
          代表指定字元至少出現n次<br />
          例:Book{1,}代表k要出現至少1次以上,可以是Book, Bookk...
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\d</td>
      <td style="height: 23px;">可以是0~9任何一個數字,相當於[0-9]</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\D</td>
      <td style="height: 23px;">不可以是0~9任何一個數字,相當於[^0-9]</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\s</td>
      <td style="height: 23px;">可以是空白的字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\S</td>
      <td style="height: 23px;">不可以是空白的字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\w</td>
      <td style="height: 23px;">可以是一個英文字母或數字</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\W</td>
      <td style="height: 23px;">不可以是任何英文字母或數字</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">?</td>
      <td style="height: 23px;">
        指定字元最多出現1次,也可以不出現,相當於{0,1}<br />例:S?PP就可以是PP或SPP。?在S後面,則是S受到?限制
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">+</td>
      <td style="height: 23px;">指定字元至少要出現1次以上,相當於{1,}</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">*</td>
      <td style="height: 23px;">指定字元出現0次以上,相當於{0,}</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">.</td>
      <td style="height: 23px;">任一字元</td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">( )</td>
      <td style="height: 23px;">
        <p>
          括弧內,代表同一個群組<br />例:(SPP){2}代表SPP是一體,必須同時出現2次:SPPSPP
        </p>
      </td>
    </tr>
    <tr style="height: 23px;">
      <td style="height: 23px;">\</td>
      <td style="height: 23px;">
        取消原運算符號的功能,使其成為單純文字<br />例:2014\-06\-13代表取消「-」符號功能,這與Java的跳脫符號<br />「\」相同,所以結果一定要是2014-06-13
      </td>
    </tr>
  </tbody>
</table>

- 可搭配 String 類別提供的 boolean matches(String regex),回傳是否符
  合正規表示法的文字格式

- 另介紹 String 類別的 String[] split(String regex),符合運算式的部份會
  被當做分隔符號移除掉,剩下部份回傳到字串陣列裡

# Regex 範例與練習

- 手機號驗證

```java
package ch05;

import java.util.Scanner;

public class RegTest {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    System.out.println("請輸入手機號碼");
    String tel = sc.next();
    sc.close();

    String regex = "09[0-9]{2}-\\d{6}";
    if (tel.matches(regex)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }
  }
}
```

- [身分證字號驗證](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/320404/)

- 官方文件的 `java.util.regex` 中有詳細使用說明

```java
package ch05;

import java.util.Scanner;

public class RegTest {
  public static void main(String[] args) {
    Scanner sc2 = new Scanner(System.in);
    System.out.println("請輸入身分證");
    String IDcard = sc2.next();
    String regex2 = "[A-Za-z]{1}[12]{1}[0-9]{8}";

    if (IDcard.matches(regex2)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }

    // /p{Alpha} 忽略大小寫
    String regex3 = "^\\p{Alpha}[12]\\d{8}$";
    if (IDcard.matches(regex3)) {
      System.out.println("OK");
    } else {
      System.out.println("No good...");
    }
    sc2.close();
  }
}
```

- 特殊處裡

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestSplit2.java"
```

```java
package ch05;

public class TestSplit2 {
  public static void main(String args[]) {

    String str1 = "boo:and:foo";

    // 因為不是最後一個字所以中間的O會變成空字串保留
    String[] tokens1 = str1.split(":"); // { "boo", "and", "foo" }
    for (int i = 0; i < tokens1.length; i++) {
      System.out.println(tokens1[i]);
    }

    System.out.println("-----------------------");

    String[] tokens2 = str1.split("o"); // { "b", "", ":and:f" } //參考String API文件的split方法
    for (int i = 0; i < tokens2.length; i++) {
      System.out.println(tokens2[i]);
    }

    System.out.println("-----------------------");

    // 正規表示法方式，解決所有O，正規處理後大數據工程師稱為wash data(清洗資料)
    String[] tokens3 = str1.split("o+"); // { "b", ":and:f" } //+指任意多個重複的字元
    for (int i = 0; i < tokens3.length; i++) {
      System.out.println(tokens3[i]);
    }

    System.out.println("-----------------------");

    String str = "http://tw.yahoo.com";
    String[] tokens = str.split("[:/.]+"); // { "http", "tw", "yahoo", "com" } //[]指在[]中的任意一個字元

    for (int i = 0; i < tokens.length; i++) {
      System.out.println(tokens[i]);
    }
  }
}
```

# 取得日期與時間

- 取得今天的日期與現在時間

  - Calendar rightNow = Calendar.getInstance();

    - `Calendar`為`抽象類別`(因為有設為 static，所以可以用類別直接呼叫方法)

  - `java.util.Date rightNow` = new java.util.Date();

    - `java.util.Date`表示某一時間點(一般是使用 util 中的方法)

- 其它與日期有關的常用類別還有

  - `GregorianCalendar` 此為`Calendar 的子類別`,適合用來設定某一特定的日期

    - `GregorianCalendar` 建構子提供的時間點

  - `java.sql.Date` 此為 java.util.Date 的子類別,用在資料庫的日期格式

  - `DateFormat` 用來`格式化` java.util.Date,可設定國別格式與時區,用在國際化

  - `SimpleDateFormat` 用來`格式化` java.util.Date,簡單的日期格式化

- 註:

  - 利用 Calendar 物件的 getTime()方法,可產生 java.util.Date 物件

    - `java.util.Date du = cal.getTime();` cal 是 `Calendar` 物件

  - 利用 java.util.Date 物件的 getTime() 方法,可得到自 1970 年 1 月 1 日 0 時 0 分 0 秒起的`總毫秒數`

    - `long len = du.getTime();` du 是 `java.util.Date` 物件

    - **1970 年 1 月 1 日 0 時 0 分 0 秒** (這是系統的起始時間，用來紀念 UNIX)

# Calendar 類別常數

- 周末是周六，周日是一天的開始

<table>
<tbody>
<tr style="height: 23px;">
<td style="height: 23px;">常數名稱</td>
<td style="height: 23px;">值</td>
<td style="height: 23px;">注意</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.YEAR</td>
<td style="height: 23px;">年</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.MONTH</td>
<td style="height: 23px;">月</td>
<td style="height: 23px;">得到的值須<code>+1</code></td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.DATE</td>
<td style="height: 23px;">日</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.HOUR_OF_DAY</td>
<td style="height: 23px;">24時制的時</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.MINUTE</td>
<td style="height: 23px;">分</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.SECOND</td>
<td style="height: 23px;">秒</td>
<td style="height: 23px;">&nbsp;</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;">Calendar.DAY_OF_WEEK</td>
<td style="height: 23px;">星期幾</td>
<td style="height: 23px;">得到的值須<code>-1</code>，當索引值操作<br>["日", "一", "二", "三", "四", "五", "六"]</td>
</tr>
</tbody>
</table>

# java.util.Date 類別

- 在 Java 1.0.2 版中 java.util.Date 有數種功能,但在 `Java 1.1 開始,其中大部份的方法都已被淘汰(Deprecated)`,所以 java.util.Date 目前功能就是表示`某一時間點`

# Calendar 時間用法

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestCalendar.java"
```

```java
package ch05;

import java.util.Calendar;

public class TestCalendar {

  static String[] week = { "日", "一", "二", "三", "四", "五", "六" };

  public static void main(String args[]) {
    // 取得「執行環境」的系統時間
    Calendar cal = Calendar.getInstance();
    int y = cal.get(Calendar.YEAR);
    int m = cal.get(Calendar.MONTH) + 1;
    int d = cal.get(Calendar.DATE);
    int h = cal.get(Calendar.HOUR);
    int min = cal.get(Calendar.MINUTE);
    int sec = cal.get(Calendar.SECOND);
    System.out.print("今天是: ");
    System.out.println(y + "年" + m + "月" + d + "日");
    System.out.print("現在是: " + (cal.get(Calendar.AM_PM) == 0 ? "上午" : "下午"));
    System.out.println(h + "點" + min + "分" + sec + "秒");

    int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
    System.out.println("星期" + week[w]);

    System.out.println();
  }
}
```

# 時間之 Calendar 與 GregorianCalendar

```cs
範例程式: "/JavaEx_Part2/src/ch05/TestGregorianCalendar.java"
```

```java
package ch05;

import java.util.Calendar;
import java.util.GregorianCalendar;

public class TestGregorianCalendar {
  static String[] week = { "日", "一", "二", "三", "四", "五", "六" };

  public static void main(String args[]) {
    Calendar cal[] = new Calendar[6];
    cal[0] = new GregorianCalendar(2015, Calendar.JANUARY, 15, 0, 0, 0); // 到秒 second
    cal[1] = new GregorianCalendar(2014, Calendar.JANUARY, 1, 0, 0); // 到分 minute
    cal[2] = new GregorianCalendar(2014, Calendar.JUNE, 1); // 到日 month
    cal[3] = new GregorianCalendar(); // 現在
    cal[4] = new GregorianCalendar();
    cal[5] = new GregorianCalendar(1991, (5 - 1), 29);

    for (int i = 0; i < cal.length; i++)
      showTime(cal[i]);
  }

  static void showTime(Calendar cal) {
    int y = cal.get(Calendar.YEAR);
    int m = cal.get(Calendar.MONTH) + 1;
    int d = cal.get(Calendar.DATE);
    int h = cal.get(Calendar.HOUR_OF_DAY);
    int min = cal.get(Calendar.MINUTE);
    int sec = cal.get(Calendar.SECOND);
    System.out.print("日期: ");
    System.out.println(y + "年" + m + "月" + d + "日");
    System.out.print("時間: ");
    System.out.println(h + "點" + min + "分" + sec + "秒");

    int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
    System.out.println("星期" + week[w]);

    // 與LinkedList一樣，欲使用isLeapYear方法不可使用多型寫法，需使用GregorianCalendar型態建立GregorianCalendar物件
    // 閏年判斷
    boolean isLeap = ((GregorianCalendar) cal).isLeapYear(y);
    System.out.println(isLeap);
  }
}
```

# 簡易格式化輸出

- Simple Formatter Output(簡易的格式化輸出:printf)

  - JDK 5 新增 System.out.printf()方法
  - printf() 方法源自於 java.util.Formatter 類別
  - 比如只需寫出: `"%tY/%<tm/%<td %<tT%n"`

    - `<` 沿用前面使用的參數資料

    - 即可輸出:2014/06/13 17:38:20 之結果

```java
java.util.Date d = new java.util.Date();
System.out.printf("%tY/%<tm/%<td %<tT%n", d);
```

- 範例

  - TestFormatter.java
    (printf()對照 DecimalFormat 與 SimpleDateFormat 類別)
  - TestDateFormat.java
    (熟悉 java.text.DateFormat 類別之應用)

- SimpleDateFormat 可以直接對日期做簡易格式化
  - `Format sfm = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");`

```CS
範例程式: "/JavaEx_Part2/src/ch05/TestFormatter.java"
```

```JAVA
package ch05;

import static java.lang.System.out;

import java.text.DecimalFormat;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.Date;

public class TestFormatter {
	public static void main(String[] args) {

		out.println("------------------數字格式化-------------------");

		double num1 = 12345.678;
		out.println(num1 + "【格式化之前】\n");

		// 使用DecimalFormat類別
		Format dfm1 = new DecimalFormat("#,###.00");
		out.println(dfm1.format(num1) + "【使用DecimalFormat類別格式化】");

		// 使用printf
		out.printf("%,.2f【使用printf格式化】%n", num1);

		out.println("\n------------------日期格式化-------------------");

		Date d1 = new Date();
		out.println(d1 + "【格式化之前的java.util.Date】\n");

		Format sfm1 = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		out.println(sfm1.format(d1) + "【使用SimpleDateFormat類別格式化】");
		Format sfm2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		out.println(sfm2.format(d1) + "【使用SimpleDateFormat類別格式化】\n");

		out.printf("%tY/%<tm/%<td %<tT【使用printf格式化】%n", d1);
		out.printf("%tF %<tT【使用printf格式化】%n", d1);

		out.println("\n-----------------------------------------------");

		out.printf("我叫%s, 今年%d歲%n", "Peter", 18); // %s字串 , %d整數 , %n換行
		out.printf("PI值趨近於%f ,而自然對數E趨近於%f%n", Math.PI, Math.E); // %f浮點數
		out.printf("PI值不是null: %b", Math.PI); // %b非null為true , null為false

	}
}
```
