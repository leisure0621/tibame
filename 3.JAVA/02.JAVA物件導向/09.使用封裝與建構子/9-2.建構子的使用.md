<h1 id="top">目錄</h1>

- [1. 區分建構子與類別依據](#s1)
- [2. 建構子的目的](#s2)
- [3. 實際用例](#s3)

---

# <a id="s1" class="md-title" href="#top">1. 區分建構子與類別依據</a>

- 建構子跟類別名稱(class name)相同

- 建構子沒有回傳(return)，因為建構子不允許回傳值

  - <code>public void PenGood(...)&#123;...&#125;</code> 方法

  - <code>public PenGood(...)&#123;...&#125;</code> 建構子

    - 不用寫 void，寫了就變方法

- 一個類別可以有多個建構子

  - 建構子可使用 [Overload](https://www.runoob.com/java/java-override-overload.html)

- 使用建構子一定要 `new` (建構子代表一個物件的出生，所以只執行一次)

  - `PenGood p = new PenGood();`

- Java 會預設給一個不帶參數的建構子，一旦宣告其他建構子則 Java 會自動將此預設建構子移除

  - `PenGood p = new PenGood();` 預設建構子

  - `PenGood p = new PenGood("123", 100);` 自訂建構子

# <a id="s2" class="md-title" href="#top">2. 建構子的目的</a>

- 解決在創建物件時，能更簡化該物件屬性初始值的設定動作

# <a id="s3" class="md-title" href="#top">3. 實際用例</a>

- ```java
  public class PenGood {
    private String brand;
    private double price;

    public PenGood(String brandXXX, double priceXXX) { // PenGood 為建構子
      setBrand(brandXXX);
      setPrice(priceXXX);
    }

    public String getBrand() {
      return brand;
    }

    public void setBrand(String brandXXX) {
      brand = brandXXX;
    }

    public double getPrice() {
      return price;
    }

    public void setPrice(double priceXXX) {
      if (priceXXX > 0)
        price = priceXXX;
      else
        System.out.println("請確認售價設定");
    }
  }
  ```

  ***

  ```java
  package ch09;

  /*
  * 試著操作給不同的值
  * 看結果有何變化
  */
  public class PenTestGood {
    public static void main(String[] args) {
      PenGood p = new PenGood("123", 100);

      System.out.println(p.getBrand());
      System.out.println(p.getPrice());

    }
  }
  ```
