<h1 id="top">目錄</h1>

- [1. 包裝類別(Wrapper Class)](#s1)
- [2. 類別類型測試](#s2)
- [3. 裝箱拆箱](#s3)
- [4. 型別轉換](#s4)
- [5. 自動裝箱/拆箱(Autoboxing/Unboxing)](#s5)

---

# <a id='s1' class='md-title' href='#top'>1. 包裝類別(Wrapper Class)</a>

- Java 每一個基本資料型態都有一個相對應的 Wrapper 類別(包裝類別)

- boxing: 將基本型別，置入相對應的包裝類別中(裝箱/包裝)

- 比較兩物件是否相等

  - 包裝類別都已經 override equals 方法了

  - 所以比較是否相等的話是使用 boolean equals(Object obj);<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>

- <table>
  <thead>
  <tr>
  <th style="text-align:center">基本資料型態</th>
  <th style="text-align:center">包裝類別</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align:center">byte</td>
  <td style="text-align:center">java.lang.Byte</td>
  </tr>
  <tr>
  <td style="text-align:center">short</td>
  <td style="text-align:center">java.lang.Short</td>
  </tr>
  <tr>
  <td style="text-align:center">int</td>
  <td style="text-align:center">java.lang.Integer</td>
  </tr>
  <tr>
  <td style="text-align:center">long</td>
  <td style="text-align:center">java.lang.Long</td>
  </tr>
  <tr>
  <td style="text-align:center">float</td>
  <td style="text-align:center">java.lang.Float</td>
  </tr>
  <tr>
  <td style="text-align:center">double</td>
  <td style="text-align:center">java.lang.Double</td>
  </tr>
  <tr>
  <td style="text-align:center">boolean</td>
  <td style="text-align:center">java.lang.Boolean</td>
  </tr>
  <tr>
  <td style="text-align:center">char</td>
  <td style="text-align:center">java.lang.Char</td>
  </tr>
  </tbody>
  </table>

- **整數型態**跟**浮點數型態**，都是 java.lang.Number 的子類別

# <a id='s2' class='md-title' href='#top'>2. 類別類型測試</a>

- Integer 即 int 型別測試

  ```java
  package ch13;

  public class ShallowCopy {
    public static void main(String[] args) {
      Integer i = new Integer(10);
      Integer j = new Integer(10);

      System.out.println(i == j);
      System.out.println(i.equals(j));
    }
  }
  ```

# <a id='s3' class='md-title' href='#top'>3. 裝箱拆箱</a>

- 裝拆箱測試

  ```java
  package ch13;

  public class ShallowCopy {
    public static void main(String[] args) {
      Integer i = new Integer(10); // boxing(裝箱)
      Integer j = new Integer(10);

      int i3 = i1.intValue(); // unboxing(拆箱)
    }
  }
  ```

# <a id='s4' class='md-title' href='#top'>4. 型別轉換</a>

- 文字轉數字

  ```java
  package ch13;

  public class ShallowCopy {
    public static void main(String[] args) {
      String s1 = "123";
      int i1 = Integer.parseInt(s1);

      System.out.println(i1 + 100);
    }
  }
  ```

# <a id='s5' class='md-title' href='#top'>5. 自動裝箱/拆箱(Autoboxing/Unboxing)</a>

- JDK5 加入的功能，由編譯器幫我們處裡裝/拆箱

- Autoboxing(自動裝箱)

  - 基本資料型別自動轉為包裝型態(Wrapper Types)，如 int 轉 Integer

- Unboxing(自動拆箱)

  - 包裝型態自動轉為基本資料型別，如 Integer 轉 int

  ```java
  package ch13;

  /*
  說明:
  int 包裝成 Integer 稱之為 Autoboxing，反之則是 Auto-unboxing。

  在 Java 中的八種基本型別，分別是 byte, short, int, long,
  float, double, char 和 boolean。
  理論上來說，真正的物件導向中的型別應該都必須是類別定義，
  像是 Short, Integer 等等類別。
  不過為了我們使用上的方便，Java 提供了基本型別。
  同時存在這兩種型別常常會造成我們在設計上要加上許多額外的程式碼，
  例如在做數字運算時，使用 int 或 double 型別來處理，
  但是要將數字存入容器時，必須要將其轉換成 Integer 或 Double 型別，
  才能使用 add(new Integer(i))，
  在使用容器或多型處理時常常要多一道轉型手續。
  Java 1.5 中，已經增加了這方面的處理，
  稱之為 Autoboxing 和 Auto-unboxing，
  編譯器會自動幫我們在 int 和 Integer 之中轉換。
  */

  public class TestAutoboxing {

    public static void main(String[] args) {
      Integer i1 = 1; // boxing
      int i2 = i1; // unboxing

      int sum1 = i1 + i2;
      Integer sum2 = i1 + i2;
      System.out.println(sum1);
      System.out.println(sum2);
    }
  }
  ```

---

<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>跟 String 做法相同 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
